<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>操作系统 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述四大基本特征 并发：一段时间内多个程序同时运行（并行是一个时刻多个指令同时运行） 共享：资源共享 虚拟：虚拟地址，为物理硬件提供逻辑接口来降低使用难度 异步：进程走走停停，上下文切换  基本功能 进程管理 内存管理 文件管理 设备管理  用户态和内核态区别操作系统的两种运行级别  用户态： R3特权级，特权最低 进程所能访问的内存空间和对象受到限制 占有的处理器可被抢占   内核态： R0特权">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2021/01/17/os/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述四大基本特征 并发：一段时间内多个程序同时运行（并行是一个时刻多个指令同时运行） 共享：资源共享 虚拟：虚拟地址，为物理硬件提供逻辑接口来降低使用难度 异步：进程走走停停，上下文切换  基本功能 进程管理 内存管理 文件管理 设备管理  用户态和内核态区别操作系统的两种运行级别  用户态： R3特权级，特权最低 进程所能访问的内存空间和对象受到限制 占有的处理器可被抢占   内核态： R0特权">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01171.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01173.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01181.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01182.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01183.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01291.jpg">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01292.jpg">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01293.jpg">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02211.jpg">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02212.jpg">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02213.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02214.jpg">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03031.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02251.png">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02252.png">
<meta property="article:published_time" content="2021-01-17T08:13:39.000Z">
<meta property="article:modified_time" content="2021-08-25T06:31:55.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01171.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-os" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/17/os/" class="article-date">
  <time class="dt-published" datetime="2021-01-17T08:13:39.000Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      操作系统
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="四大基本特征"><a href="#四大基本特征" class="headerlink" title="四大基本特征"></a>四大基本特征</h2><ul>
<li>并发：一段时间内多个程序同时运行（并行是一个时刻多个指令同时运行）</li>
<li>共享：资源共享</li>
<li>虚拟：虚拟地址，为物理硬件提供逻辑接口来降低使用难度</li>
<li>异步：进程走走停停，上下文切换</li>
</ul>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul>
<li>进程管理</li>
<li>内存管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>操作系统的两种运行级别</p>
<ul>
<li>用户态：<ul>
<li>R3特权级，特权最低</li>
<li>进程所能访问的内存空间和对象受到限制</li>
<li>占有的处理器可被抢占</li>
</ul>
</li>
<li>内核态：<ul>
<li>R0特权级，特权最高；</li>
<li>能访问所有的内存空间和对象</li>
<li>占有的处理器不允许被抢占</li>
</ul>
</li>
</ul>
<h3 id="用户态到内核态的切换（三种中断）"><a href="#用户态到内核态的切换（三种中断）" class="headerlink" title="用户态到内核态的切换（三种中断）"></a>用户态到内核态的切换（三种中断）</h3><p>其实就是三种中断</p>
<ul>
<li><p><strong>外中断</strong></p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序</p>
</li>
<li><p><strong>异常</strong></p>
<p>当 CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</p>
</li>
<li><p><strong>系统调用</strong></p>
<p>这是用户态进程主动要求切换到内核态的一种方式<strong>，</strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。比如前例中fork()实际上就是执行了一个创建新进程的系统调用。常见的系统调用还有 <code>read, write, open, create, close, readv, writev, fork, wait, exit, execve, clone</code> 等等</p>
</li>
</ul>
<h2 id="宏内核和微内核"><a href="#宏内核和微内核" class="headerlink" title="宏内核和微内核"></a>宏内核和微内核</h2><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>微内核是将一部分操作系统功能移出内核，从而降低内核的复杂性。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和内核态之间进行切换，所以会有一定的性能损失。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程的区别和联系"><a href="#进程与线程的区别和联系" class="headerlink" title="进程与线程的区别和联系"></a>进程与线程的区别和联系</h2><p>进程：资源分配的基本单位，由<strong>线程+内存+文件/网络句柄</strong>构成</p>
<p>线程：独立调度的基本单位，由 <strong>栈+PC(程序计数器)+TLS(线程本地存储)</strong> 组成</p>
<p>比如QQ和浏览器是两个进程，浏览器内的http请求是一个线程、渲染是一个线程。</p>
<p><strong>联系：</strong></p>
<p>进程是线程的容器，一个进程中可以并发多个线程，不同的线程共享进程的资源（堆），同一进程的线程各自维护自己的栈。</p>
<p><strong>区别：</strong></p>
<ul>
<li>资源：操作系统会给每个进程分配资源，但线程不会，只能共享进程的资源</li>
<li>开销：由于要分配回收资源，创建撤销进程的开销远大于创建撤销线程的开销</li>
<li>通信：线程通信更简单，直接读写同一进程中的数据；进程通信需要通过IPC（进程间通信）</li>
</ul>
<h2 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h2><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01171.png"></p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>没有太多的用户操作，目标是保证吞吐量和周转时间（从提交到终止的时间）</p>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>first-come first-serverd（FCFS）</p>
<p>非抢占式的调度算法，按照请求的顺序进行调度</p>
<ul>
<li><p>优点：任何进程不会饥饿</p>
</li>
<li><p>缺点：不利于短作业。</p>
<p>短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
</ul>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>shortest job first（SJF）</p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</p>
<ul>
<li>优点：对短作业友好</li>
<li>缺点：长作业可能会饥饿（解决方案，设定阈值，年龄超过阈值使用先来先服务）</li>
</ul>
<h4 id="最短剩余时间优先（抢）"><a href="#最短剩余时间优先（抢）" class="headerlink" title="最短剩余时间优先（抢）"></a>最短剩余时间优先（抢）</h4><p>shortest remaining time next（SRTN）</p>
<p>抢占式调度算法，按剩余运行时间顺序调度。</p>
<p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p>有大量的用户交互操作，目标是快速响应</p>
<h4 id="时间片轮转（抢）"><a href="#时间片轮转（抢）" class="headerlink" title="时间片轮转（抢）"></a>时间片轮转（抢）</h4><p>所有就绪进程按先来先服务原则排成一个队列，给队首一个时间片执行，执行结束放到队尾，再给新的队首一个时间片执行。</p>
<p>效率取决于<strong>时间片长度</strong>的设置，太短切换浪费过多时间，太长实时性得不到保证</p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h4 id="多级反馈队列（抢）"><a href="#多级反馈队列（抢）" class="headerlink" title="多级反馈队列（抢）"></a>多级反馈队列（抢）</h4><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01173.png"></p>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对临界资源进行访问的那段代码称为临界区</p>
<p>同一时刻内同一段<strong>代码</strong>可能会有多个<strong>进程</strong>在执行，同一时刻只允许一个进程位于临界区内。</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//进入区</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="comment">//退出区</span></span><br><span class="line">	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>

<p>临界区实现方式：</p>
<ul>
<li>非抢占内核：没有竞争</li>
<li>抢占内核：<ul>
<li>软件实现：使用两个变量记录是否有进程位于临界区以及哪个进程位于临界区</li>
<li>硬件实现：锁。进程在进入临界区前检测并申请锁，离开后释放锁。</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来协调进程对共享资源的访问</p>
<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
<p>信号量是一个特殊的整型变量，程序对其访问都是<strong>原子操作</strong>，且只允许对它进行等待(<code>P(sv)</code>) 和发送(<code>V(sv)</code>)信息操作。</p>
<ul>
<li><strong>P(sv)等待：</strong>如果 <code>sv</code> 的值大于零，就给它减 <code>1</code> ；如果它的值为零，就<strong>挂起</strong>该进程的执行</li>
<li><strong>V(sv)发送：</strong>如果有其他进程因等待 <code>sv</code> 而被挂起，就让它恢复运行，如果没有进程因等待 <code>sv</code> 而挂起，就给它加 <code>1</code> 。</li>
</ul>
<p>举个例子，就是两个进程共享信号量 <code>sv</code> ，一旦其中一个进程执行了 <code>P(sv)</code> 操作，它将得到信号量，并可以进入临界区，使 <code>sv</code> 减1。而第二个进程将被阻止进入临界区，因为当它试图执行 <code>P(sv)</code> 时，<code>sv</code> 为 <code>0</code> ，它会被挂起以等待第一个进程离开临界区域并执行 <code>V(sv)</code> 释放信号量，这时第二个进程就可以恢复执行。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程模型里，只能有一个进程或线程在执行。java用sychronize+wait notify来实现，即互斥锁+条件变量。</p>
<p>信号量是和资源绑定的，资源最多可以给多少个进程用，s就设置为多少，减到0了就阻塞了。管程只让一个进程运行。信号量和管程可以互相实现。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>两种管道、两种信号、socket、消息队列、共享内存</p>
<h3 id="管道（无名）"><a href="#管道（无名）" class="headerlink" title="管道（无名）"></a>管道（无名）</h3><p>当一个进程创建了一个管道，并调用 <code>fork</code> 创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。 </p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01181.png"></p>
<p>无名管道创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>当一个管道建立时，它会创建两个文件描述符(<strong>fd</strong>)：</p>
<ul>
<li><code>filedis[0]</code> 用于读管道。</li>
<li><code>filedis[1]</code> 用于写管道。</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>半双工</strong>，数据只能单向流动</li>
<li>只能在父子进程或者兄弟进程中使用</li>
<li>数据被进程从管道读出后，在管道中该数据就不存在了</li>
<li>进程去<strong>读取空管道</strong>的时候，进程会阻塞</li>
<li>进程去<strong>写入满管道</strong>的时候，进程会阻塞</li>
<li>管道容量为 <strong>64KB</strong>(缓存区有限)</li>
<li>必须在系统调用<code>fork( )</code>前调用<code>pipe( )</code>，否则子进程将不会继承文件描述符</li>
</ul>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>有名管道，和无名管道基本相同，去除了管道只能在父子进程中使用的限制，<strong>不相关的进程也能交换数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>

<p>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01182.png" style="zoom: 67%;" />

<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：缓冲区有限</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识</p>
<p>建立一个队列，先放入队列的消息被最先取出。和管道不同的是，消息队列<strong>允许多个进程放入消息，也允许多个进程取出消息</strong>。每个消息可以带有一个整数识别符( <code>message_type</code> )。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照<strong>先进先出</strong>的顺序取出，也可以<strong>只取出符合某个识别符的消息</strong>(有多个这样的消息时，同样按照先进先出的顺序取出)。</p>
<p>克服了<strong>信号传递信息少</strong>、<strong>管道只能承载无格式字节流以及缓冲区大小受限</strong>等缺点</p>
<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存<strong>由一个进程创建，但多个进程都可以访问</strong>。</p>
<p>共享内存是⭐<strong>最快</strong>⭐的 <code>IPC(interprocess communication)</code> 方式，它是<strong>针对其他进程间通信方式运行效率低而专门设计</strong>的。它往往与其他通信机制，如<strong>信号量配合使用</strong>，来实现进程间的同步和通信。</p>
<ul>
<li><p>优点：无须复制，快捷，信息量大</p>
</li>
<li><p>缺点</p>
<ul>
<li><p>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题(映射到<strong>文件映射段</strong>)</p>
</li>
<li><p>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</p>
</li>
</ul>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>通知接收进程某个事件已经发生</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>可用于不同机器间的进程通信</p>
<ul>
<li>优点：<ol>
<li>传输数据为<strong>字节级</strong>，传输数据<strong>可自定义</strong>，数据量小效率高</li>
<li>传输数据<strong>时间短</strong>，<strong>性能高</strong></li>
<li>适合于客户端和服务器端之间信息<strong>实时交互</strong></li>
<li>可以<strong>加密</strong>，<strong>数据安全性强</strong></li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（ reader-writer lock ）、自旋锁（ spin lock ）、条件变量（ condition variable ）</li>
<li>信号量机制( Semaphore )</li>
<li>信号机制( Signal )：类似进程间的信号处理</li>
</ol>
<p>线程使用共享内存，所以数据是互通的。线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>是一种比线程更加轻量级的存在，主要就是为了减少线程切换的资源消耗。</p>
<p><strong>一个线程里可以有多个协程</strong>，它不是被操作系统内核所管理的，而是完全由程序所控制，也就是在<strong>用户态</strong>执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>一个线程的多个协程虽然可以切换，但运行是<strong>串行</strong>的。当一个协程运行时，其它协程必须挂起。</p>
<p>同一个线程中通过保存代码执行段状态，进行代码段的分次执行，以及多个代码段的交织执行。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ul>
<li><strong>进程</strong>的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。</li>
<li><strong>线程</strong>的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。</li>
<li><strong>协程</strong>的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高.</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>一组互相竞争资源的线程因互相等待，导致<strong>永久阻塞</strong>的现象。说白了就是：两个线程互相持有对方所需的资源，互不释放且互相等待</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>产生死锁必须同时满足以下四个条件</p>
<ul>
<li><strong>互斥</strong>：进程申请的资源在一段时间内只能被一个进程使用</li>
<li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源，但对自己已获得的资源保持不放。</li>
<li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h3 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<p>检测：有向图有环</p>
<p>恢复：</p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>在程序运行之前预防发生死锁。</p>
<p>破坏四个必要条件</p>
<ul>
<li><p>破坏互斥条件</p>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
</li>
<li><p>破坏占有和等待条件</p>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源</p>
</li>
<li><p>破坏不可抢占条件</p>
</li>
<li><p>破坏环路等待</p>
<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>在程序运行时避免发生死锁</p>
<p><strong>银行家算法</strong></p>
<p>假设释放一个进程，然后把这个进程已分配的资源回收到剩余资源中，然后再找下一个能在剩余可用资源中被释放的进程。以此类推，如果都能被释放，系统处于安全状态，不会死锁。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01183.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<p>解决办法：线程谦让时，尝试等待一个随机的时间就可以了</p>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>低优先级的线程资源一直被高优先级抢占</p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO操作分两步：</p>
<ol>
<li><strong>等待数据：</strong>用户进程向内核发起 <code>IO</code> 请求，等待内核数据准备</li>
<li><strong>数据拷贝：</strong>将数据从<strong>内核</strong>拷贝到<strong>进程缓存区</strong>中</li>
</ol>
<p>五种模型记忆方式：</p>
<ul>
<li>数据没准备好，用户进程就一直等（阻塞IO）</li>
<li>用户进程不想一直等，就隔段时间来检查一次，即轮询（非阻塞IO）</li>
<li>用户进程不想管这事，交给中间人select，数据好了select会通知对应的用户进程（IO多路复用）</li>
<li>不想有中间人，直接内核来通知（信号驱动式IO）</li>
</ul>
<p>以上四种都是同步IO，根据<strong>等待数据</strong>分类，在拷贝数据时都是阻塞的。</p>
<ul>
<li>拷贝数据不阻塞（异步IO）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20161028200140849"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01291.jpg" alt="img"></a></p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>
<p>特点：</p>
<ol>
<li><strong>进程阻塞挂起不消耗CPU资源，及时响应每个操作</strong>；</li>
<li>实现难度低、开发应用较容易；</li>
<li>适用并发量小的网络应用开发；</li>
<li><strong>不适用并发量大的应用</strong>：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</li>
</ol>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程</p>
<p>典型应用：<strong>socket</strong>是非阻塞的方式（设置为NONBLOCK）</p>
<p><strong>阻塞IO模型是一个阻塞IO调用，而非阻塞IO模型是多个非阻塞IO调用+一个阻塞IO调用，因为多个IO检查会立即返回错误，不会阻塞进程。</strong></p>
<p>特点：</p>
<ol>
<li><strong>进程轮询（重复）调用，消耗CPU的资源</strong>；</li>
<li>实现难度低、开发应用相对阻塞IO模式较难；</li>
<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>
</ol>
<hr>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>多个的进程的IO可以注册到一个复用器(<code>select</code>)上，然后用一个进程调用该 <code>select</code> ， <code>select</code> 会监听所有注册进来的IO；如果 <code>select</code> 监听的IO在内核缓冲区都没有可读数据，<code>select</code> 调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，<code>select</code> 调用就会返回；而后 <code>select</code> 调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，<strong>多个进程注册IO后，只有另一个select调用进程被阻塞。</strong></p>
<p><strong>典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;</strong></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>专一进程解决多个进程IO的阻塞问题，性能好</strong>；<strong>Reactor模式;</strong></li>
<li>实现、开发应用难度较大；</li>
<li><strong>适用高并发服务应用开发：一个进程（线程）响应多个请求</strong>；</li>
</ol>
<h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><p>当进程发起一个IO操作，会向内核注册一个<strong>信号处理函数</strong>，然后进程<strong>返回不阻塞</strong>；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据.</p>
<p><strong>特点：回调机制，</strong>实现、开发应用难度大；</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。<strong>如果IO操作成功则进程直接获取到数据</strong>。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>不阻塞，数据一步到位</strong>；<strong>Proactor模式</strong>；</li>
<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>
<li>实现、开发应用难度大；</li>
<li>非常适合高性能高并发应用；</li>
</ol>
<h2 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>在计算机领域常说的 <code>I/O</code> 包括磁盘 <code>I/O</code> 和网络 <code>I/O</code> ，我们所说的 <code>I/O</code> 复用主要是指网络 <code>I/O</code> ，在 <code>Linux</code> 中一切皆文件，因此网络 <code>I/O</code> 也经常用文件描述符 <code>FD</code> 来表示。</p>
<p>多个描述符的IO操作都能在一个线程内并发交替地顺序完成，这就叫IO多路复用。</p>
<p>复用指的是复用同一个进程/线程。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>简单来说就是：select去看IO是否就绪（读、写、异常三种文件描述符），好了就启动用户线程。</p>
<p>描述符集合底层用数组实现。</p>
<p>下面是详细介绍，重点是那个select函数。</p>
<p><a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01292.jpg" alt="img"></a></p>
<p><code>select</code> 使用一个宏定义函数按照 <code>bitmap</code> 原理填充 <code>fd</code> ，默认大小是 <code>1024</code> 个，因此对于 <code>fd</code> 的数值大于 <code>1024</code> 都可能出现问题。</p>
<p><code>select</code> 函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。</p>
<p><strong>运行机制：</strong></p>
<p><code>select</code>会将全量<code>fd_set</code>从用户空间拷贝到内核空间，并注册回调函数， 在内核态空间来判断每个请求是否准备好数据 。<code>select</code>在没有查询到有文件描述符就绪的情况下，将一直阻塞（I/O多路服用中提过：select是一个阻塞函数）。如果有一个或者多个描述符就绪，那么select将就绪的文件描述符置位，然后select返回。返回后，由程序遍历查看哪个请求有数据。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，fd越多开销则越大；</li>
<li>每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量有限，默认是1024。</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值：就绪描述符的数目，超时返回 <code>0</code> ，出错返回 <code>-1</code> 。</p>
<p>函数参数介绍如下：</p>
<ol>
<li>第一个参数 <code>maxfdp1</code> 指定待测试的描述字个数，它的值是待测试的最大描述字加 <code>1</code> （因此把该参数命名为<code>maxfdp1</code> ），描述字 <code>0、1、2...maxfdp1 - 1</code> 均将被测试。因为文件描述符是从 <code>0</code> 开始的。</li>
<li>中间的三个参数 <code>readset</code> 、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是<strong>文件描述符FD</strong>，可通过以下四个宏进行设置：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 检查集合中指定的文件描述符是否可以读写</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>timeval *timeout</code> 告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个参数有三种可能：</p>
<p>（1）永远等待下去：仅在有一个描述字准备好 <code>I/O</code> 时才返回。为此，把该参数设置为空指针 <code>NULL</code> 。</p>
<p>（2）等待一段固定时间：在有一个描述字准备好 <code>I/O</code> 时返回，但是不超过由该参数所指向的 <code>timeval</code> 结构中指定的秒数和微秒数。</p>
<p>（3）根本不等待：检查描述字后立即返回，这称为<strong>轮询</strong>。为此，该参数必须指向一个 <code>timeval</code> 结构，而且其中的定时器值必须为 <code>0</code> 。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>poll</code> 与 <code>select</code></p>
<ul>
<li>相似点：管理多个描述符都是进行<strong>轮询</strong>，根据描述符的状态进行处理。</li>
<li>不同点： <ul>
<li><code>poll</code> 使用<strong>链表</strong>实现，没有最大文件描述符数量的限制；</li>
<li><code>select</code>使用<strong>数组</strong>实现，最多1024个文件描述符。</li>
</ul>
</li>
</ul>
<p><strong>共同的缺点：</strong></p>
<p>包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，包括未就绪的文件描述符，它的开销随着文件描述符数量的增加而线性增大。</p>
<p>下面是详细介绍</p>
<p>函数格式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>pollfd</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         	  <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;        <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>每一个 <code>pollfd</code> 结构体指定了一个<strong>被监视的文件描述符</strong>，可以传递多个结构体，指示 <code>poll()</code> 监视多个文件描述符。每个结构体的 <code>events</code> 域是监视该文件描述符的事件掩码，由用户来设置这个域。<code>revents</code> 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<code>events</code> 域中请求的任何事件都可能在 <code>revents</code> 域中返回。合法的事件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 　　　　　　　　有数据可读。</span><br><span class="line">POLLRDNORM 　　　　  有普通数据可读。</span><br><span class="line">POLLRDBAND　　　　　 有优先数据可读。</span><br><span class="line">POLLPRI　　　　　　　　 有紧迫数据可读。</span><br><span class="line">POLLOUT　　　　　　      写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM　　　　　  写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND　　　　　   写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL 　　　　消息可用。</span><br></pre></td></tr></table></figure>

<p>此外，<code>revents</code> 域中还可能返回下列事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLLER　　   指定的文件描述符发生错误。</span><br><span class="line">POLLHUP　　 指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL　　指定的文件描述符非法。</span><br></pre></td></tr></table></figure>

<p><code>timeout</code> 参数指定等待的毫秒数，无论 <code>I/O</code> 是否准备好，<code>poll</code> 都会返回。<code>timeout</code> 指定为负数值表示无限超时，使 <code>poll()</code> 一直挂起直到一个指定事件发生；<code>timeout</code> 为 <code>0</code> 指示 <code>poll</code> 调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，<code>poll()</code> 就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong><br>成功时，<code>poll()</code> 返回结构体中 <code>revents</code> 域不为 <code>0</code> 的文件描述符个数；如果在超时前没有任何事件发生，<code>poll()</code> 返回 <code>0</code> ；失败时，<code>poll()</code> 返回 <code>-1</code> ，并设置 <code>errno</code> 为下列值之一。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><code>epoll</code> <strong>使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的 <code>copy</code> 只需一次。</p>
<ul>
<li><code>poll_ctl()</code>用于向内核<strong>注册</strong>新的描述符或者<strong>改变</strong>描述符的状态</li>
<li>已注册的描述符存储在内核的<strong>红黑树</strong>上</li>
<li>IO就绪的描述符会加入到<strong>链表</strong>中</li>
<li>用户进程调用<code>epoll_wait()</code>可以得到就绪的IO描述符</li>
</ul>
<p>如图展示了红黑树、双链表、epitem之间的关系：</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMj1rxibhibqZx2wKJiaFvWic5iaqcOzoicHQVQ07GHIveN1Sb0ZV2tEQLic5nw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01293.jpg" alt="图片" style="zoom:67%;" /></a></p>
<p>工作模式：</p>
<ul>
<li>LT模式（默认）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序<strong>可以不立即处理</strong>该事件。下次调用epoll_wait时，<strong>会再次响应</strong>应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序<strong>必须立即处理</strong>该事件。如果不处理，下次调用epoll_wait时，<strong>不会再次响应</strong>应用程序并通知此事件。</li>
</ul>
<p>LT更安全，ET更高效；</p>
<p>LT可以使用阻塞或者非阻塞IO，ET必须用非阻塞IO防止其他任务饿死。</p>
<p>ET模式指的是当数据从无到有时，才通知该fd。数据读不完，也不会再次通知，所以read时一定要采用循环的方式一直读到read函数返回-1为止。此时采用阻塞的read，那么就阻塞了整个线程。</p>
<p>常见问题：</p>
<ul>
<li><p>使用epoll是否需要将socket设置为nonblocking?</p>
<p>取决于你使用的触发方式， 如果你使用水平触发(Level-triggered) 那么此时的 <code>epoll</code> 相当于高级的 <code>select</code> ， 你的论述是对的， 是不需要一定将 <code>socket</code> 设置为非阻塞的; 然而， 当你使用边缘触发(Edge-triggered) 那么此时从业务的完整性考虑， 是建议将 <code>socket</code> 设置为 <code>nonbocking</code> 模式， 并且在读写触发 <code>EAGAIN</code> 之后再进行<code>epoll_wait</code> 。</p>
</li>
<li><p>epoll的优点</p>
<ol>
<li><strong>没有最大并发连接的限制</strong>。能打开的 <code>FD</code> 的上限远大于 <code>1024</code>（ <code>1G</code> 的内存上能监听约10万个端口）</li>
<li><strong>效率提升，不是轮询而是回调</strong>。不会随着 <code>FD</code> 数目的增加效率下降。只有活跃可用的 <code>FD</code> 才会调用 <code>callback</code> 函数。即 <code>Epoll</code> 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>Epoll</code> 的效率就会远远高于 <code>select</code> 和 <code>poll</code> 。</li>
</ol>
</li>
<li><p>LT和ET的读写问题</p>
<ol>
<li>LT<ul>
<li>read<ul>
<li><code>LT</code> 对于 <code>read</code> 操作比较简单，有 <code>read</code> 事件就读，读多读少都没有问题。</li>
</ul>
</li>
<li>write<ul>
<li>但是 <code>write</code> 就不那么容易了，一般来说<strong>socket在空闲状态时发送缓冲区一定是不满的</strong>，假如 <code>fd</code> 一直在监控中，那么会一直通知写事件，不胜其烦。</li>
<li>所以必须<strong>保证没有数据要发送的时候，要把 <code>fd</code> 的 <code>写</code> 事件监控从 <code>epoll</code> 列表中删除</strong>，<strong>需要的时候再加入回去，如此反复</strong>。</li>
<li>对应 <code>write</code> 的过度提醒，需要使用者随用随加，否则将一直被提醒可写事件。</li>
</ul>
</li>
</ul>
</li>
<li>ET<ul>
<li>read<ul>
<li><code>fd</code> 可读则返回可读事件，若开发者没有把所有数据读取完毕，<code>epoll</code> 不会再次通知 <code>read</code> 事件。</li>
<li>也就是说如果没有全部读取所有数据，那么导致 <code>epoll</code> 不会再通知该 <code>socket</code> 的 <code>read</code> 事件，事实上一直读完很容易做到。</li>
</ul>
</li>
<li>write<ul>
<li><strong>若发送缓冲区未满，epoll通知write事件，直到开发者填满发送缓冲区，epoll才会在下次发送缓冲区由满变成未满时通知write事件。</strong></li>
</ul>
</li>
<li><code>ET</code> 模式下<strong>只有socket的状态发生变化</strong>时才会通知，也就是<strong>读取缓冲区由无数据到有数据时通知read事件</strong>，<strong>发送缓冲区由满变成未满通知write事件</strong>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>下面是详细介绍</p>
<p><code>epoll</code> 使用 <code>事件</code> 的就绪通知方式，通过 <code>epoll_ctl</code> 注册 <code>fd</code> ，一旦该 <code>fd</code> 就绪，内核就会采用类似 <code>callback</code> 的回调机制来激活该 <code>fd</code> ，<code>epoll_wait</code> 便可以收到通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用户数据载体</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">   void    *ptr;</span><br><span class="line">   int      fd;</span><br><span class="line">   uint32_t u32;</span><br><span class="line">   uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line">//fd装载入内核的载体</span><br><span class="line"> struct epoll_event &#123;</span><br><span class="line">     uint32_t     events;    /* Epoll events */</span><br><span class="line">     epoll_data_t data;      /* User data variable */</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>epoll 函数</strong></p>
<p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>int epoll_create(int size);</strong><br>在内核区创建一个 <code>epoll</code> 相关的一些列结构，并且将一个句柄 <code>fd</code> 返回给用户态，后续的操作都是基于此 <code>fd</code> 的，<code>size</code> 用来告诉内核这个监听的数目一共有多大，类似于 <code>STL</code> 的 <code>vector</code> 动态数组，如果 <code>size</code> 不合适会涉及复制扩容，不过貌似 <code>4.1.2</code> 内核之后 <code>size</code> 已经没有太大用途了；这个参数不同于 <code>select()</code> 中的第一个参数，<code>select</code> 给出的是最大监听的 <code>fd+1</code> 的值。需要注意的是，当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，在 <code>linux</code> 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code> ，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
</li>
<li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>
<p><code>epoll</code> 的事件注册函数， <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里 <code>epoll</code> 是先注册要监听的事件类型。第一个参数是 <code>epoll_create()</code> 的返回值，第二个参数 <strong>epoll_event</strong> 是用户态和内核态交互的结构，定义了用户态关心的事件类型和触发时数据的载体 <code>epoll_data</code> ；</p>
<ul>
<li><strong>EPOLL_CTL_ADD</strong>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；</li>
<li><strong>EPOLL_CTL_MOD</strong>：修改已经注册的 <code>fd</code> 的监听事件；</li>
<li><strong>EPOLL_CTL_DEL</strong>：从 <code>epfd</code> 中删除一个 <code>fd</code> ；<br>第三个参数是需要监听的 <code>fd</code> ，第四个参数是告诉内核需要监听什么事，<strong>epoll_event是用户态需监控fd的代言人，后续用户程序对fd的操作都是基于此结构的</strong>，<code>struct epoll_event</code> 结构如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">  __uint32_t events;  /* Epoll events */</span><br><span class="line">  epoll_data_t data;  /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>events</code> 可以是以下几个宏的集合：</p>
<ul>
<li><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端 <code>SOCKET</code> 正常关闭）</li>
<li><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写</li>
<li><strong>EPOLLPRI</strong>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li><strong>EPOLLERR</strong>：表示对应的文件描述符发生错误</li>
<li><strong>EPOLLHUP</strong>：表示对应的文件描述符被挂断</li>
<li><strong>EPOLLET</strong>： 将 <code>EPOLL</code> 设为边缘触发(<strong>Edge Triggered</strong>)模式，这是相对于水平触发(<strong>Level Triggered</strong>)来说的</li>
<li><strong>EPOLLONESHOT</strong>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 <code>socket</code> 的话，需要再次把这个 <code>socket</code> 加入到 <code>EPOLL</code> 队列里。</li>
</ul>
</li>
<li><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<p>是阻塞等待内核返回的可读写事件，<code>epfd</code> 还是 <code>epoll_create</code> 的返回值，<code>events</code> 是个结构体数组指针存储 <code>epoll_event</code> ，也就是将内核返回的待处理 <code>epoll_event</code> 结构都存储下来，<code>maxevents</code> 告诉内核本次返回的最大 <code>fd</code> 数量，这个和 <code>events</code> 指向的数组是相关的；</p>
</li>
</ul>
<p>底层实现看<a target="_blank" rel="noopener" href="https://www.chenqi1997.top/2020/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/#%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B">这里</a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><p>分为<strong>连续</strong>（块式）和<strong>非连续</strong>（页式、段氏等）</p>
<ol>
<li><strong>块式管理</strong> ：给每个进程分配整块内存</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是<strong>段是有实际意义的</strong>，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li><strong>段页式管理机制</strong> ：结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。</li>
</ol>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由<strong>代码分段、数据分段、栈段、堆段</strong>组成。</p>
<p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p>
<ul>
<li><strong>段选择因子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02211.jpg"></p>
<p>缺点：</p>
<ul>
<li>内存碎片</li>
<li>内存交换效率低</li>
</ul>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个<strong>连续并且尺寸固定的内存空间</strong>，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <strong>4KB</strong>。<strong>虚拟地址与物理地址</strong>之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02212.jpg"></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元</strong> （<strong>MMU</strong>） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p>
<p>分页弥补分段缺陷：</p>
<ul>
<li><p>内存碎片问题：由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p>
</li>
<li><p>交换效率问题：如果内存空间不够，操作系统会把其他正在运行的进程中的 <code>LRU</code> 等<strong>页面置换算法</strong>计算出的的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p>
</li>
</ul>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>特点如下：</p>
<ul>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧(<strong>缺页异常page fault</strong>)</li>
</ul>
<p>页表不分级的话，页表太多占用空间，所以改进使用多级页表。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02213.png"></p>
<p>多级页表实际上是增加了<strong>索引</strong>，有了索引就可以定位到具体的项。</p>
<p>缺点是增加了寻址的时间（时间换空间）</p>
<h4 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h4><p>程序是有<strong>局部性</strong>的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。我们就可以利用这一特性，<strong>把最常访问的几个页表项存储到访问速度更快的硬件</strong>，在 CPU 芯片中，<strong>加入了一个专门存放程序最常访问的页表项的 Cache</strong>，这个 Cache 就是 TLB。MMU可以先在TLB中查找页表，如果没有命中再去找页表里找。</p>
<p>当<strong>TLB</strong>不命中时，<strong>MMU</strong>必须从<strong>L1缓存</strong>中取出对应的*页表条目<strong>PTE</strong>，新取出的<strong>PTE</strong>存放在<strong>TLB</strong>中，可能会覆盖一个已经存在的<strong>PTE</strong>条目。</p>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>传统页表的缺点是：<strong>逻辑地址空间增长速度快于物理地址空间</strong>，所以反向页表，也就是index是物理地址，value是逻辑地址，它的大小会小于传统页表。</p>
<p>以页帧号为 <code>index</code>，页号地址为 <code>value</code>，<strong>每次访问从前到后遍历页表</strong>，<strong>将 <code>value</code> 和逻辑地址比对</strong>，这样做的原因就是大大节省了内存的开销，全局只需要一张页表。再通过hash加速判断</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02214.jpg"></p>
<h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制(代码段、数据段、栈段、堆段等等)；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。</p>
<p>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>主要就是分内存和外存。</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页</strong>功能和<strong>页面置换</strong>功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了<strong>请求调段</strong>功能、<strong>分段置换</strong>功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>在请求分页系统中，可以通过查询<strong>页表中的状态位</strong>来确定所要访问的页面是否存在于内存中。<strong>每当所要访问的页面不在内存时，会产生一次缺页中断</strong>，此时操作系统会根据<strong>页表中的外存地址在外存中找到所缺的一页</strong>，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<ol>
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序进行处理</li>
<li>恢复CPU现场，继续执行</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file_name #更改文件权限，421 rwx</span><br><span class="line">df -h #查看磁盘目录使用情况</span><br><span class="line"></span><br><span class="line">top #实时查看每个进程CPU、内存利用率</span><br><span class="line">top -H #排序查看</span><br><span class="line">top -p 139 #查看进程号139的CPU内存占有率</span><br><span class="line"></span><br><span class="line"> ps -aux #瞬间查看，不实时，进程查看命令</span><br><span class="line"> grep #文本搜索 例如ps -aux|grep yfw</span><br><span class="line"> </span><br><span class="line"> netstat -an #查看网络是否连通,监听TCP和UDP连接</span><br><span class="line"> </span><br><span class="line"> ifconfig #查看ip地址网卡信息及接口信息</span><br><span class="line"> </span><br><span class="line"> du #显示目录或文件的大小</span><br><span class="line"> du -h --max-depth=1 #查看当前文件夹下文件和目录大小</span><br><span class="line"> </span><br><span class="line"> cat /proc/version #查看系统版本</span><br><span class="line"> cat /proc/cpuinfo #查看cpu信息</span><br><span class="line"> free #查看内存</span><br><span class="line"> fdisk -l #查看磁盘</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">修改环境变量</span></span><br><span class="line"> /etc/profile #所有用户生效</span><br><span class="line"> ~/.bashrc #当前用户生效</span><br></pre></td></tr></table></figure>

<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a><a target="_blank" rel="noopener" href="https://github.com/huaxz1986/APUE_notes/blob/master/chapter/3_file_IO.md">文件IO</a></h2><p><strong>文件描述符fd</strong> ：一个非负整数，范围是<code>0~OPEN_MAX-1</code>。内核用它来标识进程正在访问的文件。当进程创建时，默认为它打开了3个文件描述符，它们都链接向终端：</p>
<ul>
<li>0： 标准输入</li>
<li>1： 标准输出</li>
<li>2： 标准错误输出</li>
</ul>
<p>通常我们应该使用<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>和 <code>STDERR_FILENO</code>来替代这三个幻数，从而提高可读性。</p>
<p><strong>打开文件</strong>：<code>open</code>和<code>openat</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">int</span> oflag,...<span class="comment">/*mode_t mode*/</span>)</span></span>;<span class="comment">//只能绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">int</span> oflag,...<span class="comment">/*mode_t mode */</span>)</span></span>;<span class="comment">//fd可以指定相对路径为目录</span></span><br></pre></td></tr></table></figure>

<p><strong>创建文件</strong>：<code>creat</code>函数</p>
<p>成功返回fd，失败返回-1</p>
<p><strong>关闭文件</strong>：<code>close</code>函数</p>
<p>关闭文件释放所有锁，进程终止时自动关闭所有它打开的文件</p>
<p><strong>读取文件</strong>：<code>read</code>函数</p>
<p>从文件的当前偏移量开始读。</p>
<p>实际读到的字节数少于期望读到的字节数：</p>
<ul>
<li>普通文件：在读到期望字节数之前到达了文件尾端</li>
<li>终端设备：通常一次最多读取一行（行缓存）</li>
<li>网络：缓存机制</li>
<li>FIFO和管道：管道包含的字节少于所需的数量</li>
<li>被中断</li>
</ul>
<p><strong>写入文件</strong>：<code>write</code>函数</p>
<p><strong>原子定位读和原子定位写</strong>：<code>pread/pwrite</code>函数</p>
<p>调用<code>pread</code>相当于先调用<code>lseek</code>再调用<code>read</code>.但是调用<code>pread</code>时，无法中断其定位和读操作，并且不更新当前文件偏移量；</p>
<p>调用<code>pwrite</code>相当于先调用<code>lseek</code>再调用<code>write</code>.但是调用<code>pwrite</code>时，无法中断其定位和写操作，并且不更新当前文件偏移量</p>
<p><strong>延迟写刷盘</strong>：<code>sync, fsync, fdatasync</code>函数</p>
<p>磁盘IO先写到缓冲区，再刷盘，称作延迟写。这三个函数能显式刷盘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;         <span class="comment">//刷盘，不等待刷盘结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;       <span class="comment">//只对fd指定的单个文件刷盘，等待刷盘结束才返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;   <span class="comment">//同fsync，但是只影响文件的数据部分，不更新文件属性</span></span><br></pre></td></tr></table></figure>

<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p><strong>获取文件信息结构</strong>：4个<code>stat</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> pathname, struct stat*<span class="keyword">restrict</span> buf)</span></span>;<span class="comment">//当前文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat* buf)</span></span>;<span class="comment">//指定fd文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname,struct stat *<span class="keyword">restrict</span> buf)</span></span>;<span class="comment">//软链接信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span>*<span class="keyword">restrict</span> pathname,struct stat*<span class="keyword">restrict</span> buf,<span class="keyword">int</span> flag)</span></span>;<span class="comment">//相对路径文件信息</span></span><br></pre></td></tr></table></figure>

<p><strong>文件类型</strong>：</p>
<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>系统的所有设备<ul>
<li>块特殊文件</li>
<li>字符特殊文件</li>
</ul>
</li>
<li>FIFO</li>
<li>socket</li>
<li>软链接</li>
</ul>
<p><strong>文件系统</strong></p>
<ul>
<li>分区：每个分区包含一个文件系统</li>
<li>柱面<ul>
<li>inode图：指示哪些 i 节点已经被使用，哪些未被使用</li>
<li>块位图：用于指示哪些数据块已经被使用，哪些未被使用</li>
<li>inode:许多个</li>
<li>数据区<ul>
<li>数据块</li>
<li>目录块</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03031.png"></p>
<p><strong>硬链接和软链接</strong></p>
<p>文件都有<strong>文件名与数据</strong>，这在 Linux 上被分成两个部分：<strong>用户数据</strong> (user data) 与<strong>元数据</strong> (metadata)。</p>
<ul>
<li><strong>用户数据</strong>，即文件数据块(data block)，记录文件真实内容的地方；</li>
<li><strong>元数据</strong>：记录文件的附加属性，如文件大小、创建时间、所有者等信息。<ul>
<li> <strong>inode 号</strong>：元数据的一部分，不包含文件名，是文件的唯一标识。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</li>
</ul>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02251.png"></p>
<p>为解决文件的共享使用，Linux 系统引入了两种链接：<strong>硬链接</strong>与<strong>软链接</strong></p>
<ul>
<li>硬链接：一个 inode 号对应多个文件名    <code>ln f1 f2</code></li>
<li>软链接：数据块中存放的内容是另一文件的路径名的指向    <code>ln -s f1 f3</code></li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02252.png"></p>
<p>每个inode可以有多个链接，删除节点时，先看是否链接计数为0，是的话在看是否没有任何一个进程在使用这个inode，是的话才删除。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><a target="_blank" rel="noopener" href="https://github.com/huaxz1986/APUE_notes/blob/master/chapter/8_progress_control.md">进程控制</a></h2><p>进程ID：每个进程有一个pid，不同进程的pid不同，进程结束后pid可以复用。0是系统进程。1是init进程，参与系统初始化，是用户态的进程，永不终止。</p>
<p><strong>创建进程</strong>：<code>fork</code>函数</p>
<ul>
<li><code>fork</code>调用成功，子进程返回0，父进程返回子进程id（因为没有获取子进程id的函数，只能在创建时返回）</li>
<li>子进程是父进程的拷贝，共享正文段，数据空间、堆、栈不共享</li>
<li>父子进程有相同的文件描述符fd和文件偏移量，如果创建完后一起写文件的话，输出会相互混合，所以需要各自关闭它们不需要使用的文件描述符，从而避免干扰对方的文件操作</li>
<li><code>fork</code>失败的原因：进程数超过了系统的限制</li>
<li>创建子进程的目的：<ul>
<li>为了执行父进程的其他代码段</li>
<li>为了执行其他程序（<code>vfork</code>函数）</li>
</ul>
</li>
</ul>
<p><strong>进程终止</strong></p>
<ul>
<li>正常终止</li>
<li>异常终止</li>
</ul>
<p>在任意一种情况下，终止进程的父进程都能够用<code>wait</code>或者<code>waitpid</code>函数取得终止状态。然后父进程能够检测终止状态。如果发现子进程是正常终止，则可以从终止状态中提取出退出状态</p>
<p>孤儿进程：如果父进程在子进程之前终止，那么内核会将该子进程的父进程改变为<code>init</code>进程，称作由<code>init</code>进程收养。其原理为：</p>
<ul>
<li>在一个进程终止时，内核逐个检查所有活动进程，以判断这些活动进程是否是正要终止的进程的子进程</li>
<li>如果是，则该活动进程的父进程<code>ID</code>就改为 1</li>
</ul>
<p>僵尸进程：子进程已经终止，但是父进程没有调用<code>wait</code>函数或者<code>waitpid</code>函数读取终止进程的残留信息</p>
<ul>
<li>如何避免僵尸进程<ul>
<li>使用signal函数显式地忽略sigchld信号</li>
<li>使用wait函数</li>
<li>fork两次，父进程fork子进程后继续执行，子进程fork一个孙进程后退出，此时孙进程被init进程接管，避免僵尸进程</li>
</ul>
</li>
</ul>
<p><strong>初始化执行新的程序</strong>:<code>exec</code>函数</p>
<p>当进程调用一种<code>exec</code>函数时，该进程执行的程序完全替换成新程序，而新程序则从<code>main</code>函数开始执行</p>
<ul>
<li>调用<code>exec</code>前后，进程<code>ID</code>并未改变。因为<code>exec</code>并不创建新进程</li>
<li><code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</li>
</ul>
<p>7个exec族函数只有<code>execve</code>是内核的系统调用。另外 6 个只是库函数。它们最终都要调用该系统调用。</p>
<p>一般配合fork使用。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在多线程并发执行的过程中，代码能够正确地得到结果，就称为线程安全。</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误</p>
<h2 id="信号安全"><a href="#信号安全" class="headerlink" title="信号安全"></a>信号安全</h2><p>在信号处理函数中可以安全调用的函数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/17/os/" data-id="ckw9lh00s002z2ww56s3cd1oa" data-title="操作系统" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/01/19/gbf_2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          synchronized
        
      </div>
    </a>
  
  
    <a href="/2021/01/16/sql2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据库面试点</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DIY/" rel="tag">DIY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" rel="tag">学术交流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9F%B3%E4%B9%90/" rel="tag">音乐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DIY/" style="font-size: 12px;">DIY</a> <a href="/tags/JAVA/" style="font-size: 18px;">JAVA</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">学习</a> <a href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" style="font-size: 12px;">学术交流</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12px;">数据库</a> <a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">游戏</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px;">算法</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%9F%B3%E4%B9%90/" style="font-size: 12px;">音乐</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 16px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/15/musicScore/">小提琴谱子</a>
          </li>
        
          <li>
            <a href="/2021/05/15/musicTheory/">基本乐理</a>
          </li>
        
          <li>
            <a href="/2021/05/09/qianyi/">网站迁移</a>
          </li>
        
          <li>
            <a href="/2021/05/05/mybatis/">MyBatis</a>
          </li>
        
          <li>
            <a href="/2021/04/25/maven/">Maven</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>