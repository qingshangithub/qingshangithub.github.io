<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>剑指Offer刷题笔记 | ifwant ^_^</title><meta name="keywords" content="学习"><meta name="author" content="Allen Yi"><meta name="copyright" content="Allen Yi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JZ1：二维数组中的查找 左下角开始，遇大右移，遇小上移，直到超过边界都没找到，得false。否则得true。   JZ2：替换空格 自带函数replace 新建stringbuffer用append() 遍历一遍计数空格,每个空格新长度+2，setLength(),从后往前setCharAt()   JZ3：从尾到头打印链表 ArrayList.add(0,value) 递归   JZ4：重建">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer刷题笔记">
<meta property="og:url" content="https://ifwant.tech/2020/12/10/jianzhioffer/index.html">
<meta property="og:site_name" content="ifwant ^_^">
<meta property="og:description" content="JZ1：二维数组中的查找 左下角开始，遇大右移，遇小上移，直到超过边界都没找到，得false。否则得true。   JZ2：替换空格 自带函数replace 新建stringbuffer用append() 遍历一遍计数空格,每个空格新长度+2，setLength(),从后往前setCharAt()   JZ3：从尾到头打印链表 ArrayList.add(0,value) 递归   JZ4：重建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/2.png">
<meta property="article:published_time" content="2020-12-10T07:09:39.000Z">
<meta property="article:modified_time" content="2021-08-13T11:38:08.561Z">
<meta property="article:author" content="Allen Yi">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ifwant.tech/2020/12/10/jianzhioffer/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b3b4e55761c1613e6e0dd115f033bd6b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '剑指Offer刷题笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-13 19:38:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 收藏</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 摄影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ifwant ^_^</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 收藏</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 摄影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">剑指Offer刷题笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-10T07:09:39.000Z" title="发表于 2020-12-10 15:09:39">2020-12-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-13T11:38:08.561Z" title="更新于 2021-08-13 19:38:08">2021-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="剑指Offer刷题笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><ul>
<li>JZ1：二维数组中的查找<ul>
<li>左下角开始，遇大右移，遇小上移，直到超过边界都没找到，得false。否则得true。</li>
</ul>
</li>
<li>JZ2：替换空格<ul>
<li>自带函数replace</li>
<li>新建stringbuffer用append()</li>
<li>遍历一遍计数空格,每个空格新长度+2，setLength(),从后往前setCharAt()</li>
</ul>
</li>
<li>JZ3：从尾到头打印链表<ul>
<li>ArrayList.add(0,value)</li>
<li>递归</li>
</ul>
</li>
<li>JZ4：重建二叉树<ul>
<li>递归，前序遍历第一个pre[0]是根节点，在中序遍历中找到pre[0]的位置，对左右分别递归调用函数，可以使用 Arrays.copyOfRange (array,start,end)直接复制数组，左闭右开</li>
</ul>
</li>
<li>JZ5：两个栈实现队列<ul>
<li>出栈：栈2空时，先把栈1转移到栈2，再pop，栈2非空时，直接pop</li>
</ul>
</li>
<li>JZ6：旋转数组的最小数字<ul>
<li>二分法，三种情况讨论</li>
</ul>
</li>
<li>JZ7：斐波那契数列<ul>
<li>当前项是前两项之和</li>
</ul>
</li>
<li>JZ8：跳台阶<ul>
<li>递归</li>
</ul>
</li>
<li>JZ9：变态跳台阶<ul>
<li>递归，f(n)=f(n-1)+f(n-2)+…+f(1)=2*f(n-1)</li>
</ul>
</li>
<li>JZ10：矩形覆盖<ul>
<li>递归，012三种情况单列</li>
</ul>
</li>
<li>JZ11：二进制中1的个数<ul>
<li>n=n&amp;(n-1)可以把二进制数最右边的1置0</li>
</ul>
</li>
<li>JZ12：数值的整次方<ul>
<li>快速幂，时间复杂度logn，指数的二进制形式的1才参与计算</li>
</ul>
</li>
</ul>
<h1 id="JZ13：调整数组顺序使奇数位于偶数前面"><a href="#JZ13：调整数组顺序使奇数位于偶数前面" class="headerlink" title="JZ13：调整数组顺序使奇数位于偶数前面"></a>JZ13：调整数组顺序使奇数位于偶数前面</h1><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</p>
<p>插入排序思想，使用两个循环。假设前面的已经都是奇数，当前元素：</p>
<ul>
<li><p>如果是偶数，不动；</p>
</li>
<li><p>如果是奇数，与前面的偶数一个个交换。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp=array[j+<span class="number">1</span>];</span><br><span class="line">                        array[j+<span class="number">1</span>]=array[j];</span><br><span class="line">                        array[j]=tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JZ14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h1><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p>
<p>快慢双指针：指针p先走k-1步，指针q再开始，两个指针之间的距离是k-1，当p到链表末端，q就是倒数第k个结点。</p>
<p>注意边界情况：</p>
<ul>
<li><p>k&gt;链表长度</p>
</li>
<li><p>k&lt;=0</p>
</li>
<li><p>链表为{}</p>
</li>
</ul>
<p>这三种情况都返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        ListNode q=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h1><p>题目：输入一个链表，反转链表后，输出新链表的表头</p>
<p>用两个指针，p和q分别指向head的前一结点和后一结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p=<span class="keyword">null</span>;</span><br><span class="line">        ListNode q=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=head.next;</span><br><span class="line">            head.next=p;</span><br><span class="line">            p=head;</span><br><span class="line">            head=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ15.png" alt="图解" style="zoom:50%;" />

<h1 id="JZ16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h1><p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>新建一个结点头head，每次比较list1和list2，把更小的接在head后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode root=head;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;&amp;list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                head.next=list1;</span><br><span class="line">                head=list1;</span><br><span class="line">                list1=list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head.next=list2;</span><br><span class="line">                head=list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把未结束的链表连接到合并后的链表尾部</span></span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head.next=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ17-树的子结构"><a href="#JZ17-树的子结构" class="headerlink" title="JZ17 树的子结构"></a>JZ17 树的子结构</h1><p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>递归思想，使用两个递归：</p>
<ul>
<li><p>第一个递归：当前结点是否等于子结构树的根结点，是则执行第二个递归；否则分别对左节点和右节点递归调用</p>
</li>
<li><p>第二个递归：判断当前结点是否和子结构树的对应结点相等，不相等则返回false，相等则再对左节点和右节点递归调用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">                result=DoesTree1hasTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                result=HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                result=HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">DoesTree1hasTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> DoesTree1hasTree2(root1.left,root2.left)&amp;&amp;DoesTree1hasTree2(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h1><p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<p>递归：交换左右结点，分别对左右结点递归调用函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        TreeNode tmp=root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=tmp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用栈，每次把左右结点压入栈中实现前序遍历，避免递归。</p>
<h1 id="JZ19-顺时针打印矩阵"><a href="#JZ19-顺时针打印矩阵" class="headerlink" title="JZ19 顺时针打印矩阵"></a>JZ19 顺时针打印矩阵</h1><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>三个变量row,col,start。注意开闭：</p>
<ul>
<li><p>[start,col)</p>
</li>
<li><p>[start+1,row)</p>
</li>
<li><p>[col-2,start]</p>
</li>
<li><p>[row-2,start)</p>
</li>
</ul>
<p>外层循环当<code>row&gt;start&amp;&amp;col&gt;start</code>时结束</p>
<p>单行的情况，走完第一步就返回</p>
<p>单列的情况，走完第二步就返回</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/shunshizhenjuzheng.png" alt="图解"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&gt;start&amp;&amp;col&gt;start)&#123;</span><br><span class="line">            printMatrixIner(matrix,row,col,start,result);</span><br><span class="line">            row--;</span><br><span class="line">            col--;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMatrixIner</span><span class="params">(<span class="keyword">int</span> [][] matrix,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> start,ArrayList&lt;Integer&gt; result)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;col;i++)&#123;</span><br><span class="line">            result.add(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row-start==<span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//只有一行，打印完直接return</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            result.add(matrix[i][col-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col-start==<span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//只有一列，打印完直接return</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=col-<span class="number">2</span>;i&gt;=start;i--)&#123;</span><br><span class="line">            result.add(matrix[row-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">2</span>;i&gt;start;i--)&#123;</span><br><span class="line">            result.add(matrix[i][start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ20-包含min函数的栈"><a href="#JZ20-包含min函数的栈" class="headerlink" title="JZ20 包含min函数的栈"></a>JZ20 包含min函数的栈</h1><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p>用两个栈，其中一个栈（stackMin）每次push时压入当前最小值（要么是新元素，要么是stackMin的栈顶元素）。</p>
<ul>
<li>判断栈空：stack.empty()</li>
<li>查看栈顶（不删除）：stack.peek()</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/stackmin.png" alt="stackmin" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackOrin=<span class="keyword">new</span> Stack&lt;Integer&gt; ();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin=<span class="keyword">new</span> Stack&lt;Integer&gt; ();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stackOrin.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackMin.empty()||stackMin.peek()&gt;node)&#123;</span><br><span class="line">            stackMin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stackMin.push(stackMin.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackOrin.pop();</span><br><span class="line">        stackMin.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackOrin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ21-栈的压入和弹出序列"><a href="#JZ21-栈的压入和弹出序列" class="headerlink" title="JZ21 栈的压入和弹出序列"></a>JZ21 栈的压入和弹出序列</h1><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>一个栈模拟压入过程，不断判断栈顶元素和出栈序列是否相等，相等则出栈，不等则继续压入栈。最后栈为空则返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; myStack=<span class="keyword">new</span> Stack&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            myStack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(flag&lt;popA.length&amp;&amp;myStack.peek()==popA[flag])&#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ22-从上往下打印二叉树"><a href="#JZ22-从上往下打印二叉树" class="headerlink" title="JZ22 从上往下打印二叉树"></a>JZ22 从上往下打印二叉树</h1><p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>其实就是实现二叉树层序遍历：队列+前序遍历</p>
<ul>
<li>队列：<code>Queue &lt;TreeNode&gt; myqueue=new LinkedList &lt;TreeNode&gt;();</code></li>
<li>队列加元素：offer()</li>
<li>删队头：poll()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        Queue &lt;TreeNode&gt; myqueue=<span class="keyword">new</span> LinkedList &lt;TreeNode&gt;();</span><br><span class="line">        myqueue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!myqueue.isEmpty())&#123;</span><br><span class="line">            TreeNode tmp=myqueue.poll();</span><br><span class="line">            result.add(tmp.val);</span><br><span class="line">            <span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                myqueue.offer(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                myqueue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ23-二叉搜索树的后序遍历序列"><a href="#JZ23-二叉搜索树的后序遍历序列" class="headerlink" title="JZ23 二叉搜索树的后序遍历序列"></a>JZ23 二叉搜索树的后序遍历序列</h1><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>二叉搜索树（BST）</p>
<ul>
<li><p>左子树都比根节点小，右子树都比根节点大。</p>
</li>
<li><p>后序遍历的最后一位是根节点，前面的序列一定可以分成两部分（或者一部分），一部分小于根节点，一部分大于根节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = subProcess(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">subProcess</span><span class="params">(<span class="keyword">int</span> []sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=end-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(sequence[tmp]&gt;sequence[end]&amp;&amp;tmp&gt;start)tmp--;</span><br><span class="line">        <span class="keyword">if</span>(tmp==start)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=tmp;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;sequence[end])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subProcess(sequence,start,tmp)&amp;&amp;subProcess(sequence,tmp+<span class="number">1</span>,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<ul>
<li><p>从最后一位往前遍历，找到比根节点小的数，序号为tmp，再从start遍历到tmp，看是不是都小于根节点，不是就返回false。</p>
</li>
<li><p>如果start&gt;=end，就返回true</p>
</li>
<li><p>分别对小于根节点的序列和大于根节点的序列递归调用函数</p>
</li>
</ul>
<p>注意对于根节点前面的数都比根节点大的情况（只有右子树），此时tmp==start,可以直接返回true</p>
<h1 id="JZ24-二叉树和为某一值的路径"><a href="#JZ24-二叉树和为某一值的路径" class="headerlink" title="JZ24 二叉树和为某一值的路径"></a>JZ24 二叉树和为某一值的路径</h1><p>题目：输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<ul>
<li>递归，用一个<code>ArrayList&lt;Integer&gt;</code>保存测试路径，加上根节点的val等于target，且没有左右节点了就返回，否则对左右子树递归调用。</li>
<li>注意调用结束后要把最后一个节点remove，才能回退到上一个节点状态。</li>
<li>result添加时要新建一个新的<code>ArrayList&lt;Integer&gt;</code>，这样才不会因为后续path的更新而受到影响。</li>
<li>对于字典排序，原始的剑指offer并没有这个要求，排序可以重写<code>Collections.sort</code>的<code>compare</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result =<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        help(root,target);</span><br><span class="line">        Collections.sort(result,<span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt; o1, ArrayList&lt;Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 返回值为int类型，大于0表示正序，小于0表示逆序</span></span><br><span class="line">                <span class="keyword">return</span> o2.size()-o1.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        target-=root.val;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        help(root.left,target);</span><br><span class="line">        help(root.right,target);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ25-复杂链表的复制"><a href="#JZ25-复杂链表的复制" class="headerlink" title="JZ25 复杂链表的复制"></a>JZ25 复杂链表的复制</h1><p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<ul>
<li><p>先在原链接上复制，再匹配对应的随机链接，最后拆分原始节点和克隆节点</p>
</li>
<li><p>特别注意使用<code>.next</code>的时候，这个节点是否是null，如果是还调用的话，会报指针null错</p>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/jz25.png" alt="流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode currentNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode tmp=<span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            tmp.next=currentNode.next;</span><br><span class="line">            currentNode.next=tmp;</span><br><span class="line">            currentNode=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            currentNode.next.random=currentNode.random==<span class="keyword">null</span>?<span class="keyword">null</span>:currentNode.random.next;</span><br><span class="line">            currentNode=currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode=pHead;</span><br><span class="line">        RandomListNode result=pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode tmp=currentNode.next;</span><br><span class="line">            currentNode.next=tmp.next;</span><br><span class="line">            tmp.next=tmp.next==<span class="keyword">null</span>?<span class="keyword">null</span>:tmp.next.next;</span><br><span class="line">            currentNode=currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ26-二叉搜索树与双向链表"><a href="#JZ26-二叉搜索树与双向链表" class="headerlink" title="JZ26 二叉搜索树与双向链表"></a>JZ26 二叉搜索树与双向链表</h1><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>递归：即假设经过这个函数后，左右子树都整理好，并返回当前头结点</p>
<ul>
<li>如果左右子树都为null，则返回当前节点</li>
<li>当前节点和整理好的左子树的末端节点连接，和整理好的右子树的头结点连接</li>
<li>最终返回值：如果有左子树，返回整理好的左子树的头结点；如果没有，返回当前节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)<span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left==<span class="keyword">null</span>&amp;&amp;pRootOfTree.right==<span class="keyword">null</span>)<span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        TreeNode finalResult=pRootOfTree;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode head=Convert(pRootOfTree.right);</span><br><span class="line">            pRootOfTree.right=head;</span><br><span class="line">            head.left=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode head=Convert(pRootOfTree.left);</span><br><span class="line">            TreeNode tmp=head;</span><br><span class="line">            <span class="keyword">while</span>(tmp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp=tmp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.right=pRootOfTree;</span><br><span class="line">            pRootOfTree.left=tmp;</span><br><span class="line">            finalResult=head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ27-字符串排列"><a href="#JZ27-字符串排列" class="headerlink" title="JZ27 字符串排列"></a>JZ27 字符串排列</h1><p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba</p>
<p>递归+回溯法</p>
<ul>
<li>String转char数组：<code>toCharArray()</code></li>
<li>char数组转String：<code>String s=String.valueOf(charstr);</code></li>
<li>第0位分别和第012位交换得到第二行排列</li>
<li>第1位分别和12位交换得到第三行排列</li>
<li>到达最终叶节点（index==chararray.length-1),该排列加入结果队列</li>
<li>字典序排列：<code>Collections.sort()</code></li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ27.png" alt="回溯过程"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            PermutationHelp(str.toCharArray(),<span class="number">0</span>,result);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationHelp</span><span class="params">(<span class="keyword">char</span>[] charstr,<span class="keyword">int</span> i,ArrayList&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=charstr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;charstr.length;j++)&#123;</span><br><span class="line">                swap(charstr,i,j);</span><br><span class="line">                PermutationHelp(charstr,i+<span class="number">1</span>,result);</span><br><span class="line">                swap(charstr,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            String s=String.valueOf(charstr);</span><br><span class="line">            <span class="keyword">if</span>(!result.contains(s))result.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] charstr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=charstr[i];</span><br><span class="line">        charstr[i]=charstr[j];</span><br><span class="line">        charstr[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ28-数组中超过一半的数"><a href="#JZ28-数组中超过一半的数" class="headerlink" title="JZ28 数组中超过一半的数"></a>JZ28 数组中超过一半的数</h1><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<ul>
<li>思想：如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</li>
<li>用一个变量candi保存候选数，一个变量num保存候选数出现次数</li>
<li>遍历数组，候选数和下一个数相等，num++；不等，num–；num==0,下一个遍历的数成为新的候选数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candi=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                candi=array[i];</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(candi==array[i])&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tmp:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp==candi)num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num&gt;array.length/<span class="number">2</span>?candi:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ29-最小的K个数"><a href="#JZ29-最小的K个数" class="headerlink" title="JZ29 最小的K个数"></a>JZ29 最小的K个数</h1><p>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>思路一：排序，取前K个。Arrays.sort()</p>
<p>思路二：用优先级队列<code>PriorityQueue&lt;Integer&gt;</code>，通过重写比较函数，降序排列（队列头是最大值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Comparator&lt;Integer&gt; cmp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length==<span class="number">0</span>||k&gt;input.length||k==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; myQueue=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length;i++)&#123;</span><br><span class="line">            myQueue.offer(input[i]);</span><br><span class="line">            <span class="keyword">if</span>(myQueue.size()&gt;k)myQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            result.add(myQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ30-连续子数组的最大和"><a href="#JZ30-连续子数组的最大和" class="headerlink" title="JZ30 连续子数组的最大和"></a>JZ30 连续子数组的最大和</h1><p>题目：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>两个变量，sum存储子数组的和，max存储和最大的子数组和。如果sum+当前数比当前数小，sum更新为当前数。如果sum比max大，更新max为sum。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+array[i]&lt;array[i])&#123;</span><br><span class="line">                sum=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max)max=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ31-整数中1出现的次数"><a href="#JZ31-整数中1出现的次数" class="headerlink" title="JZ31 整数中1出现的次数"></a>JZ31 整数中1出现的次数</h1><p>归纳：以百位为例</p>
<ul>
<li><p>该数百位为0，例如12012，则从0到12012的数，百位为1的有100<del>199,1100</del>1199，…，11100~11199，共12*100个，即高位数决定</p>
</li>
<li><p>该数百位为1，例如12112，则从0到12112的数，百位为1的有100<del>199,1100</del>1199，…，11100<del>11199和12100</del>12112共12*100+12+1个，高位数和低位数决定</p>
</li>
<li><p>该数百位为2<del>9，例如12212，则从0到12212的数，百位为1的有100</del>199,1100<del>1199，…，11100</del>11199和12100~12199共（12+1）*100个</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=(n/i)%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> high=n/(i*<span class="number">10</span>);</span><br><span class="line">                sum+=(high*i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> high=n/(i*<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">int</span> low=n%i;</span><br><span class="line">                sum+=(high*i+low+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> high=n/(i*<span class="number">10</span>);</span><br><span class="line">                sum+=((high+<span class="number">1</span>)*i);</span><br><span class="line">            &#125;</span><br><span class="line">            i*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ32-把数组排成最小的数"><a href="#JZ32-把数组排成最小的数" class="headerlink" title="JZ32 把数组排成最小的数"></a>JZ32 把数组排成最小的数</h1><p>问题： 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 </p>
<p> 两个字符串a,b，如果a + b &lt; b + a, 我们希望a排在b的前面。 自定义排序规则，使得ArrayList中字符串都满足如上规则，那么最后的结果肯定是最小的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; myCmp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">            String ab=a+<span class="string">&quot;&quot;</span>+b;</span><br><span class="line">            String ba=b+<span class="string">&quot;&quot;</span>+a;</span><br><span class="line">            <span class="keyword">return</span> ab.compareTo(ba);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        ArrayList&lt;Integer&gt; myArray=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:numbers)&#123;</span><br><span class="line">            myArray.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(myArray,myCmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:myArray)&#123;</span><br><span class="line">            result+=(<span class="string">&quot;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ33-丑数"><a href="#JZ33-丑数" class="headerlink" title="JZ33 丑数"></a>JZ33 丑数</h1><p>题目： 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 </p>
<ul>
<li>一个丑数是一个比他小的丑数乘以2、3、5得到的</li>
<li>生成丑数的过程中，每个丑数只会分别乘以1次2、3、5</li>
<li>用三个int：n2, n3, n5分别记录还未乘以过2, 3, 5的位置</li>
<li>每次将n2, n3, n5这三个位置的丑数生成的新丑数中最小的那个加入结果数组</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ33.PNG" alt="过程" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">int</span> n2=<span class="number">0</span>,n3=<span class="number">0</span>,n5=<span class="number">0</span>;</span><br><span class="line">        result[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newcs=minOfThree(result[n2]*<span class="number">2</span>,result[n3]*<span class="number">3</span>,result[n5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(newcs==result[n2]*<span class="number">2</span>)n2++;</span><br><span class="line">            <span class="keyword">if</span>(newcs==result[n3]*<span class="number">3</span>)n3++;</span><br><span class="line">            <span class="keyword">if</span>(newcs==result[n5]*<span class="number">5</span>)n5++;</span><br><span class="line">            result[i]=newcs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOfThree</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=a&lt;b?a:b;</span><br><span class="line">        min=min&lt;c?min:c;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ34-第一个只出现一次的字符"><a href="#JZ34-第一个只出现一次的字符" class="headerlink" title="JZ34 第一个只出现一次的字符"></a>JZ34 第一个只出现一次的字符</h1><p>题目：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数 )</p>
<ul>
<li>创建一个数组，index是字符的ASCII值，value是该字符出现次数。</li>
<li>第一次遍历str,记录得到每个字符出现次数，第二次遍历str，得到第一个出现次数为1的字符</li>
<li>字符的ASCII：<code>Integer.valueOf(&#39;a&#39;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            result[Integer.valueOf(str.charAt(i))]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[Integer.valueOf(str.charAt(i))]==<span class="number">1</span>)<span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ35-数组中的逆序对"><a href="#JZ35-数组中的逆序对" class="headerlink" title="JZ35 数组中的逆序对"></a>JZ35 数组中的逆序对</h1><p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>对于$50%$的数据,$size\leq 10^4$<br>对于$70%$的数据,$size\leq 10^5$<br>对于$100%$的数据,$size\leq 2*10^5$</p>
<p>输入描述: 题目保证输入的数组中没有的相同的数字</p>
<p>思路：递归，把数组均分为两个数组</p>
<ul>
<li><p>左段数组排序并计算逆序对数</p>
</li>
<li><p>右段数组排序并计算逆序对数</p>
</li>
<li><p>将两个排好序的数组合并并计算逆序对数。</p>
</li>
</ul>
<p>递归到底的条件是数组中只有一个数。</p>
<p>两个数组合并：由于数组已经排好序，从左到右递增</p>
<ul>
<li>使用两个指针left和right指向两个数组的最大值。</li>
<li>然后使用归并排序思想操作</li>
<li>left和right比，大的放到tmp中。如果left大，逆序对数result还要加上right-mid</li>
<li>最后如果其中一个数组先遍历完，把另一个数组剩下的依序放入tmp中</li>
<li>在tmp数组中得到排好序的数组，最后把array数组中对应的部分改为tmp中排好序的结果：</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ35.png" alt="JZ35" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] tmp=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=array.length-<span class="number">1</span>;</span><br><span class="line">        cutPairs(array,tmp,start,end);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cutPairs</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span>[]tmp,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end-start&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cutPairs(array,tmp,start,(end+start)/<span class="number">2</span>);</span><br><span class="line">            cutPairs(array,tmp,(end+start)/<span class="number">2</span>+<span class="number">1</span>,end);</span><br><span class="line">            merge(array,tmp,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span>[]tmp,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(end+start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left=mid,right=end;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=end;i&gt;start-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;=start&amp;&amp;right&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[left]&gt;array[right])&#123;</span><br><span class="line">                    tmp[i]=array[left];</span><br><span class="line">                    result+=(right-mid);</span><br><span class="line">                    result=result%<span class="number">1000000007</span>;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[i]=array[right];</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(left&lt;start)&#123;</span><br><span class="line">                    tmp[i]=array[right];</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[i]=array[left];</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=end;i&gt;start-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            array[i]=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JZ36-两个链表的第一个公共结点"><a href="#JZ36-两个链表的第一个公共结点" class="headerlink" title="JZ36 两个链表的第一个公共结点"></a>JZ36 两个链表的第一个公共结点</h1><p>题目： 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<ul>
<li>有了第一个公共点后，之后的结点都是公共点（因为单链表只有一个next）</li>
<li>使用两个指针，分别从两个链表头开始遍历，遍历到尾端时（next==null）再从另一条链表头遍历，这样他们就会同时到达链表末端（下图中的5结点），也就是说他们会在第一个公共结点相遇（下图中的8）</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ36.png" alt="JZ36"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1=pHead1;</span><br><span class="line">        ListNode p2=pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="keyword">null</span>||pHead2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="keyword">null</span>&amp;&amp;p2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="keyword">null</span>)p1=pHead2;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="keyword">null</span>)p2=pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ37-数字在排序数组中出现的次数"><a href="#JZ37-数字在排序数组中出现的次数" class="headerlink" title="JZ37 数字在排序数组中出现的次数"></a>JZ37 数字在排序数组中出现的次数</h1><p>题目：</p>
<ul>
<li>二分查找法查找k，找到k后，往前计数有多少个k，往后计数有多少个k</li>
<li>上一种方法时间复杂度O(n)，改进：使用二分法查找k，找到后对前半段继续二分查找k，直到该k前一位不等于k，则表示找到了第一个k，同理找最后一个k，index相减得到次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subGet(array,k,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subGet</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> k,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=mid;</span><br><span class="line">            <span class="keyword">while</span>(index&gt;=start&amp;&amp;array[index]==k)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            index=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;=end&amp;&amp;array[index]==k)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==start)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> subGet(array,k,start,mid-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==end)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> subGet(array,k,mid+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ38-二叉树深度"><a href="#JZ38-二叉树深度" class="headerlink" title="JZ38 二叉树深度"></a>JZ38 二叉树深度</h1><ul>
<li>递归</li>
<li>非递归：层次遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        left=TreeDepth(root.left);</span><br><span class="line">        right=TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ39-平衡二叉树"><a href="#JZ39-平衡二叉树" class="headerlink" title="JZ39 平衡二叉树"></a>JZ39 平衡二叉树</h1><p>题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。<strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>递归获取子树深度，设定非平衡二叉树深度为-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root)!=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(right-left)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(right,left)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ40-数组中只出现一次的数字"><a href="#JZ40-数组中只出现一次的数字" class="headerlink" title="JZ40 数组中只出现一次的数字"></a>JZ40 数组中只出现一次的数字</h1><p>题目： 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 </p>
<ul>
<li><p>两数相等，异或为0；一个数和0异或，为它本身</p>
</li>
<li><p>把数组中所有数异或，得到的就是那两个只出现一次的数的异或</p>
</li>
<li><p>一个数和它的负数（即补码，取反加1）相与，得到的是第一个出现1的位置：10101&amp;01011=00001</p>
</li>
<li><p>按上述位的位置，数组分为两部分，改位为1或0</p>
</li>
<li><p>每部分再内部异或即可得到只出现一次的数字</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;</span><br><span class="line">            tmp^=i;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&amp;=(-tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;tmp)==<span class="number">0</span>)&#123;</span><br><span class="line">                num1[<span class="number">0</span>]^=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>]^=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ41-和为S的连续正数序列"><a href="#JZ41-和为S的连续正数序列" class="headerlink" title="JZ41 和为S的连续正数序列"></a>JZ41 和为S的连续正数序列</h1><p>题目： 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<p>滑动窗口：</p>
<ul>
<li>两个指针left和right，如果窗口内的和小于S，right++;如果大于，left++，等于就把结果加入result中。</li>
<li>由于至少包括两个数，所以循环停止的条件是left&gt;S/2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">2</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">3</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=sum/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumtmp=(left+right)*(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sumtmp&gt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sumtmp&lt;sum)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; resulttmp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">                    resulttmp.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add((resulttmp));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ42-和为S的两个数字"><a href="#JZ42-和为S的两个数字" class="headerlink" title="JZ42 和为S的两个数字"></a>JZ42 和为S的两个数字</h1><p>题目： 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
<ul>
<li>left和right两个指针。<code>left=0    right=array.length-1</code></li>
<li>left小的，两个数的乘积更小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumtmp=array[left]+array[right];</span><br><span class="line">            <span class="keyword">if</span>(sumtmp&lt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sumtmp&gt;sum)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(array[left]);</span><br><span class="line">                result.add(array[right]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ43-左旋转字符串"><a href="#JZ43-左旋转字符串" class="headerlink" title="JZ43 左旋转字符串"></a>JZ43 左旋转字符串</h1><p>题目： 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ </p>
<p>主要两个函数：<code>String.concat()</code>和<code>String.substring()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">&quot;&quot;</span>||str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)<span class="keyword">return</span> str;</span><br><span class="line">        n=n%str.length();</span><br><span class="line">        <span class="keyword">return</span> str.concat(str).substring(n,str.length()+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ44-翻转单词顺序列"><a href="#JZ44-翻转单词顺序列" class="headerlink" title="JZ44 翻转单词顺序列"></a>JZ44 翻转单词顺序列</h1><p>题目： 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ </p>
<p>创建一个<code>ArrayList&lt;String&gt;</code>来保存每个单词，用两个指针遍历，分别记录单词起始字符和终止字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)<span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        ArrayList&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;str.length())&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;str.length()&amp;&amp;str.charAt(left)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>&amp;&amp;left==str.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            right=left+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;str.length()&amp;&amp;str.charAt(right)!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(str.substring(left,right));</span><br><span class="line">            left=right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String finalresult=result.get(result.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=result.size()-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            finalresult+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">            finalresult+=result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalresult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ45-扑克牌顺子"><a href="#JZ45-扑克牌顺子" class="headerlink" title="JZ45 扑克牌顺子"></a>JZ45 扑克牌顺子</h1><p>题目： LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 </p>
<p>先排序，然后找到除去0以外的最小的数和最大的数。</p>
<ul>
<li>如果除0外，数组中有相等的数，则不是顺子</li>
<li>如果两数之差&lt;=<code>numbers,length-1</code>，则是顺子；否则不是</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length==<span class="number">0</span>||numbers==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[start]==<span class="number">0</span>&amp;&amp;start&lt;numbers.length)start++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[i+<span class="number">1</span>])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dis=numbers[numbers.length-<span class="number">1</span>]-numbers[start];</span><br><span class="line">        <span class="keyword">if</span>(dis&lt;=numbers.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ46-圆圈中最后剩下的数"><a href="#JZ46-圆圈中最后剩下的数" class="headerlink" title="JZ46 圆圈中最后剩下的数"></a>JZ46 圆圈中最后剩下的数</h1><p>题目：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<p>递归： 长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。 假设我们已知n - 1的序列最后留下的是 f(n - 1, m) 号小朋友，那么对于n个小朋友的序列，f(n - 1, m) 号小朋友的位置其实是(f(n - 1, m) + m )%n</p>
<p>下图中就是，对于6个小朋友时，假设已知最后留下的是0号小朋友，那么在上一轮中，0号小朋友的位置就是3=（0+3）%7</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ46.png" alt="图示" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (m+LastRemaining_Solution(n-<span class="number">1</span>,m))%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ47-1-2-3-…-n"><a href="#JZ47-1-2-3-…-n" class="headerlink" title="JZ47 1+2+3+…+n"></a>JZ47 1+2+3+…+n</h1><p>递归，<code>&amp;&amp;</code>运算先算左边，成立再算右边，不成立就不算右边了；而<code>&amp;</code>两边同时算。所以可以用<code>&amp;&amp;</code>来实现当i=0时就不递归了（右边不继续算了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ite=n;</span><br><span class="line">        <span class="keyword">boolean</span> flag=(n!=<span class="number">0</span>)&amp;&amp;((ite+=Sum_Solution(n-<span class="number">1</span>))!=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h1><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>二进制中，异或<code>^</code>就是相加（不含进位），按位与<code>&amp;</code>就是求进位，再用递归即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=num1^num2;</span><br><span class="line">        <span class="keyword">int</span> carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">0</span>)<span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> Add(sum,carry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ49-字符串转换成整数"><a href="#JZ49-字符串转换成整数" class="headerlink" title="JZ49 字符串转换成整数"></a>JZ49 字符串转换成整数</h1><p>题目：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<ul>
<li><p>输入描述:输入一个字符串,包括数字字母符号,可以为空</p>
</li>
<li><p>返回值描述:如果是合法的数值表达则返回该数字，否则返回0</p>
</li>
</ul>
<p>思路：</p>
<ul>
<li>0位只能是’+’ ‘-‘或者数字</li>
<li>中间有非数字就返回0</li>
<li>注意越界，<code>Integer.MAX_VALUE</code>和<code>Integer.MIN_VALUE</code>，可以先用long存储数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> num=<span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">int</span> zf=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||str==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;str.charAt(i)==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                zf=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;str.charAt(i)==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                zf=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((str.charAt(i)-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>)&amp;&amp;(<span class="string">&#x27;9&#x27;</span>-str.charAt(i)&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">                num=num*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zf==<span class="number">0</span>&amp;&amp;num&gt;Integer.MAX_VALUE)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(zf==<span class="number">1</span>&amp;&amp;(-num&lt;Integer.MIN_VALUE))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=(<span class="keyword">int</span>)num;</span><br><span class="line">        <span class="keyword">return</span> zf==<span class="number">0</span>?result:-result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JZ50-数组中重复的数字："><a href="#JZ50-数组中重复的数字：" class="headerlink" title="JZ50 数组中重复的数字："></a>JZ50 数组中重复的数字：</h1><ul>
<li>利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数+n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。不需要额外的空间消耗，时间效率是O(n)</li>
<li>HashMap</li>
</ul>
<h1 id="JZ51-构建乘积数组"><a href="#JZ51-构建乘积数组" class="headerlink" title="JZ51 构建乘积数组"></a>JZ51 构建乘积数组</h1><p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<p>注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<p>思路：</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01252.png" style="zoom:67%;" />

<p>先计算下三角到B[]中，再计算上三角到B[]中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> []B=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            tmp*=A[i-<span class="number">1</span>];</span><br><span class="line">            B[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            tmp*=A[i+<span class="number">1</span>];</span><br><span class="line">            B[i]*=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ52-正则表达式匹配"><a href="#JZ52-正则表达式匹配" class="headerlink" title="JZ52 正则表达式匹配"></a>JZ52 正则表达式匹配</h1><p>使用递归</p>
<ul>
<li><p>模式中的第二个字符是’*’时：</p>
<ul>
<li><p>字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。</p>
</li>
<li><p>字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</p>
<ul>
<li>模式后移2字符，相当于x*被忽略；</li>
<li>字符串后移1字符，模式后移2字符；</li>
<li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</li>
</ul>
</li>
</ul>
</li>
<li><p>模式中的第二个字符不是’*’时</p>
<ul>
<li>字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li>
<li>字符串第一个字符和模式中的第一个字符相不匹配，直接返回false</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">    <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || </span><br><span class="line">            (pattern[patternIndex] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//x*匹配0个字符</span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//匹配1个字符</span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配多个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || </span><br><span class="line">        (pattern[patternIndex] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ53-表示数值的字符串"><a href="#JZ53-表示数值的字符串" class="headerlink" title="JZ53 表示数值的字符串"></a>JZ53 表示数值的字符串</h1><p>题目：</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>思路：</p>
<ul>
<li>只能有一个小数点</li>
<li>只能有1个e</li>
<li>e后面必须有一个数且是整数</li>
<li>正负号只能出现在第一位或e后面的第一位</li>
<li>小数点前一位只能是0~9或者+-，可以是第一位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flagfloat=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flage=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flage&amp;&amp;(str[i]==<span class="string">&#x27;e&#x27;</span>||str[i]==<span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">                flage=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;str.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i+<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>||str[i+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((!flagfloat)&amp;&amp;(!flage)&amp;&amp;(str[i]==<span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                flagfloat=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((str[i-<span class="number">1</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i-<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)||</span><br><span class="line">                        str[i-<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>||</span><br><span class="line">                        str[i-<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ54-字符流中第一个不重复的字符"><a href="#JZ54-字符流中第一个不重复的字符" class="headerlink" title="JZ54 字符流中第一个不重复的字符"></a>JZ54 字符流中第一个不重复的字符</h1><p>题目：</p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>思路：</p>
<ul>
<li>用一个数组存储每个字符出现的次数，没出现是0，出现1次是1，超过1次是2.</li>
<li>用一个队列存储出现过的字符，多次出现不重复入队</li>
<li>每次找只出现一次的字符：查看队头，数组中对应值是1，则返回该字符，不是1就出队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] allchar=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    Queue&lt;Character&gt; charqueue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(allchar[ch]==<span class="number">0</span>)&#123;</span><br><span class="line">            charqueue.offer(ch);</span><br><span class="line">            allchar[ch]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(allchar[ch]==<span class="number">1</span>)&#123;</span><br><span class="line">            allchar[ch]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!charqueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp=charqueue.peek();</span><br><span class="line">            <span class="keyword">if</span>(allchar[tmp]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                charqueue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ55-链表中环的入口结点"><a href="#JZ55-链表中环的入口结点" class="headerlink" title="JZ55 链表中环的入口结点"></a>JZ55 链表中环的入口结点</h1><p>题目：</p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p>思路：</p>
<p>快慢指针:</p>
<p><strong>两个结论：</strong></p>
<ol>
<li><p>设置快慢指针从head开始走，快指针每次走两步，慢指针每次走一步。假如有环，他们最后一定相遇。</p>
</li>
<li><p>两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。</p>
</li>
</ol>
<p><strong>证明结论1</strong>：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。</p>
<p><strong>证明结论2：</strong></p>
<p>设：</p>
<p>链表头到环入口长度为–<strong>a</strong></p>
<p>环入口到相遇点长度为–<strong>b</strong></p>
<p>相遇点到环入口长度为–<strong>c</strong></p>
<p>相遇时</p>
<p><strong>快指针路程=a+(b+c)k+b</strong> ，k&gt;=1 其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。</p>
<p><strong>慢指针路程=a+b</strong></p>
<p>快指针走的路程是慢指针的两倍，所以：</p>
<p><strong>（a+b）*2=a+(b+c)k+b</strong></p>
<p>化简可得：</p>
<p><strong>a=(k-1)(b+c)+c</strong> 这个式子的意思是： <strong>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度</strong>。其中k&gt;=1,所以<strong>k-1&gt;=0</strong>圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01261.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode pfast=pHead;</span><br><span class="line">        ListNode pslow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(pfast!=<span class="keyword">null</span>&amp;&amp;pfast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pfast=pfast.next.next;</span><br><span class="line">            pslow=pslow.next;</span><br><span class="line">            <span class="keyword">if</span>(pslow==pfast)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pfast==<span class="keyword">null</span>||pfast.next==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        pslow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(pslow!=pfast)&#123;</span><br><span class="line">            pslow=pslow.next;</span><br><span class="line">            pfast=pfast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pslow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ56-删除链表中重复的结点"><a href="#JZ56-删除链表中重复的结点" class="headerlink" title="JZ56 删除链表中重复的结点"></a>JZ56 删除链表中重复的结点</h1><p>题目：</p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>思路：</p>
<ul>
<li>两个指针，一个记录前一个结点，一个记录当前结点</li>
<li>创建一个meta结点接在pHead前，以处理第一个结点就是重复结点的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode meta=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        meta.next=pHead;</span><br><span class="line">        ListNode p1=meta;</span><br><span class="line">        ListNode p2=pHead;</span><br><span class="line">        <span class="keyword">if</span>(p2==<span class="keyword">null</span>)<span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="keyword">null</span>&amp;&amp;p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.next.val==p2.val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(p2.next!=<span class="keyword">null</span>&amp;&amp;p2.next.val==p2.val)&#123;</span><br><span class="line">                    p2=p2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                p1.next=p2.next;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> meta.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ57-二叉树的下一个结点"><a href="#JZ57-二叉树的下一个结点" class="headerlink" title="JZ57 二叉树的下一个结点"></a>JZ57 二叉树的下一个结点</h1><p>题目：</p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p>思路：</p>
<ul>
<li>有右孩子，找到右孩子的最左左孩子</li>
<li>没有右孩子<ul>
<li>节点是父节点的左孩子，返回父节点</li>
<li>节点是父节点的右孩子，递归父节点</li>
<li>节点或父节点是null，返回null</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeLinkNode tmpNode;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tmpNode=pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(tmpNode.left!=<span class="keyword">null</span>)tmpNode=tmpNode.left;</span><br><span class="line">            <span class="keyword">return</span> tmpNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode(pNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeLinkNode <span class="title">rightNode</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="keyword">null</span>||pNode.next==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.next.left==pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> rightNode(pNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ58-对称的二叉树"><a href="#JZ58-对称的二叉树" class="headerlink" title="JZ58 对称的二叉树"></a>JZ58 对称的二叉树</h1><p>题目：</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>思路：</p>
<ul>
<li><p>递归：左孩子的左孩子等于右孩子的右孩子，左孩子的右孩子等于右孩子的左孩子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> comp(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">comp</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val==right.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> comp(left.left,right.right)&amp;&amp;comp(left.right,right.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用栈实现DFS，每次成对入栈，成对出栈(注意：null也会入栈)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(pRoot.left);</span><br><span class="line">        s.push(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            TreeNode right = s.pop();<span class="comment">//成对取出</span></span><br><span class="line">            TreeNode left = s.pop();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//成对插入</span></span><br><span class="line">            s.push(left.left);</span><br><span class="line">            s.push(right.right);</span><br><span class="line">            s.push(left.right);</span><br><span class="line">            s.push(right.left);</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用队列实现BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetricalBFS</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       Queue&lt;TreeNode&gt; s = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       s.offer(pRoot.left);</span><br><span class="line">       s.offer(pRoot.right);</span><br><span class="line">       <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">           TreeNode left= s.poll();<span class="comment">//成对取出</span></span><br><span class="line">           TreeNode right= s.poll();</span><br><span class="line">           <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//成对插入</span></span><br><span class="line">           s.offer(left.left);</span><br><span class="line">           s.offer(right.right);</span><br><span class="line">           s.offer(left.right);</span><br><span class="line">           s.offer(right.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="JZ59-按之字形顺序打印二叉树"><a href="#JZ59-按之字形顺序打印二叉树" class="headerlink" title="JZ59 按之字形顺序打印二叉树"></a>JZ59 按之字形顺序打印二叉树</h1><p>题目：</p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>思路：</p>
<ul>
<li>层序遍历，然后分奇偶插入Deque的前后</li>
<li>层序遍历，然后分奇偶插入做Collections.reverse</li>
<li>用两个栈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stackji=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stackou=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        stackji.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stackou.empty()||!stackji.empty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; jishu=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stackji.empty())&#123;</span><br><span class="line">                TreeNode tmp=stackji.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">                jishu.add(tmp.val);</span><br><span class="line">                stackou.push(tmp.left);</span><br><span class="line">                stackou.push(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; oushu=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stackou.empty())&#123;</span><br><span class="line">                TreeNode tmp2=stackou.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp2==<span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">                oushu.add(tmp2.val);</span><br><span class="line">                stackji.push(tmp2.right);</span><br><span class="line">                stackji.push(tmp2.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!jishu.isEmpty())result.add(jishu);</span><br><span class="line">            <span class="keyword">if</span>(!oushu.isEmpty())result.add(oushu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ60-把二叉树打印成多行"><a href="#JZ60-把二叉树打印成多行" class="headerlink" title="JZ60 把二叉树打印成多行"></a>JZ60 把二叉树打印成多行</h1><p>题目：</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</p>
<p>思路：</p>
<p>层序遍历</p>
<h1 id="JZ61-序列化二叉树"><a href="#JZ61-序列化二叉树" class="headerlink" title="JZ61 序列化二叉树"></a>JZ61 序列化二叉树</h1><p>题目：</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树</p>
<p>思路：</p>
<p>以前序遍历为例，写个前序遍历，再写个递归来反序列化。重点是：</p>
<ul>
<li>String类型要比较的话要用<code>equals()</code></li>
<li>String类型分割用<code>split()</code>成String[]</li>
<li>String转Int用<code>Integer.parseInt()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Stack&lt;TreeNode&gt; myStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        myStack.push(root);</span><br><span class="line">        TreeNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(!myStack.empty())&#123;</span><br><span class="line">            tmp=myStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                result.append(<span class="string">&quot;#!&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(String.valueOf(tmp.val)+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">                myStack.push(tmp.right);</span><br><span class="line">                myStack.push(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        String[]strnew=str.split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Des(strnew);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Des</span><span class="params">(String []strnew)</span></span>&#123;</span><br><span class="line">        TreeNode newtree=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(strnew[index].equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> newtree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> now=Integer.parseInt(strnew[index]);</span><br><span class="line">            newtree=<span class="keyword">new</span> TreeNode(now);</span><br><span class="line">            index++;</span><br><span class="line">            newtree.left=Des(strnew);</span><br><span class="line">            newtree.right=Des(strnew);</span><br><span class="line">            <span class="keyword">return</span> newtree;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ62-二叉搜索树的第k个结点"><a href="#JZ62-二叉搜索树的第k个结点" class="headerlink" title="JZ62 二叉搜索树的第k个结点"></a>JZ62 二叉搜索树的第k个结点</h1><p>题目：</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p>
<p>思路：</p>
<p>中序遍历，注意k的界限判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TreeNode newnode=pRoot;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; relink=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; restack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!restack.empty()||newnode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(newnode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                restack.push(newnode);</span><br><span class="line">                newnode=newnode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode tmp=restack.pop();</span><br><span class="line">            relink.add(tmp);</span><br><span class="line">            newnode=tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;relink.size())<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> relink.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ63-数据流中的中位数"><a href="#JZ63-数据流中的中位数" class="headerlink" title="JZ63 数据流中的中位数"></a>JZ63 数据流中的中位数</h1><p>题目：</p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p>思路：</p>
<p>用两个优先级队列，一个小顶堆min一个大顶堆max，min队首是队中最小值，max队首是队中最大值。保证min的队首&gt;max的队首。每次都插入新数据到min，如果min队首小于max了，就将队首放到max中。如果两个堆的size相差2了，就平衡一下两个堆的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(maxcp);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Integer&gt; maxcp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer c1,Integer c2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(c2-c1);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        minHeap.offer(num);</span><br><span class="line">        <span class="keyword">if</span>(!maxHeap.isEmpty()&amp;&amp;minHeap.peek()&lt;maxHeap.peek())&#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size()-maxHeap.size()==<span class="number">2</span>)&#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size()-maxHeap.size()==-<span class="number">2</span>)&#123;</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size()&gt;maxHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minHeap.size()&lt;maxHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek().doubleValue()+minHeap.peek().doubleValue())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ64-滑动窗口的最大值"><a href="#JZ64-滑动窗口的最大值" class="headerlink" title="JZ64 滑动窗口的最大值"></a>JZ64 滑动窗口的最大值</h1><p>题目：</p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>窗口大于数组长度的时候，返回空</p>
<p>思路：</p>
<p>假设我们当前遍历到下标i，对于下标i+1的元素（假设i和i+1都在同一个窗口）</p>
<ul>
<li>如果arr[i+1] &gt;arr[i], 那么arr[i]永远不可能是窗口最大值</li>
<li>如果arr[i+1] &lt; arr[i]，那么arr[i]和arr[i+1]都需要保留，因为之后可能arr[i]之前的最大值会失效</li>
</ul>
<p>所以使用双端队列<code>ArrayDeque</code></p>
<ol>
<li><p>遍历数组的每一个元素，</p>
</li>
<li><p>如果容器为空，则直接将当前元素加入到容器中。</p>
</li>
<li><p>如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续讲当前元素和容器的最后一个元素比较</p>
</li>
<li><p>如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾</p>
</li>
<li><p>如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size&gt;num.length||size&lt;=<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; wd=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wd.isEmpty())&#123; <span class="comment">//2</span></span><br><span class="line">                wd.addFirst(num[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=size&amp;&amp;num[i-size]==wd.peek())&#123;<span class="comment">//5</span></span><br><span class="line">                    wd.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!wd.isEmpty()&amp;&amp;(num[i]&gt;wd.getLast()))&#123; <span class="comment">//3</span></span><br><span class="line">                    wd.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                wd.addLast(num[i]);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=size-<span class="number">1</span>)result.add(wd.getFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ65-矩阵中的路径"><a href="#JZ65-矩阵中的路径" class="headerlink" title="JZ65 矩阵中的路径"></a>JZ65 矩阵中的路径</h1><p>题目：</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如<br>$$<br>\begin{bmatrix} a &amp; b &amp; c &amp;e \ s &amp; f &amp; c &amp; s \ a &amp; d &amp; e&amp; e\ \end{bmatrix}<br>$$</p>
<p>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>思路：</p>
<p>使用回溯递归。</p>
<p>算法框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[]done=<span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line">                <span class="keyword">int</span> stridx=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(head(i,j,done,rows,cols,matrix,str,stridx))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">head</span><span class="params">(<span class="keyword">int</span> nowrow,<span class="keyword">int</span> nowcol,<span class="keyword">int</span> []done,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">int</span> rows,<span class="keyword">int</span> cols,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">char</span>[]matrix,<span class="keyword">char</span>[]str,<span class="keyword">int</span> stridx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[nowrow*cols+nowcol]!=str[stridx])&#123;<span class="comment">//当前元素和str的当前元素不等，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stridx++;</span><br><span class="line">            <span class="keyword">if</span>(stridx==str.length)<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//str全部元素都遍历完，返回true</span></span><br><span class="line">            done[nowrow*cols+nowcol]=<span class="number">1</span>;<span class="comment">//当前元素已访问，将done数组当前元素位置标为1</span></span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            <span class="keyword">if</span>(nowcol-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;done[nowrow*cols+nowcol-<span class="number">1</span>]!=<span class="number">1</span>)&#123;<span class="comment">//左边元素边界合法且未被访问</span></span><br><span class="line">                <span class="keyword">boolean</span> bleft=head(nowrow,nowcol-<span class="number">1</span>,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bleft)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            <span class="keyword">if</span>(nowcol+<span class="number">1</span>&lt;cols&amp;&amp;done[nowrow*cols+nowcol+<span class="number">1</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> bright=head(nowrow,nowcol+<span class="number">1</span>,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bright)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//up</span></span><br><span class="line">            <span class="keyword">if</span>(nowrow-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;done[(nowrow-<span class="number">1</span>)*cols+nowcol]!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> bup=head(nowrow-<span class="number">1</span>,nowcol,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bup)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//down</span></span><br><span class="line">            <span class="keyword">if</span>(nowrow+<span class="number">1</span>&lt;rows&amp;&amp;done[(nowrow+<span class="number">1</span>)*cols+nowcol]!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> bdown=head(nowrow+<span class="number">1</span>,nowcol,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bdown)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ66-机器人的运动范围"><a href="#JZ66-机器人的运动范围" class="headerlink" title="JZ66 机器人的运动范围"></a>JZ66 机器人的运动范围</h1><p>题目：</p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：</p>
<p>回溯递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][]done=<span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        next(threshold,rows,cols,<span class="number">0</span>,<span class="number">0</span>,done);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> thre,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> nowrow,<span class="keyword">int</span> nowcol,<span class="keyword">int</span>[][]done)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nowrow&lt;rows &amp;&amp; nowcol&lt;cols &amp;&amp; nowrow&gt;=<span class="number">0</span> &amp;&amp; nowcol&gt;=<span class="number">0</span> &amp;&amp; <span class="comment">//格子坐标不越界</span></span><br><span class="line">           done[nowrow][nowcol]!=<span class="number">1</span>&amp;&amp;  <span class="comment">//格子未被访问</span></span><br><span class="line">           legal(nowrow,nowcol,thre))&#123;   <span class="comment">//格子小于等于阈值</span></span><br><span class="line">            num++;</span><br><span class="line">            done[nowrow][nowcol]=<span class="number">1</span>;</span><br><span class="line">            next(thre,rows,cols,nowrow,nowcol-<span class="number">1</span>,done);<span class="comment">//left</span></span><br><span class="line">            next(thre,rows,cols,nowrow,nowcol+<span class="number">1</span>,done);<span class="comment">//right</span></span><br><span class="line">            next(thre,rows,cols,nowrow+<span class="number">1</span>,nowcol,done);<span class="comment">//up</span></span><br><span class="line">            next(thre,rows,cols,nowrow-<span class="number">1</span>,nowcol,done);<span class="comment">//down</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">legal</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> thre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row!=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp+=row%<span class="number">10</span>;</span><br><span class="line">            row/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(col!=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp+=col%<span class="number">10</span>;</span><br><span class="line">            col/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;thre)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h1><p>题目：</p>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路：</p>
<p>暴力递归会超时，采用一个数组，记录已经计算过的值。</p>
<p>另外注意对于2,3来说，如果是绳子长，那么最大值分别是1和2，如果是递归中，那么最大值是2和3.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] done=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">3</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            done[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back(target,done);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span>[]done)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">4</span>)<span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;target;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(done[target-i]==<span class="number">0</span>)&#123;</span><br><span class="line">                done[target-i]=back(target-i,done);</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=Math.max(maxnum,i*done[target-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Allen Yi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ifwant.tech/2020/12/10/jianzhioffer/">https://ifwant.tech/2020/12/10/jianzhioffer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ifwant.tech" target="_blank">ifwant ^_^</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post_share"><div class="social-share" data-image="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/19/jvm_1/"><img class="prev-cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">深入理解JAVA虚拟机</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/02/iot/"><img class="next-cover" src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbcon2stcj34q335eqv6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">腾讯物联网-甲醛检测</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/12/28/binaryrteebianli/" title="二叉树遍历"><img class="cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/62258773_p0.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-28</div><div class="title">二叉树遍历</div></div></a></div><div><a href="/2020/12/28/collection/" title="Java集合总结"><img class="cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/78323842_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-28</div><div class="title">Java集合总结</div></div></a></div><div><a href="/2021/03/25/dpmodel/" title="动态规划代码模板"><img class="cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/61606256_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-25</div><div class="title">动态规划代码模板</div></div></a></div><div><a href="/2021/01/19/gbf_2/" title="synchronized"><img class="cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/82052350_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-19</div><div class="title">synchronized</div></div></a></div><div><a href="/2021/02/27/javadl/" title="java动态代理"><img class="cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/78445866_p0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-27</div><div class="title">java动态代理</div></div></a></div><div><a href="/2021/01/20/map/" title="HashMap和ConcurrentHashMap"><img class="cover" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/86849083_p0%20%281%29%281%29.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-20</div><div class="title">HashMap和ConcurrentHashMap</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Allen Yi</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qingshangithub"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qingshangithub" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1056914402@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="qq:1056914402" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">对未来充满热爱<div class="twopeople"><div class="twopeople"><div class="container" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/js/twopeople1.js"></script><script src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/js/zdog.dist.js"></script><script id="rendered-js" src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/js/twopeople.js"></script><style>.twopeople{margin: 0;align-items: center;justify-content: center;text-align: center;}canvas {display: block;margin: 0 auto;cursor: move;}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ13%EF%BC%9A%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="toc-text">JZ13：调整数组顺序使奇数位于偶数前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ14-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">JZ14 链表中倒数第k个结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-text">JZ15 反转链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="toc-text">JZ16 合并两个排序的链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ17-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">JZ17 树的子结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ18-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">JZ18 二叉树的镜像</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ19-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-text">JZ19 顺时针打印矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ20-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="toc-text">JZ20 包含min函数的栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ21-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="toc-text">JZ21 栈的压入和弹出序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ22-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">JZ22 从上往下打印二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-text">JZ23 二叉搜索树的后序遍历序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ24-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">JZ24 二叉树和为某一值的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">JZ25 复杂链表的复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ26-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">JZ26 二叉搜索树与双向链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ27-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97"><span class="toc-text">JZ27 字符串排列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ28-%E6%95%B0%E7%BB%84%E4%B8%AD%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0"><span class="toc-text">JZ28 数组中超过一半的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ29-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="toc-text">JZ29 最小的K个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ30-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-text">JZ30 连续子数组的最大和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ31-%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">JZ31 整数中1出现的次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ32-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-text">JZ32 把数组排成最小的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ33-%E4%B8%91%E6%95%B0"><span class="toc-text">JZ33 丑数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ34-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">JZ34 第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ35-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-text">JZ35 数组中的逆序对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ36-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9"><span class="toc-text">JZ36 两个链表的第一个公共结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ37-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">JZ37 数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ38-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="toc-text">JZ38 二叉树深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ39-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">JZ39 平衡二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ40-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">JZ40 数组中只出现一次的数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ41-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="toc-text">JZ41 和为S的连续正数序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ42-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-text">JZ42 和为S的两个数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ43-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">JZ43 左旋转字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ44-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97"><span class="toc-text">JZ44 翻转单词顺序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ45-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90"><span class="toc-text">JZ45 扑克牌顺子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ46-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0"><span class="toc-text">JZ46 圆圈中最后剩下的数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ47-1-2-3-%E2%80%A6-n"><span class="toc-text">JZ47 1+2+3+…+n</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ48-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-text">JZ48 不用加减乘除做加法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ49-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="toc-text">JZ49 字符串转换成整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ50-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%9A"><span class="toc-text">JZ50 数组中重复的数字：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ51-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="toc-text">JZ51 构建乘积数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ52-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">JZ52 正则表达式匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ53-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">JZ53 表示数值的字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ54-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">JZ54 字符流中第一个不重复的字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ55-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="toc-text">JZ55 链表中环的入口结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ56-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-text">JZ56 删除链表中重复的结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ57-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">JZ57 二叉树的下一个结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ58-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">JZ58 对称的二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">JZ59 按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ60-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C"><span class="toc-text">JZ60 把二叉树打印成多行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ61-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">JZ61 序列化二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ62-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="toc-text">JZ62 二叉搜索树的第k个结点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ63-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">JZ63 数据流中的中位数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ64-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">JZ64 滑动窗口的最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ65-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">JZ65 矩阵中的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ66-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">JZ66 机器人的运动范围</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JZ67-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="toc-text">JZ67 剪绳子</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/02/27/goland/" title="goland使用技巧"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/022701.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="goland使用技巧"/></a><div class="content"><a class="title" href="/2022/02/27/goland/" title="goland使用技巧">goland使用技巧</a><time datetime="2022-02-27T03:41:39.000Z" title="发表于 2022-02-27 11:41:39">2022-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/21/kratos/" title="Kratos 笔记"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/22022101.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kratos 笔记"/></a><div class="content"><a class="title" href="/2022/02/21/kratos/" title="Kratos 笔记">Kratos 笔记</a><time datetime="2022-02-21T13:10:39.000Z" title="发表于 2022-02-21 21:10:39">2022-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/golang/" title="Go语言基础"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/21112216.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言基础"/></a><div class="content"><a class="title" href="/2022/01/15/golang/" title="Go语言基础">Go语言基础</a><time datetime="2022-01-15T04:30:39.000Z" title="发表于 2022-01-15 12:30:39">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/06/nysj/" title="备忘录"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/21112213.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="备忘录"/></a><div class="content"><a class="title" href="/2021/12/06/nysj/" title="备忘录">备忘录</a><time datetime="2021-12-06T09:19:39.000Z" title="发表于 2021-12-06 17:19:39">2021-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/22/video/" title="发布在b站的视频"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/21112214.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="发布在b站的视频"/></a><div class="content"><a class="title" href="/2021/11/22/video/" title="发布在b站的视频">发布在b站的视频</a><time datetime="2021-11-22T09:22:39.000Z" title="发表于 2021-11-22 17:22:39">2021-11-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Allen Yi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://ifwant.tech/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="7083053787" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>