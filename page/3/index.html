<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-other" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/01/other/" class="article-date">
  <time class="dt-published" datetime="2021-01-01T02:37:39.000Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/01/other/">零散的Java语法和类笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="三种String"><a href="#三种String" class="headerlink" title="三种String"></a>三种String</h1><p>String ：不可改变的，<br>StringBuilder ：可改变，速度快，线程不安全<br>StringBuffer：可改变，线程安全</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;abc&quot;</span>;<span class="comment">//创建在方法区的常量池里，相同值则共用</span></span><br><span class="line">String str=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">//创建在堆上，每个对象单独分配</span></span><br><span class="line">str.length();<span class="comment">//字符串长度</span></span><br><span class="line">str.concat(str);<span class="comment">//拼接字符串</span></span><br><span class="line">str.substring(<span class="number">0</span>,n);<span class="comment">//子字符串，左闭右开</span></span><br><span class="line">str.charAt();<span class="comment">//索引处char值</span></span><br></pre></td></tr></table></figure>

<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">StringBuilder str=<span class="keyword">new</span> StringBuilder(<span class="number">12</span>);<span class="comment">//创建时也可以先开辟空间，再append进去字符</span></span><br><span class="line">str.length();<span class="comment">//字符串长度</span></span><br><span class="line">str.append(<span class="string">&quot;efg&quot;</span>);<span class="comment">//追加字符</span></span><br><span class="line">str.delete(<span class="number">0</span>,n);<span class="comment">//删除字符，左闭右开</span></span><br><span class="line">str.insert(<span class="number">0</span>,<span class="string">&quot;aaa&quot;</span>);<span class="comment">//插入字符</span></span><br><span class="line">str.toString();<span class="comment">//转String</span></span><br><span class="line">str.reverse();<span class="comment">//反转</span></span><br><span class="line">str.substring(<span class="number">0</span>,n);<span class="comment">//子字符串，左闭右开</span></span><br></pre></td></tr></table></figure>

<h2 id="String和char数组转换"><a href="#String和char数组转换" class="headerlink" title="String和char数组转换"></a>String和char数组转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String-&gt;char[]</span></span><br><span class="line"><span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line"><span class="comment">//char[]-&gt;String</span></span><br><span class="line">String s=<span class="keyword">new</span> String(ch);</span><br></pre></td></tr></table></figure>



<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort();<span class="comment">//数组排序</span></span><br><span class="line">Arrays.copyOfRange (array,start,end);<span class="comment">//复制数组</span></span><br><span class="line">Arrays.toString();<span class="comment">//转String</span></span><br></pre></td></tr></table></figure>

<h1 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29520044">hash冲突</a></h1><p>解决方法：</p>
<ul>
<li>再散列法：以计算出的hash值再计算hash<ul>
<li>线性探测：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</li>
<li>二次探测：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</li>
<li>伪随机探测：伪随机数序列参与计算</li>
</ul>
</li>
<li>再哈希法：构造多个哈希函数</li>
<li>链地址法：哈希值相同的存在一个单链表里</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/01/other/" data-id="ckw9lgzyn001j2ww5hn7thkcv" data-title="零散的Java语法和类笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-collection" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/28/collection/" class="article-date">
  <time class="dt-published" datetime="2020-12-28T14:25:39.000Z" itemprop="datePublished">2020-12-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/28/collection/">Java集合总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th></th>
<th>Stack</th>
<th>ArrayList</th>
<th>LinkedList</th>
<th>HashMap</th>
<th>HashSet</th>
<th>Queue</th>
</tr>
</thead>
<tbody><tr>
<td>添加元素</td>
<td>push</td>
<td>add, addAll</td>
<td>add, addAll</td>
<td>put</td>
<td>add</td>
<td>offer</td>
</tr>
<tr>
<td>删除元素</td>
<td>pop</td>
<td>remove</td>
<td>remove</td>
<td>remove</td>
<td>remove</td>
<td>poll</td>
</tr>
<tr>
<td>查看第一个元素</td>
<td>peek</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>peek</td>
</tr>
<tr>
<td>查看指定元素</td>
<td></td>
<td>get</td>
<td>get</td>
<td>get</td>
<td></td>
<td></td>
</tr>
<tr>
<td>修改元素</td>
<td></td>
<td>set</td>
<td>set</td>
<td>replace,put</td>
<td></td>
<td></td>
</tr>
<tr>
<td>大小</td>
<td>size</td>
<td>size</td>
<td>size</td>
<td>size</td>
<td>size</td>
<td>size</td>
</tr>
<tr>
<td>判断元素是否存在</td>
<td>search</td>
<td>contains</td>
<td>contains</td>
<td>containsKey,containsValue</td>
<td>contains</td>
<td></td>
</tr>
<tr>
<td>是否为空</td>
<td>empty</td>
<td>isEmpty</td>
<td>isEmpty</td>
<td>isEmpty</td>
<td></td>
<td></td>
</tr>
<tr>
<td>线程安全</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<p>初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Object&gt; <span class="keyword">var</span>=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">ArrayList&lt;Object&gt; <span class="keyword">var</span>=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">LinkedList&lt;Object&gt; <span class="keyword">var</span>=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">HashSet&lt;Object&gt; <span class="keyword">var</span>=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Queue&lt;Object&gt; <span class="keyword">var</span>=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">HashMap&lt;Key,Value&gt; <span class="keyword">var</span>=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search(Object)<span class="comment">//查找元素所在位置，栈顶为1，不存在则返回-1</span></span><br></pre></td></tr></table></figure>

<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(value)<span class="comment">//末尾添加元素</span></span><br><span class="line">add(index,value)<span class="comment">//指定位置添加元素</span></span><br><span class="line">addAll(index,collection)<span class="comment">//添加集合的所有元素到index（可省略）之后</span></span><br><span class="line">remove(index)<span class="comment">//删除元素,参数可以是元素，也可以是索引</span></span><br><span class="line">get(index)<span class="comment">//访问元素</span></span><br><span class="line">set(index,value)<span class="comment">//修改元素</span></span><br><span class="line">size()<span class="comment">//大小</span></span><br></pre></td></tr></table></figure>



<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>同ArrayList</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>线程安全的ArrayList</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Key, Value&gt; Sites = <span class="keyword">new</span> HashMap&lt;Key, Value&gt;();</span><br><span class="line">Sites.put(Key,Value);<span class="comment">//添加元素</span></span><br><span class="line">Sites.get(Key);<span class="comment">//获取Key对应的Value</span></span><br><span class="line">Sites.remove(Key);<span class="comment">//删除元素</span></span><br><span class="line">Sites.clear();<span class="comment">//删除所有键值对</span></span><br><span class="line">Sites.size();<span class="comment">//计算元素数量</span></span><br><span class="line">Sites.getOrDefault(Key,defaultvalue);<span class="comment">//如果map中有key，就返回他的value，没有key，就返回defaultvalue</span></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (Integer i : Sites.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;key: &quot;</span> + i + <span class="string">&quot; value: &quot;</span> + Sites.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String value: Sites.values()) &#123;</span><br><span class="line">    System.out.print(value + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul>
<li>HashMap+双向链表</li>
<li>头部是最久远的节点，尾部是最新的节点</li>
<li>布尔变量<code>accessOrder</code>决定<code>get</code>和<code>put</code>函数调用后是否把节点放在尾部，具体实现在<code>afterNodeAccess</code>函数里</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按顺序遍历</span></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String,Integer&gt; entry:seqMap.entrySet())&#123;</span><br><span class="line">	System.out.println(entry.getKey()+<span class="string">&quot; &quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>支持两种顺序<strong>插入顺序 、 访问顺序</strong></p>
<ol>
<li>插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序</li>
<li>访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置按照访问顺序排序，accessOrder设为true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span></span>;</span><br></pre></td></tr></table></figure>



<p>实现LRU:最久没访问的放在队头，最近访问的放在队尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>线程安全，弃用了</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>默认按照key排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();<span class="comment">//创建</span></span><br><span class="line">TreeMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;(Comparator.reverseOrder());<span class="comment">//指定排序方式，倒序</span></span><br><span class="line"><span class="comment">//基本操作和hashmap一样</span></span><br><span class="line"></span><br><span class="line">treeMap.firstKey();<span class="comment">//返回该TreeMap的第一个（最小的）映射的key</span></span><br><span class="line">treeMap.lastKey();<span class="comment">//返回该TreeMap的最后一个（最大的）映射的key</span></span><br><span class="line">treeMap.subMap(fromKey,toKey);<span class="comment">//返回该TreeMap中指定范围的映射集合（大于等于fromKey，小于toKey）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry : treeMap.entrySet()) &#123;</span><br><span class="line">      System.out.println(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>源码实现是HashMap的一个实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; sites = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">sites.add(<span class="string">&quot;Google&quot;</span>);<span class="comment">//添加元素</span></span><br><span class="line">sites.contains(<span class="string">&quot;Taobao&quot;</span>);<span class="comment">//是否包含元素</span></span><br><span class="line">sites.remove(<span class="string">&quot;Taobao&quot;</span>);<span class="comment">//删除元素</span></span><br><span class="line">sites.size();<span class="comment">//大小</span></span><br></pre></td></tr></table></figure>

<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>源码实现是LinkedHashMap的一个实例</p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>源码实现是TreeMap的一个实例</p>
<p>有序唯一</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>默认小顶堆。myPQ第一个是最小的那个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; myPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">myPQ.offer(<span class="number">1</span>);<span class="comment">//插入元素</span></span><br><span class="line">myPQ.poll();<span class="comment">//取出队列头元素</span></span><br></pre></td></tr></table></figure>

<p>创建自定义优先级：创建一个<code>Comparator</code>对象并重写<code>compare</code>方法，返回<strong>负数</strong>表示<strong>前者更优先</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Untitled</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Queue&lt;Integer&gt; myPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(newCp);</span><br><span class="line">		myPQ.offer(<span class="number">3</span>);</span><br><span class="line">		myPQ.offer(<span class="number">2</span>);</span><br><span class="line">		myPQ.offer(<span class="number">1</span>);</span><br><span class="line">		myPQ.offer(<span class="number">4</span>);</span><br><span class="line">		System.out.println(myPQ.poll());</span><br><span class="line">		System.out.println(myPQ.poll());</span><br><span class="line">		System.out.println(myPQ.poll());</span><br><span class="line">		System.out.println(myPQ.poll());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Integer&gt; newCp = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer c1, Integer c2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(c2-c1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">	   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>双端队列，更多参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenglc/p/10722304.html">这里</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; path=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">offerFirst(E e);<span class="comment">//在队列前面添加元素，并返回是否添加成功</span></span><br><span class="line">offerLast(E e);<span class="comment">//在队列末尾添加元素，并返回是否添加成功</span></span><br><span class="line">pollFirst();<span class="comment">//删除第一个元素，并返回删除元素的值</span></span><br><span class="line">pollLast();<span class="comment">//删除最后一个元素，并返回删除元素的值</span></span><br><span class="line">getFirst();<span class="comment">//获取第一个元素</span></span><br><span class="line">getLast();<span class="comment">//获取最后一个元素</span></span><br></pre></td></tr></table></figure>



<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.reverse();<span class="comment">//反转</span></span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写sorts函数的比较函数</span></span><br><span class="line">Comparator&lt;Integer&gt; cmp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b-a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回值为负代表当前对象位置要排在前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于String</span></span><br><span class="line">Comparator&lt;String&gt; myCmp=<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.compareTo(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//compareTo函数，当前值小于参数值，返回负数</span></span><br></pre></td></tr></table></figure>

<h1 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h1><h2 id="数组和List"><a href="#数组和List" class="headerlink" title="数组和List"></a>数组和List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Queue和List"><a href="#Queue和List" class="headerlink" title="Queue和List"></a>Queue和List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">//queue-&gt;list,直接放到构造参数里</span></span><br><span class="line">ArrayList&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/28/collection/" data-id="ckw9lgzwr00062ww5bbpl0sys" data-title="Java集合总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-binaryrteebianli" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/28/binaryrteebianli/" class="article-date">
  <time class="dt-published" datetime="2020-12-28T04:27:39.000Z" itemprop="datePublished">2020-12-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/28/binaryrteebianli/">二叉树遍历</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>二叉树结点结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;val: &quot;</span>+val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRecursion</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    visit(node);</span><br><span class="line">    preOrderRecursion(node.left);</span><br><span class="line">    preOrderRecursion(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>使用栈:根节点出栈，右节点入栈，左节点入栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; preStack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        preStack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!preStack.isEmpty())&#123;</span><br><span class="line">            TreeNode nodeNow=preStack.pop();</span><br><span class="line">            result.add(nodeNow.val);</span><br><span class="line">            <span class="keyword">if</span>(nodeNow.right!=<span class="keyword">null</span>)preStack.push(nodeNow.right);</span><br><span class="line">            <span class="keyword">if</span>(nodeNow.left!=<span class="keyword">null</span>)preStack.push(nodeNow.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><h2 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>使用栈+双层循环：内层循环不停寻找左孩子并入栈，直到没有左孩子；外层循环每次pop出栈顶元素，并都把右孩子（如果有）入栈。</p>
<p>注意一点：外层循环的判断条件是或，即只要栈非空或者结点有右孩子，就继续循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; inStack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode currentNode=root;</span><br><span class="line">        <span class="keyword">while</span>(!inStack.isEmpty()||currentNode!=<span class="keyword">null</span>)&#123;      </span><br><span class="line">            <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                inStack.push(currentNode);</span><br><span class="line">                currentNode=currentNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode=inStack.pop();</span><br><span class="line">            result.add(currentNode.val);</span><br><span class="line">            currentNode=currentNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><h2 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>使用一个栈和一个hashmap，hashmap记录节点是否被访问过。</p>
<p>四种情况访问这个节点：</p>
<ul>
<li><p>没有左右孩子</p>
</li>
<li><p>只有左孩子且左孩子已被访问</p>
</li>
<li><p>只有右孩子且右孩子已被访问</p>
</li>
<li><p>有左右孩子且左右孩子都被访问</p>
</li>
</ul>
<p>左孩子未被访问，则不断把左孩子入栈</p>
<p>右孩子未被访问，把这个右孩子入栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; postStack=<span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Map&lt;TreeNode,Integer&gt; visitedNode=<span class="keyword">new</span> HashMap&lt;TreeNode,Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        postStack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!postStack.isEmpty())&#123;</span><br><span class="line">            TreeNode currentNode=postStack.peek();</span><br><span class="line">            <span class="keyword">if</span>( (currentNode.left==<span class="keyword">null</span>&amp;&amp;currentNode.right==<span class="keyword">null</span>)||</span><br><span class="line">                (currentNode.left==<span class="keyword">null</span>&amp;&amp;currentNode.right!=<span class="keyword">null</span>&amp;&amp;visitedNode.containsKey(currentNode.right))||</span><br><span class="line">                (currentNode.right==<span class="keyword">null</span>&amp;&amp;currentNode.left!=<span class="keyword">null</span>&amp;&amp;visitedNode.containsKey(currentNode.left))||</span><br><span class="line">                (currentNode.right!=<span class="keyword">null</span>&amp;&amp;currentNode.left!=<span class="keyword">null</span>&amp;&amp;visitedNode.containsKey(currentNode.left)&amp;&amp;visitedNode.containsKey(currentNode.right)))&#123;</span><br><span class="line">                result.add(currentNode.val);</span><br><span class="line">                visitedNode.put(currentNode,<span class="number">1</span>);</span><br><span class="line">                postStack.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currentNode.left!=<span class="keyword">null</span>&amp;&amp;(!visitedNode.containsKey(currentNode.left)))&#123;</span><br><span class="line">                <span class="keyword">while</span>(currentNode.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    postStack.push(currentNode.left);</span><br><span class="line">                    currentNode=currentNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(currentNode.right!=<span class="keyword">null</span>&amp;&amp;(!visitedNode.containsKey(currentNode.right)))&#123;</span><br><span class="line">                postStack.push(currentNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h1><h2 id="非递归实现-3"><a href="#非递归实现-3" class="headerlink" title="非递归实现"></a>非递归实现</h2><ul>
<li>使用队列，每次结点出栈后将左右结点依次入队</li>
<li>使用变量<code>levelNum</code>保存当前层的结点个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; nodeQueue=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        nodeQueue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> levelNum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nodeQueue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; levelList=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(levelNum!=<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode tmp=nodeQueue.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodeQueue.offer(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodeQueue.offer(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">                levelList.add(tmp.val);</span><br><span class="line">                levelNum--;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(levelList);</span><br><span class="line">            levelNum=nodeQueue.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/28/binaryrteebianli/" data-id="ckw9lgzwm00032ww52o181rpt" data-title="二叉树遍历" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-sort" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/25/sort/" class="article-date">
  <time class="dt-published" datetime="2020-12-25T01:28:39.000Z" itemprop="datePublished">2020-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/25/sort/">排序算法归纳</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="插入排序（稳）n-2-1"><a href="#插入排序（稳）n-2-1" class="headerlink" title="插入排序（稳）n^2,1"></a>插入排序（稳）n^2,1</h1><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。</p>
<p>使用双层循环</p>
<ul>
<li>外层循环对除了第一个元素之外的所有元素</li>
<li>内层循环将当前元素和前面的元素比较，不满足排序要求则交换这两个元素位置。</li>
</ul>
<p>时间复杂度 <strong>O(n^2)</strong>   空间复杂度<strong>O(1)</strong></p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;length; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[j]和array[j+<span class="number">1</span>]不满足排序顺序)&#123;</span><br><span class="line">            swap(array,j,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>过程图示：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/InsertSort-01.png" alt="insert1"></p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/InsertSort-02.png" alt="insert2"></p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/InsertSort-03.png" alt="insert3"></p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/InsertSort-04.png" alt="insert4"></p>
<h1 id="冒泡排序（稳）n-2-1"><a href="#冒泡排序（稳）n-2-1" class="headerlink" title="冒泡排序（稳）n^2,1"></a>冒泡排序（稳）n^2,1</h1><p>每轮冒泡，<strong>相邻两数，前面的数字大于后面的数字就交换</strong>，这样一轮过后，最大的数放在了最后</p>
<p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span> [] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;<span class="comment">//n轮冒泡</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="归并排序（稳）nlogn-n"><a href="#归并排序（稳）nlogn-n" class="headerlink" title="归并排序（稳）nlogn,n"></a>归并排序（稳）nlogn,n</h1><p>往下做二分递归，往上合并两个排好序的数组递归回去。</p>
<p><strong>时间复杂度：</strong>O(nlogn)，往上的时候深度是logn，合并两个排好序的数组最多需要n次，相乘。</p>
<p><strong>空间复杂度：</strong>O(n)，需要存储两个排好序的数组</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03081.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        mergeSort(a, low, mid);</span><br><span class="line">        mergeSort(a, mid + <span class="number">1</span>, high);</span><br><span class="line">        merge(a, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = low;<span class="comment">// 左指针</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;<span class="comment">// 右指针</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把较小的数先移到新数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[j]) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把左边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把右边边剩余的数移入数组</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把新数组中的数覆盖nums数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k2 = <span class="number">0</span>; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">        a[k2 + low] = temp[k2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="快速排序-nlogn-logn"><a href="#快速排序-nlogn-logn" class="headerlink" title="快速排序 nlogn,logn"></a>快速排序 nlogn,logn</h1><p>分治思想，取出一个数，小于它的放左边，大于的放右边，在分别对左右子序列操作，直到区间只有1个数。</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/21082501.png" style="zoom:50%;" />

<p><strong>时间复杂度</strong>：最优 <strong>O(nlogn)</strong> ，最差 <strong>O(n^2)</strong></p>
<p>最优就是每次划分都是正好一半，遍历是n,每次少一半相当于二分是logn,相乘就是nlogn</p>
<p>最差就是正序或者倒序，每次划分都只是减少1个项，遍历是n，总共n次，相乘就是n^2</p>
<p><strong>空间复杂度</strong>：最优 <strong>O(logn)</strong> ，最差 <strong>O(n)</strong></p>
<p>空间复杂度就是递归树深度，最优logn次递归，最差n次递归</p>
<p>整个划分函数partition主要涉及两个指针<code>i</code>和<code>j</code>，一开始 <code>i = l-1</code> , <code>j = l</code>。我们需要实时维护两个指针使得任意时候，对于任意数组下标k，我们有如下条件成立:</p>
<ol>
<li><code>l ≤ k ≤ i</code>时,<code>nums[k] ≤ pivot</code>。</li>
<li><code>i＋1 ≤ k ≤ j-1</code>时，<code>nums[k] &gt; pivot</code>。</li>
</ol>
<p>我们每次移动指针<code>j</code>，如果<code>nums[j] &gt; pivot</code>，我们只需要继续移动指针<code>j</code>，即能使上述三个条件成立，否则我们需要将指针<code>i</code>加一，然后交换<code>nums[i]</code>和<code>nums[j]</code>，再移动指针<code>j</code>才能使得三个条件成立。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quicksort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = partition(nums, l, r);</span><br><span class="line">            quicksort(nums, l, pos - <span class="number">1</span>);</span><br><span class="line">            quicksort(nums, pos + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">        <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= pivot) &#123;</span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap(nums, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主元是最后一个，两个指针，<code>i</code>从<code>l-1</code>开始，<code>j</code>从<code>l</code>开始，先移动<code>j</code>，不满足条件就交换<code>++i</code>和<code>j</code></strong></p>
<h1 id="堆排序-nlogn-1"><a href="#堆排序-nlogn-1" class="headerlink" title="堆排序 nlogn,1"></a>堆排序 nlogn,1</h1><p>每一次下沉（<code>siftDown</code>）都能把最大的值放到堆顶，然后再把堆顶和数组尾交换，就能把最大的放到数组后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        heapify(nums);<span class="comment">//建堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; ) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            i--;</span><br><span class="line">            siftDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            siftDown(nums, i, len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k + <span class="number">1</span> &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= end &amp;&amp; nums[j + <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[k]) &#123;</span><br><span class="line">                swap(nums, j, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/25/sort/" data-id="ckw9lgzyu001q2ww5ghyp2wzw" data-title="排序算法归纳" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-gbf_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/24/gbf_1/" class="article-date">
  <time class="dt-published" datetime="2020-12-24T07:24:39.000Z" itemprop="datePublished">2020-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/24/gbf_1/">Java高并发程序设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>用来形容方法调用 </p>
<ul>
<li>同步方法调用：方法调用开始后，调用者必须等到方法返回后才能继续后续的操作</li>
<li>异步方法调用：方法调用开始后，异步方法会在另一个线程中执行，调用者可以继续其他操作。当异步方法有返回值时，会在方法调用结束后返回。</li>
</ul>
<p>例子：<br>同步调用就像我们在实体店买东西，我们要自己亲自去实体店，买完东西后我们要亲自把东西带回来，而异步就像网购，我们在完成网上支付时买东西这个事件就已经结束了，我们可以去做其他的一些事情，而卖方会将东西给我们送过来。 </p>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li>并发：多个任务交替执行</li>
<li>并行：多个任务同时执行</li>
</ul>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>共享数据，可以被多个线程使用，但一次只能有一个线程用。</p>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>形容多线程间的相互影响。</p>
<ul>
<li><p>阻塞：一个线程访问了临界区，其他需要这个临界区资源的线程必须等待。</p>
</li>
<li><p>非阻塞：没有一个线程可以妨碍其他线程的执行，所有线程都会不断的向前执行。</p>
</li>
</ul>
<h2 id="死锁、饥饿和活锁"><a href="#死锁、饥饿和活锁" class="headerlink" title="死锁、饥饿和活锁"></a>死锁、饥饿和活锁</h2><ul>
<li>死锁：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象 。</li>
<li>饥饿：一个或者多个线程因为种种原因（例如优先级）无法获得所需要的资源，导致一直无法执行。</li>
<li>活锁：获取不到资源就释放已有资源，一直尝试-失败-尝试-失败。<ul>
<li>例子：  走路时对面堵着一个人，我向左走想避开他，他向右走想避开我，这样我们就有堵在一起了。  </li>
</ul>
</li>
</ul>
<h2 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h2><ul>
<li>阻塞：其他线程释放资源前，当前线程无法执行</li>
<li>无饥饿：线程的调度是公平的，先来先调度，后来后调度，不存在饥饿的现象</li>
<li>无障碍：所有线程无需等待可以一起进入临界区，一旦临界区的数据遭到破坏，所有线程会回滚，保证数据的安全。</li>
<li>无锁：无锁是无障碍的一种，但是无锁保证必然有一个线程能够执行成功</li>
<li>无等待：所有的线程都必须在有限步内完成<ul>
<li>例子：RCU（Read-Copy-Update）对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。 但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在合适的时机回写数据。 </li>
</ul>
</li>
</ul>
<h2 id="多线程的原子性、可见性和有序性"><a href="#多线程的原子性、可见性和有序性" class="headerlink" title="多线程的原子性、可见性和有序性"></a>多线程的原子性、可见性和有序性</h2><ul>
<li>原子性：一个操作不可中断</li>
<li>可见性：一个线程修改了一个共享变量的值，其他线程能否立即知道这个修改。<ul>
<li>缓存优化、硬件优化、指令重排等都可能导致可见性问题</li>
</ul>
</li>
<li>有序性：指令重排可能导致多线程下先写的代码后运行</li>
</ul>
<h2 id="Happen-Before原则"><a href="#Happen-Before原则" class="headerlink" title="Happen-Before原则"></a>Happen-Before原则</h2><p>指令不能重排的原则：</p>
<ul>
<li>程序顺序原则∶ 一个线程内保证语义的串行性 </li>
<li>volatile规则∶volatile变量的写，先发生于读，这保证了volatile变量的可见性</li>
<li>锁规则∶解锁（unlock）必然发生在随后的加锁（lock）前</li>
<li>传递性∶ A先于B，B先于C，那么 A 必然先于 C</li>
<li>线程的 start（）方法先于它的每一个动作 </li>
<li>线程的所有操作先于线程的终结（Thread.join（））</li>
<li>线程的中断（interrupt（））先于被中断线程的代码</li>
<li>对象的构造函数执行、结束先于 finalize（）方法</li>
</ul>
<h1 id="并行程序基础"><a href="#并行程序基础" class="headerlink" title="并行程序基础"></a>并行程序基础</h1><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>Thread中的 State 枚举中定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    NEW, </span><br><span class="line">    RUNNABLE, </span><br><span class="line">    BLOCKED, </span><br><span class="line">    WAITING, <span class="comment">//无限时间等待</span></span><br><span class="line">    TIMED_WAITING, <span class="comment">//有限时间等待</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01184.png"></p>
<h2 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h2><h3 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h3><p>new一个Thread对象，然后start()就可以新建一个线程了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p><code>start()</code>之后会调用<code>run()</code>函数，我们需要在run函数中实现自己想要的功能。</p>
<ul>
<li>继承Thread类（这里是匿名内部类）重载run</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,I am t1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start ();</span><br></pre></td></tr></table></figure>

<ul>
<li>实现Runnable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThread3());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Oh,I am Runnable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>用标记变量来决定是否退出：设置个stopme的boolean，为true就break</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopme = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        stopme = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (stopme) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;exit by stop me&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (u)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=(<span class="keyword">int</span>)(System.currentTimeMillis()/ <span class="number">1000</span>); </span><br><span class="line">                u.setId(v);</span><br><span class="line">                <span class="comment">//oh,do sth. else </span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                u.setName(String.valueOf(v));</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt() <span class="comment">//中断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted() <span class="comment">//判断线程是否中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted() <span class="comment">//判断是否中断，并清除中断状态</span></span><br></pre></td></tr></table></figure>

<p>例子:通过<code>Thread.isInterrupted()</code>l来在<code>run</code>函数里写中断时做的操作，这样中断<code>Thread.interrupt()</code>调用时才有作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">            &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep (<span class="number">2000</span>); </span><br><span class="line">    t1.interrupt ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> ch2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWN</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;<span class="comment">//获取object锁</span></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;T1 wait for object&quot;</span>);</span><br><span class="line">                    object.wait();<span class="comment">//等待并释放object锁</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;T1 end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;<span class="comment">//获取锁</span></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">                object.notify();<span class="comment">//通知T1</span></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">&quot;T2 end&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);<span class="comment">//休眠两秒，两秒后才释放锁，T1才能继续操作</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T1 start!</span><br><span class="line">T1 wait for object</span><br><span class="line">T2 start! notify one thread</span><br><span class="line">T2 end!</span><br><span class="line">T1 end!</span><br></pre></td></tr></table></figure>

<p>wait会释放掉锁，sleep不会。notify之后T1线程要获得锁才能继续执行</p>
<p>wait是object的方法，sleep是Thread的方法</p>
<h3 id="join和yield"><a href="#join和yield" class="headerlink" title="join和yield"></a>join和yield</h3><p>线程a调用线程b的join函数，则a会等待b线程结束才继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AddThread at = <span class="keyword">new</span> AddThread();</span><br><span class="line">        at.start();</span><br><span class="line">        at.join();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yield声明了当前线程已经完成生命周期中最重要的部分，可以切换给其他线程来执行。让出CPU重新参与资源竞争。</p>
<h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>守护线程，当所有用户线程结束时，程序终止，杀死所有守护线程。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>读取volatile类型的变量时总会返回最新写入的值</p>
<ul>
<li>不会指令重排（保证有序性）</li>
<li>变量不会被缓存到寄存器或其他处理器不可见的地方（保证可见性）</li>
</ul>
<p>对非 volatile 变量进行读写的时候，每个线程先从<strong>内存</strong>拷贝变量到<strong>CPU缓存</strong>中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步</p>
<p><strong>性能</strong>：读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</p>
<p><strong>volatile不保证原子性</strong>，所以对于十个线程做i++这种操作，结果会不准确：Java中只有对基本类型变量的赋值和读取是原子操作，如<code>i = 1</code>的赋值操作，但是像<code>j = i</code>或者<code>i++</code>这样的操作都不是原子操作，因为他们都进行了多次原子操作，比如先读取i的值，再将i的值赋值给j，两个原子操作加起来就不是原子操作了。</p>
<ol>
<li>线程读取i </li>
<li>temp = i + 1 </li>
<li>i = temp </li>
</ol>
<p>当 i=5 的时候，A和B两个线程同时读入了 i 的值， 然后A线程执行了<code>temp = i + 1</code>的操作，要注意，此时的 i 的值还没有变化，然后B线程也执行了<code>temp = i + 1</code>的操作，注意，此时A，B两个线程保存的 i 的值都是5，temp 的值都是6， 然后A线程执行了 <code>i = temp</code> 的操作，此时i的值会立即刷新到主存并通知其他线程保存的 i 值失效， 此时B线程需要重新读取 i 的值。那么此时B线程保存的 i 就是6，同时B线程保存的 temp 还仍然是6， 然后B线程执行 <code>i=temp</code> ，所以导致了计算结果比预期少了1。</p>
<h2 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h2><ul>
<li>volatile告诉jvm每次从主存中取值，<strong>非阻塞</strong>；synchronized加锁，只有当前线程可以访问，<strong>阻塞</strong></li>
<li>volatile只能变量级，synchronized可以变量和方法</li>
<li>volatile不保证原子性，synchronized保证原子性</li>
</ul>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="简述一下"><a href="#简述一下" class="headerlink" title="简述一下"></a>简述一下</h3><p><code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>在Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程， 都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要<strong>从用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized 效率低的原因。庆幸的是在<strong>Java 6</strong>之后Java 官方对从JVM层面对synchronized 较大优化，所以现在的synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>synchronized关键字最主要的三种使用方式:</p>
<ul>
<li>普通方法，只对当前实例对象加锁</li>
<li>静态方法，对类的所有对象加锁</li>
<li>方法块<ul>
<li><code>this</code> ：对当前实例对象加锁</li>
<li><code>Classname.class</code>：对类的所有对象加锁</li>
</ul>
</li>
</ul>
<p>具体例子、底层原理看<a target="_blank" rel="noopener" href="https://ifwant.tech/2021/01/19/gbf_2/">这里</a></p>
<h2 id="ArrayList线程不安全"><a href="#ArrayList线程不安全" class="headerlink" title="ArrayList线程不安全"></a>ArrayList线程不安全</h2><ul>
<li><p>添加元素的add方法不是原子性操作</p>
<p>add方法分成两步：1、加入元素 2、移动标志位</p>
<p>有A、B两条线程，A线程执行到array[flag] = 1后还未移动标志位，此时线程B执行array[flag] = 2;将线程A添加的1覆盖，此后A、B线程相继执行 flag+=1; A、B线程执行完后数组变为array = {2,0,0} 与预期{1，2}不符</p>
</li>
<li><p>数组扩容可能会发生数组越界</p>
<p>在调用add()方法前要先判断数组容量，若数组已满则需要扩容，然后再执行添加操作。假设有A、B两个线程，当A线程要往数组大小为10的Arraylist中添加第10个元素时完成判断不需扩容，正要执行添加操作，B线程执行完成判断不需扩容 接着添加元素，移动标志位 flag = 10;A线程继续执行使用标志位flag = 10，从而产生数组越界的错误</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案：适用Vector类，是线程安全的，方法加了synchronized关键字。</p>
<h2 id="ConcurrentHashMap实现原理"><a href="#ConcurrentHashMap实现原理" class="headerlink" title="ConcurrentHashMap实现原理"></a>ConcurrentHashMap实现原理</h2><p>HashMap和ConcurrentHashMap看<a target="_blank" rel="noopener" href="https://ifwant.tech/2021/01/20/map/">这里</a></p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">AQS</a></h2><p>AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。</p>
<p><strong>AQS的核心思想</strong>：</p>
<ul>
<li>资源空闲，加锁</li>
<li>资源不空闲，线程加入CLH队列中等待</li>
</ul>
<p>CLH队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02201.png"></p>
<p>AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p>
<p><strong>注意：AQS是自旋锁：</strong>在等待唤醒的时候，经常会使用自旋（while(!cas())）的方式，不停地尝试获取锁，直到被其他线程获取成功</p>
<p>AQS 定义了两种资源共享方式：</p>
<ol>
<li>Exclusive：独占，只有一个线程能执行，如ReentrantLock</li>
<li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier</li>
</ol>
<p>ReentrantLock为例，（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。<br>注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。</p>
<h1 id="JUC并发包"><a href="#JUC并发包" class="headerlink" title="JUC并发包"></a>JUC并发包</h1><p>java.util.concurrent</p>
<h2 id="ReentrantLock和synchronized"><a href="#ReentrantLock和synchronized" class="headerlink" title="ReentrantLock和synchronized"></a>ReentrantLock和synchronized</h2><p><code>java.util.concurrent.locks.ReentrantLock</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p><strong>中断</strong>：为了解决死锁问题，可以中断ReentrantLock。使用<code>lockInterruptibly</code>申请锁，这是一个可以对中断进行响应的锁申请动作。</p>
<p><strong>等待</strong>：<code>tryLock(num,TimeUnit.SECONDS)</code>可以实现限时等待锁。超过num秒还没得到锁就返回false</p>
<p><strong>可重入</strong>：一个线程可以多次申请加锁，只要解锁的时候次数与加锁的次数相等即可。</p>
<p><strong>公平锁</strong>：先申请锁的线程先得到锁。构造函数fair可以设定ReentrantLock是公平锁还是非公平锁。</p>
<p><strong>Condition</strong>：用来暂停和唤醒锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockCondition</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Condition condition = lock.newCondition();<span class="comment">//生成与lock绑定的Condition对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock(); </span><br><span class="line">            condition.await ();  <span class="comment">//等待</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Thread is going on&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace () ;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock. unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ReenterLockCondition tl=<span class="keyword">new</span> ReenterLockCondition(); </span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(tl); </span><br><span class="line">        t1.start(); </span><br><span class="line">        Thread.sleep (<span class="number">2000</span>);<span class="comment">//通知线程 t1 继续执行 </span></span><br><span class="line">        lock.lock(); </span><br><span class="line">        condition.signal(); <span class="comment">//唤醒继续执行</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>实现：synchronized由JVM实现，ReentrantLock由JDK实现</li>
<li>可中断：synchronized不可中断，ReentrantLock可中断</li>
<li>公平锁：synchronized非公平锁，ReentrantLock默认非公平，也可以做公平锁。</li>
<li>等待和唤醒：synchronized使用<code>Object.wait()</code>和<code>notify()</code>,ReentrantLock使用<code>Condition.await()</code>和<code>signal()</code>.另外一个ReentrantLock锁可以绑定多个Condition对象</li>
</ul>
<ul>
<li>性能上两者差不多，synchronized做了很多优化</li>
<li>都是可重入锁</li>
</ul>
<h2 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h2><p>synchronized和ReentrantLock同时都只能有一个线程访问一个资源，信号量可以控制多个线程访问一个资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemapDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//控制只有5个线程可以同时访问资源</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semp.acquire(); <span class="comment">//申请获得许可</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">&quot;:done!&quot;</span>);</span><br><span class="line">            semp.release(); <span class="comment">//释放许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总共20个线程,系统会以5个线程一组为单位,依次执行并输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">final</span> SemapDemo demo = <span class="keyword">new</span> SemapDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h2><p>读读之间不阻塞，读写、写写之间阻塞。提升系统效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 13 on 2017/5/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//模拟读操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读操作:&quot;</span> + value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//模拟写操作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;写操作:&quot;</span> + value);</span><br><span class="line">            value = index;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line"></span><br><span class="line">        Runnable readRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//分别使用两种锁来运行,性能差别很直观的就体现出来,使用读写锁后读操作可以并行,节省了大量时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.handleRead(readLock);</span><br><span class="line">                    <span class="comment">//demo.handleRead(lock);</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Runnable writeRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//分别使用两种锁来运行,性能差别很直观的就体现出来</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.handleWrite(writeLock, <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>));</span><br><span class="line">                    <span class="comment">//demo.handleWrite(lock, new Random().nextInt(100));</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(readRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(writeRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="倒计时器CountDownLatch"><a href="#倒计时器CountDownLatch" class="headerlink" title="倒计时器CountDownLatch"></a>倒计时器CountDownLatch</h2><p>用一个整数n初始化，当n个线程执行完后才执行主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);<span class="comment">//10个线程完成才执行主线程</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">3</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;check complete&quot;</span>);</span><br><span class="line">            end.countDown();<span class="comment">//完成一个线程就计数-1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待检查</span></span><br><span class="line">        end.await();</span><br><span class="line">        <span class="comment">//发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Fire!&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环栅栏CyclicBarrier"><a href="#循环栅栏CyclicBarrier" class="headerlink" title="循环栅栏CyclicBarrier"></a>循环栅栏CyclicBarrier</h2><p>和倒计时器的区别在于，可以重复使用，而且可以定义多个线程完成后做一个动作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单版</span></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));<span class="comment">//N个线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">cyclicBarrier.await();<span class="comment">//等待所有线程就绪</span></span><br><span class="line">doWork();</span><br><span class="line">cyclicBarrier.await();<span class="comment">//等待所有线程执行完dowork()</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01221.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by 13 on 2017/5/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String soldier;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CyclicBarrier cyclicBarrier, String soldier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.soldier = soldier;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                doWork();</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">10000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(soldier + <span class="string">&quot;:任务完成&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">            <span class="keyword">this</span>.N = N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;司令:[士兵&quot;</span> + N + <span class="string">&quot;个,任务完成!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;司令:[士兵&quot;</span> + N + <span class="string">&quot;个,集合完毕!&quot;</span>);</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">        Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</span><br><span class="line">        System.out.println(<span class="string">&quot;集合队伍!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;士兵&quot;</span> + i + <span class="string">&quot;报道!&quot;</span>);</span><br><span class="line">            allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclicBarrier, <span class="string">&quot;士兵&quot;</span> + i));</span><br><span class="line">            allSoldier[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>什么是线程池？</strong></p>
<p>就是<strong>线程复用</strong>。创建线程变为从线程池里拿空闲线程，销毁线程变为向线程池里归还线程</p>
<p><strong>为什么要用线程池？</strong></p>
<p>减少资源消耗，提高响应速度（少了创建线程的时间），方便管理</p>
<p><strong>框架</strong></p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01241.png"></p>
<h3 id="四种常用构造方法"><a href="#四种常用构造方法" class="headerlink" title="四种常用构造方法"></a>四种常用构造方法</h3><ul>
<li><p><code>newFixedThreadPool</code>：创建固定线程数量的线程池</p>
</li>
<li><p><code>newSingleThreadExecutor</code>：创建只有一个线程的线程池</p>
</li>
<li><p><code>newCachedThreadPool</code>：创建根据实际情况调整线程数量的线程池</p>
</li>
<li><p><code>newScheduledThreadPool</code>：线程在指定时间执行</p>
<ul>
<li><p><code>scheduleAtFixedRate()</code>：从上次开始到下次开始</p>
</li>
<li><p><code>scheduleWithFixedDelay()</code>从上次结束到下次开始</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01242.png"></p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//newFixedThreadPool</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot; Thread id:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前5个线程执行时间和后5个比差了1秒钟</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scheduleAtFixedRate</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorServiceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService es = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        es.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法的内部实现"><a href="#构造方法的内部实现" class="headerlink" title="构造方法的内部实现"></a>构造方法的内部实现</h3><p>前三种方法<code>newFixedThreadPool</code>，<code>newSingleThreadExecutor</code>，<code>newCachedThreadPool</code>都是由<code>ThreadPoolExcutor</code>构造函数的不同参数来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>corePoolSize:线程池维护线程的最少数量</li>
<li>maximumPoolSize:线程池维护线程的最大数量</li>
<li>keepAliveTime:超过corePoolSize的空闲线程的存活时间</li>
<li>unit:线程池维护线程所允许的空闲时间的单位</li>
<li><strong>workQueue</strong>:线程池所使用的缓冲队列</li>
<li><strong>handler</strong>:线程池对拒绝任务的处理策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于newFixedThreadPool采用了LinkedBlockingQueue，这是无界队列，所以实际线程队列永远维持在nThreads，所以maximumPoolSize和keepAliveTime无效。</p>
<p>由于newCachedThreadPool采用了SynchronousQueue，这个阻塞队列没有存储空间，一有请求就使用空闲线程或申请新的线程执行任务</p>
<h3 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h3><p>四种：直接提交，有界，无界，优先</p>
<ul>
<li>直接提交队列：<code>SynchronousQueue</code>，有空闲线程就直接提交，没有就创建新线程，超过上限就拒绝</li>
<li>有界任务队列：<code>ArrayBlockingQueue</code>,有一个参数<code>capacity</code>表示队列长度。有新的任务时<ul>
<li>实际运行的线程数小于corePoolSize时，直接创建新线程</li>
<li>大于corePoolSize但小于corePoolSize+capacity时，加入等待队列</li>
<li>大于corePoolSize+capacity但小于maximumPoolSize时，直接创建新线程</li>
<li>大于maximumPoolSize时，拒绝</li>
</ul>
</li>
<li>无界任务队列：<code>LinkedBlockingQueue</code>,超过corePoolSize的线程全部进队列等待</li>
<li>优先任务队列：<code>PriorityBlockingQueue</code>：特殊的无界队列,有优先级。</li>
</ul>
<h3 id="线程池增长策略（任务调度）"><a href="#线程池增长策略（任务调度）" class="headerlink" title="线程池增长策略（任务调度）"></a>线程池增长策略（任务调度）</h3><ul>
<li>实际运行的线程数小于corePoolSize时，直接创建新线程</li>
<li>大于corePoolSize但workQueue未满时，加入等待队列</li>
<li>大于workQueue已满但小于maximumPoolSize时，直接创建新线程</li>
<li>大于maximumPoolSize时，拒绝</li>
</ul>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ul>
<li>AbortPolicy：抛出异常，丢弃任务</li>
<li>CallerRunsPolicy：不想放弃但也没资源，就使用调用该excute的线程来执行，性能会下降</li>
<li>DiscardOldestPolicy：删除workQueue队列头的任务，再重试执行任务</li>
<li>DiscardPolicy：不抛出异常，丢弃任务</li>
</ul>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>HashMap线程不安全，解决方案：</p>
<ul>
<li><p>使用Collections.synchronizedMap()方法包装HashMap，效率不高，不适合高并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m=Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure></li>
<li><p>使用ConcurrentHashMap，参考<a target="_blank" rel="noopener" href="https://ifwant.tech/2021/01/20/map/">这里</a></p>
</li>
</ul>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>适用读多写少的情况</p>
<p>写的时候，先复制一份副本，修改副本完成后再替换原有数据。这样写操作就不会阻塞读操作。</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>高并发下性能最好的队列</p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue是一个接口，主要有四种实现，参见上一节的BlockingQueue阻塞队列</p>
<p>队列末尾压入元素put()，如果队列已满，会等待；队列头取出元素take()，如果队为空，会等待</p>
<p>例如take()，对于线程而言，如果队列为空，该线程就会等待在notEmpty上，当有新的元素入队的时候，会通知notEmpty的所有线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的字段</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; </span><br><span class="line">    lock.lockInterruptibly(); </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count =- <span class="number">0</span>)</span><br><span class="line">            notEmpty.await(); </span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素来了激活</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span></span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>跳表</p>
<ul>
<li>分层，最底层链表维护了所有元素</li>
<li>上一层是下一层的子集</li>
<li>链表的元素是<strong>排序的</strong></li>
<li>查找时，从顶层链表开始查起，发现大于当前值就去下一层查找</li>
<li>查找时间复杂度是logN</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01243.png"></p>
<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer,Integer&gt;map = <span class="keyword">new</span> ConcurrentSkipListMap&lt;Integer,Integer&gt;(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++) &#123;</span><br><span class="line">    map.put(i,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt;entry:map.entryset())&#123;</span><br><span class="line">System.out.println(entry.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h1><h2 id="提高锁性能的建议"><a href="#提高锁性能的建议" class="headerlink" title="提高锁性能的建议"></a>提高锁性能的建议</h2><ol>
<li>减少锁的持有时间</li>
<li>减少锁粒度(只对需要的一部分进行加锁)，相对是锁的粗化。</li>
<li>读写分离锁(读和读之间不阻塞)</li>
<li>jvm对锁的优化(这是synchronized优化)</li>
</ol>
<p>ConcurrentHashMap里每个Segment分别加锁就是减少锁粒度。缺点是对于全局操作，资源消耗会很大，因为要给所有段加锁，如size()函数。</p>
<p>锁分离的一个例子是<code>LinkedBlockingQueue</code>，take()函数操作的是队头，put操作的是队尾，因此可以两把锁分别给这两个函数，实现读数据和写数据不冲突。</p>
<p>锁粗化的一个例子是把锁加在循环外而非循环内，这样就不用重复地加锁和释放锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jvm虚拟机对锁的优化"><a href="#jvm虚拟机对锁的优化" class="headerlink" title="jvm虚拟机对锁的优化"></a>jvm虚拟机对锁的优化</h2><ul>
<li><strong>偏向锁</strong>:第一个线程请求锁并拿到锁之后，下次再请求锁不需要进行同步操作，直接拿到锁。当有第二个线程竞争的时候，偏向锁失效。</li>
<li><strong>轻量级锁</strong>:偏向锁失效后，使用轻量级锁。将对象头部作为指针，指向持有锁的线程堆栈内部，如果成功就获得轻量级锁，如果失败升级为自旋锁。</li>
<li><strong>自旋锁</strong>:轻量级锁失效之后，java 虚拟机会假设在不久的时间内，可以拿到锁。所以让线程进行几个空循环，如果可以拿到锁则进入临界区，否则阻塞等待锁。</li>
<li><strong>锁消除</strong>:去除不可能存在共享资源竞争的锁。节省不必要的锁请求的时间。</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>ThreadLocal是线程的变量副本，每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，每个线程隔离。</p>
<p>ThreadLocal一般设为static，这样所有线程都共用一个实例，get的时候通过这个ThreadLocal实例计算hash，然后到当前线程的ThreadLocalMap里去找key，找到后返回value。</p>
<ul>
<li><p>每个线程有一个ThreadLocalMap,存储的是entry类型的数组。</p>
</li>
<li><p>entry变量的key是ThreadLocal实例，但是是弱引用。</p>
</li>
<li><p>从整体来看，代码里只有一个ThreadLocal变量t1，但是对于每个线程来说，执行t1.get()函数获取到的value是不一样的，这样就实现了t1变量在不同线程里的隔离</p>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03032.png"></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyy-MM-dd HH:mm;ss&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i=i;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">            Date t=sdf.parse(<span class="string">&quot;2015-03-29 19:29:&quot;</span>+i%<span class="number">60</span>); </span><br><span class="line">            System.out.println(i+<span class="string">&quot;:&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService es=Executors.newFixedThreadPool(<span class="number">10</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123; </span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序是把String类型的时间转成Date类型的时间。由于parse()函数不是线程安全，所以会报错。</p>
<p>使用ThreadLocal为每一个线程都产生一个 SimpleDateformat 对象实例解决线程安全问题。ThreadLocal相当于一个容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();<span class="comment">//相当于创建了容器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ParseDate</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">this</span>.i=i;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(t1.get()==<span class="keyword">null</span>)&#123;</span><br><span class="line">                t1.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<span class="comment">//为每个线程创建一个SimpleDateFormat对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            Date t =t1.get().parse(<span class="string">&quot;2015-03-29 19:29:&quot;</span>+i%<span class="number">60</span>);<span class="comment">//调用自己的parse函数，每个线程只访问自己的对象</span></span><br><span class="line">            System.out.println(i+<span class="string">&quot;:&quot;</span>+t);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            es.execute(<span class="keyword">new</span> ParseDate(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set函数"><a href="#set函数" class="headerlink" title="set函数"></a>set函数</h3><p>计算hash，如果key不相等说明冲突了，检查下一个</p>
<h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><p>同上</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>如果指向ThreadLocal实例的强引用消失了，那么GC会回收实例，导致ThreadLocalMap就会存在key为null，但value不为null的Entry。</p>
<p>每次使用完线程使用<code>remove</code>函数可以清除所有键值对，帮助解决内存泄漏。</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="CAS比较交换"><a href="#CAS比较交换" class="headerlink" title="CAS比较交换"></a>CAS比较交换</h3><ul>
<li>天生免疫死锁，没有锁竞争和线程切换的开销</li>
<li>CAS(V,E,N)，V表示要更新的变量，E表示预期值，N表示新值，当V=E时，才会将V值设为N，如果不相等则该线程被告知失败，可以再次尝试</li>
<li>硬件层面现代处理器已经支持原子化的CAS指令</li>
</ul>
<h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><ul>
<li>atomic包中实现了直接使用CAS的线程安全类型</li>
<li>AtomicInteger与Integer的区别是它是可变的，也是线程安全的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AtomicInteger使用示例</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10000</span>;k++)&#123;</span><br><span class="line">                i.incrementAndGet();<span class="comment">//CAS操作，给自己+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread []ts = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            ts[k] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            ts[k].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            ts[k].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>incrementAndGet()</code>实现原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;  <span class="comment">//死循环就是CAS的失败不断重新尝试</span></span><br><span class="line">        <span class="keyword">int</span> current = get (); </span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current,next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>一个类只产生一个实例对象</p>
<p>好处</p>
<ul>
<li>减少new花费的时间</li>
<li>减轻GC的压力 </li>
</ul>
<p>写法</p>
<ul>
<li>构造函数设为private</li>
<li>在本类中（<strong>饿汉式</strong>）或方法中（<strong>懒汉式</strong>）创建一个本类对象（private static）</li>
<li>写一个公有静态方法（publiac static）返回创建的对象</li>
</ul>
<p>饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton is created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LazySingleton is created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//多线程下需要加锁实现同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();<span class="comment">//方法内创建，方法调用时对象才会创建</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内部类结合懒汉式和饿汉式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticSingleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">staticSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.put.printline&#123;<span class="string">&quot;staticSingleton is created.&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">innerClassHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> staticSingleton instance=<span class="keyword">new</span> staticSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> staticSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerClassHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生产者消费者的实现"><a href="#生产者消费者的实现" class="headerlink" title="生产者消费者的实现"></a>生产者消费者的实现</h2><p>五种实现方式，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/xindoo/article/details/80004003">这里</a></p>
<ul>
<li>用synchronized对存储加锁，然后用object原生的wait() 和 notify()做同步。</li>
<li>用concurrent.locks.Lock，然后用condition的await() 和signal()做同步。</li>
<li>直接使用concurrent.BlockingQueue。</li>
<li>使用PipedInputStream/PipedOutputStream。</li>
<li>使用信号量semaphore。</li>
</ul>
<p><strong>synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEN = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            producer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == MAX_LEN) &#123;</span><br><span class="line">                        queue.notify();</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前队列满&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    queue.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产一条任务，当前队列长度为&quot;</span> + queue.size());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consumer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        queue.notify();</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前队列为空&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.notify();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者消费一条任务，当前队列长度为&quot;</span> + queue.size());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumer pc = <span class="keyword">new</span> ProducerAndConsumer();</span><br><span class="line">        Producer producer = pc.<span class="function">new <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        Consumer consumer = pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>concurrent.locks.Lock</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * version 1 doesn&#x27;t use synchronized to improve performance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEN = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            producer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == MAX_LEN) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前队列满&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            condition.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产一条任务，当前队列长度为&quot;</span> + queue.size());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consumer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前队列为空&quot;</span>);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            condition.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者消费一条任务，当前队列长度为&quot;</span> + queue.size());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumer pc = <span class="keyword">new</span> ProducerAndConsumer();</span><br><span class="line">        Producer producer = pc.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        Consumer consumer = pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BlockingQueue</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            producer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者生产一条任务，当前队列长度为&quot;</span> + queue.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>)+<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            consumer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者消费一条任务，当前队列长度为&quot;</span> + queue.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>)+<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerAndConsumer pc = <span class="keyword">new</span> ProducerAndConsumer();</span><br><span class="line">        Producer producer = pc.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span></span>;</span><br><span class="line">        Consumer consumer = pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span></span>;</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程交替打印1212…"><a href="#多线程交替打印1212…" class="headerlink" title="多线程交替打印1212…"></a>多线程交替打印1212…</h2><p>需要创建一个Object对象，然后用synchronized给这个对象加锁。</p>
<p>notify()会激活等待的线程，wait()会释放锁。</p>
<ul>
<li>线程1先加锁，再激活等待线程（第一次没有等待线程），然后wait()释放锁，线程1休眠等待</li>
<li>线程2先加锁，再激活等待线程（线程1），然后wait()释放锁，线程2休眠等待</li>
<li>线程1被激活且获得锁，打印1，释放锁（synchronized块结束），再加锁，激活等待线程（线程2），然后wait()释放锁，线程1休眠等待</li>
<li>线程2被激活且获得锁，打印2，释放锁（synchronized块结束），再加锁，激活等待线程（线程1），然后wait()释放锁，线程2休眠等待</li>
<li>……</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line">        <span class="keyword">private</span> Object o;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Mythread</span><span class="params">(<span class="keyword">int</span> idxnew,Object onew)</span></span>&#123;</span><br><span class="line">            idx=idxnew;</span><br><span class="line">            o=onew;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                    o.notify();</span><br><span class="line">                    o.wait();</span><br><span class="line">                    System.out.println(idx);</span><br><span class="line">                    <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        o.notify();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Object o=<span class="keyword">new</span> Object();</span><br><span class="line">        Thread th1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread(<span class="number">1</span>,o));</span><br><span class="line">        th1.start();</span><br><span class="line">        th1.sleep(<span class="number">10</span>);<span class="comment">//保证先打印1</span></span><br><span class="line">        Thread th2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread(<span class="number">2</span>,o));</span><br><span class="line">        th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池参数设置"><a href="#线程池参数设置" class="headerlink" title="线程池参数设置"></a>线程池参数设置</h2><p>CPU密集型：N+1</p>
<p>IO密集型：2*N</p>
<p>线程等待时间为w，线程CPU计算时间为c，CPU核心数为n，则线程池大小应设为：(w+c)/c *n 才能达到100%CPU使用率。</p>
<p>对于CPU密集型，w=0，+1是为了如果有线程停下可以快速补上；</p>
<p>对于IO密集型，c=0，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/24/gbf_1/" data-id="ckw9lh00d002r2ww5a9zmal45" data-title="Java高并发程序设计" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-jvm_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/19/jvm_1/" class="article-date">
  <time class="dt-published" datetime="2020-12-19T07:09:39.000Z" itemprop="datePublished">2020-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/19/jvm_1/">深入理解JAVA虚拟机</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>知识结构</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/jvm.jpg"></p>
<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>JVM内存空间：</p>
<ul>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/jvm-memory-structure.jpg" alt="JVM内存结构"></p>
<p>记忆方法：java程序由两部分组成：<strong>对象</strong>和<strong>方法</strong>。</p>
<ul>
<li>对象存在<strong>堆</strong>中</li>
<li>方法存在<strong>栈</strong>中<ul>
<li><strong>一般的方法</strong>存在<strong>jvm栈</strong>中</li>
<li><strong>本地方法</strong>存在<strong>本地方法栈</strong>中。</li>
</ul>
</li>
<li>另外还有<strong>静态变量</strong>和<strong>常量</strong>，存在<strong>方法区</strong>中。</li>
<li>程序运行起来怎么知道运行到哪了呢，用<strong>程序计数器</strong>。</li>
</ul>
<p> JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区（Metaspace）取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。 </p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>记录当前线程正在执行的那条字节码指令的地址 </p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>
<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>是一块较小的内存空间。</li>
<li>线程私有，每条线程都有自己的程序计数器。</li>
<li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li>
<li><strong>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</strong></li>
</ul>
<h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p> 描述 Java 方法运行过程的内存模型 </p>
<p>Jvm栈为每个运行的java方法创建栈帧，存放信息：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息</li>
<li>……</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/jvm-stack.jpg" alt="stack"></p>
<h3 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h3><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p>
<p>栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>
<p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>局部变量表大小编译时确定，不会改变</li>
<li>栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul>
<li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。（递归容易导致stackoverflow问题）</li>
<li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li>
</ul>
</li>
<li>线程私有</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法是指java以外的语言写的方法，本地方法保存在动态链接库中。</p>
<p> 描述本地方法运行过程的内存模型 ，几乎所有的对象都存储在堆中。 </p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>存放对象实例和数组</p>
<h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>线程共享，需要注意同步问题 </li>
<li>垃圾回收的主要场所</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>堆的一个逻辑部分，存放：</p>
<ul>
<li>已经被虚拟机加载的类信息</li>
<li>常量</li>
<li>静态变量</li>
<li>即时编译器编译后的代码</li>
</ul>
<h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul>
<li>线程共享</li>
<li>JDK8使用元空间（Metaspace）代替永久代来实现方法区</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池</strong>是方法区的一部分， 常量就存放在运行时常量池中 </p>
<p><strong>常量池</strong>是.class文件的一部分代码，记录了字面量和符号引用</p>
<p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。 </p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p> 除 Java 虚拟机之外的内存 </p>
<p> 在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。 </p>
<h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p> HotSpot 虚拟机中分为三块区域：</p>
<ul>
<li>对象头（Header）</li>
<li>实例数据（Instance Data）</li>
<li>对齐填充（Padding）</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/object-memory-layout.png" alt="内存布局"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>记录了对象在运行过程中所需要使用的一些数据：</p>
<ul>
<li>哈希码</li>
<li>GC 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程 ID</li>
<li>偏向时间戳</li>
</ul>
<p>对象头可能包含类型指针，通过该指针能确定对象属于哪个类。</p>
<p>如果对象是一个数组，那么对象头还会包括数组长度。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p> 成员变量的值，其中包括父类成员变量和本类成员变量 </p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p> 确保对象的总长度为 8 字节的整数倍 </p>
<p> 对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。 </p>
<h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><h3 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h3><p>jvm遇到new指令-&gt; 检查常量池中是否有这个类的符号引用 、 符号引用所代表的类是否已被加载、解析和初始化过 </p>
<h3 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="headerlink" title="为新生对象分配内存"></a>为新生对象分配内存</h3><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03141.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f1e5e03ed2f8"><strong>栈上分配</strong></a></p>
<p>如果对象不会超出方法的使用范围（逃逸分析），则可以分配栈上内存，随着栈帧的销毁而回收内存。这样可以减少gc负担。</p>
<p><strong>TLAB</strong></p>
<p>当多线程在堆上分配内存时，需要同步，会导致效率差</p>
<p>给每个线程划分私有的堆空间，分配内存时先分配到自己那块空间，减少同步，提升效率。</p>
<p> 对象所需内存的大小在类加载完成后便可完全确定 ， 从堆中划分一块对应大小的内存空间给新的对象 。</p>
<ul>
<li><p><strong>指针碰撞</strong><br>堆中内存规整，移动指针</p>
<p>说明采用的是“<strong>标记-复制算法</strong>”或“<strong>标记-整理算法</strong>”，空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离。</p>
</li>
<li><p><strong>空闲列表</strong><br>堆中内存不规整，从空闲列表中找内存分配</p>
<p>已使用的内存和空闲内存交错（说明采用的是<strong>标记-清除算法</strong>，有碎片）， VM 维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。</p>
</li>
</ul>
<p>对象创建时的线程安全问题：</p>
<ul>
<li>CAS配上失败重试</li>
<li>本地线程分配缓冲：每个线程预留一块内存</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p> 为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。 </p>
<h2 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h2><p>堆中放对象，栈里放对象引用，引用访问对象的方式有两种：</p>
<h3 id="句柄访问方式"><a href="#句柄访问方式" class="headerlink" title="句柄访问方式"></a>句柄访问方式</h3><p>对象引用-&gt;句柄池-&gt;实例数据和类型数据</p>
<p>更安全，对象移动，引用不变</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/handle-access.jpg" alt="句柄方式"></p>
<h3 id="直接指针访问方式"><a href="#直接指针访问方式" class="headerlink" title="直接指针访问方式"></a>直接指针访问方式</h3><p>对象引用-&gt;实例数据（含类型数据指针）-&gt;类型数据</p>
<p>更快</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/direct-pointer.jpg" alt="直接指针访问"></p>
<h1 id="垃圾收集策略与算法"><a href="#垃圾收集策略与算法" class="headerlink" title="垃圾收集策略与算法"></a>垃圾收集策略与算法</h1><p>程序计数器、虚拟机栈、本地方法栈：线程私有，内存分配和回收有确定性，无需过多考虑垃圾回收；</p>
<p>堆、方法区：动态分配内存和回收，垃圾收集器重点关注这块。</p>
<h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p>一个对象不被任何对象或变量引用，则为无效对象，需要被回收。</p>
<p>JAVA主要用的可达性分析算法</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p> 在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了。 </p>
<p>简单，但很难解决对象间相互循环引用问题。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象（图论中的不可到达）就是无效对象。</p>
<p>GC Roots 是指：</p>
<ul>
<li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈中引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
</ul>
<p>GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/12544c0ad5c1">三色标记</a>：</p>
<p>(1) 黑色子节点已被访问</p>
<p>(2) 灰色当前节点访问了但是子节点没被访问</p>
<p>(3) 白色没被访问。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>可达性分析认为不可达后：</p>
<ul>
<li>没有finalize或者已经调用过一次，对象被回收</li>
<li>执行finalize，对象放入一个队列中，虚拟机以较低的优先级执行这些 finalize()方法。对象在队列中被执行前如果被附加引用，则重生；否则被回收。</li>
</ul>
<h2 id="引用的种类"><a href="#引用的种类" class="headerlink" title="引用的种类"></a>引用的种类</h2><p>强软弱虚</p>
<h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>引用赋值，类似“ Object obj = new Object()” </p>
<p>有强引用，GC就不会回收被引用对象</p>
<p>如果错误地保持了强引用，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>当JVM认为内存不足时，才会回收软引用的对象。</p>
<p>软引用对象都被清理了，内存仍不足，才会抛出OOM。</p>
<p>常用来实现内存敏感的缓存，有内存空闲就不清理，内存不足才清理。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>生存周期到下一次垃圾回收之前。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>完全不影响对象生存时间，仅仅是用来在对象被回收时，通知你它被回收了。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>清除、复制（新生代）、整理（老年代）</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>过程：</p>
<ul>
<li>标记：GC Roots遍历，标记存活（可达）对象</li>
<li>清除：遍历堆，清除未被标记的对象</li>
<li>或者反过来，标记非存活对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>效率问题：对象越多越耗时</li>
<li>空间问题：内存碎片化，清除后产生大量不连续内存碎片</li>
</ul>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>内存等分为两块，每次使用一块，GC时将存活者复制到另一块内存上，清空原来内存。</p>
<ul>
<li>优点：没有内存碎片化问题</li>
<li>缺点：浪费空间</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wy5612087/article/details/52369677">优化</a>：</p>
<ul>
<li>内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。 <ul>
<li> <a target="_blank" rel="noopener" href="https://blog.csdn.net/antony9118/article/details/51425581">为什么要Survivor区</a>：避免一次Minor GC后对象直接从Eden进入老年代，从而避免过度的Full GC，使用Survivor后只有存活16次的才移到老年代</li>
<li> 为什么要两个：如果只有一个，每次次Minor GC后，Survivor区也会回收一部分，被回收的地方就变成了内存碎片，使用率大幅度降低</li>
</ul>
</li>
<li> 分配担保：Survivor没有足够空间存放上一次新生代收集下来的存活对象，这些对象直接进入老年代</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>过程：</p>
<ul>
<li>标记：遍历GC Roots，标记存活</li>
<li>整理：移动存活对象到一起，清除末端内存地址以后的内存</li>
</ul>
<p>缺点：需要暂停应用程序，大量对象移动导致长时间停顿</p>
<p>对于老年代，关注延迟（内存回收）用清除算法，关注吞吐量（内存分配）用整理算法</p>
<h1 id="HotSpot-垃圾收集器"><a href="#HotSpot-垃圾收集器" class="headerlink" title="HotSpot 垃圾收集器"></a>HotSpot 垃圾收集器</h1><p>七种，前三种新生代，后三种老生代，G1通用：</p>
<ul>
<li>Serial（复制）</li>
<li>PalNew（复制）</li>
<li>Parallel Scavenge（复制）</li>
<li><strong>G1</strong>（整理、复制）</li>
<li><strong>CMS</strong>（清除）</li>
<li>Serial Old（整理）</li>
<li>Parallel Old（整理）</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/gc.png" alt="垃圾收集器"></p>
<h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>只开启一条 GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程 </p>
<p>适合客户端（内存小，创建对象少，回收时间短）</p>
<h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p> Serial 的多线程版本,只能和CMS配合使用</p>
<p>追求降低停顿时间，适合交互式应用</p>
<h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>多线程</p>
<p>追求提升吞吐量，适合没有交互的后台</p>
<p>吞吐量=用户代码时间/（用户代码时间+GC时间）</p>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。 </p>
<ul>
<li>初始标记：Stop The World<ul>
<li>仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记</li>
<li>修改TAMS 指针的值，让下一阶段用户线程并发运行时新分配的对象，都在指针地址之上（即默认为存活不回收）</li>
</ul>
</li>
<li>并发标记：并发执行，进行可达性分析，速度很慢。</li>
<li>最终标记：Stop The World，处理并发标记阶段更新的对象引用关系。</li>
<li>筛选回收：Stop The World，回收无效对象，选择价值最高的Region，复制移动Region。</li>
</ul>
<p>对于Region之间的对象引用问题，使用记忆集来解决。每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01301.png"></p>
<p>缺点：</p>
<ul>
<li>内存占用更多（如每个Region都有记忆集）</li>
<li>额外负载</li>
</ul>
<p><strong>G1和CMS的区别</strong>：</p>
<ul>
<li>G1清理过程可以设置停顿时间，时间长就多回收一些Region，时间短就少些；CMS时间不可控。</li>
<li>G1只有并发标记是并发的，其他<strong>3</strong>个阶段都要停顿；CMS并发标记和并发清除并发，另<strong>2</strong>个阶段停顿。</li>
<li>CMS只用于老年代，G1全都可以</li>
<li>G1基于标记整理和标记复制；CMS基于标记清除</li>
</ul>
<h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>使用标记清除，追求最短停顿时间，用户线程和GC线程并发。</p>
<ul>
<li>初始标记：Stop The World，仅使用<strong>一条</strong>初始标记线程对所有与 GC Roots <strong>直接关联</strong>的对象进行标记，速度快。</li>
<li>并发标记：使用<strong>多条</strong>标记线程，与用户线程并发执行。此过程进行可达性分析，遍历标记出所有废弃对象。速度很慢。</li>
<li>重新标记：Stop The World，修正上一步，并发标记过程中，本来不可达的对象由于新的引用变得可达了，这种对象标记出来不回收，速度较快。</li>
<li>并发清除：只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/CMS.png" alt="CMS"></p>
<p>缺点：</p>
<ul>
<li>吞吐量低（并发占用线程，应用程序变慢）</li>
<li>无法处理浮动垃圾（并发标记过程中新出现的无效对象，包括本来可达变不可达）</li>
<li>标记-清除产生内存碎片化问题</li>
</ul>
<h2 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h2><p> Serial 的老年代版本 ,使用标记-整理算法</p>
<h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p> Parallel Scavenge 的老年代版本 ，追求吞吐量</p>
<h2 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h2><p>特点：</p>
<ul>
<li>停顿时间短，不超过10ms</li>
<li>停顿时间不随着堆的增大而增大</li>
</ul>
<p>原理：</p>
<ul>
<li><p>染色指针：m0,m1,remapped</p>
<p>ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。</p>
</li>
<li><p>读屏障</p>
<p>当应用线程从堆中读取对象引用时,如果发现对象引用不是最新的，读屏障会去获取最新的地址</p>
</li>
<li><p>page更灵活</p>
<p>和G1一样分区，但是不固定大小，更灵活</p>
</li>
</ul>
<p>一开始都是remapped视图</p>
<p>标记过程中，被访问过或被标记过，则转换到m0视图，即表示该对象存活。</p>
<p>并发转移时，如果被转移或被访问，则转换到remapped视图，即表示该对象</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>并发与并行的区别：</p>
<ul>
<li>并发是两个队列<strong>交替</strong>使用一台咖啡机</li>
<li>并行是两个队列<strong>同时</strong>使用两台咖啡机 </li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/bingfa.jpg" alt="并发与并行"></p>
<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>对象内存主要分配在新生代的Eden区，少数情况直接分配在老年代，具体规则取决于垃圾收集器。</p>
<h2 id="对象优先在-Eden-分配"><a href="#对象优先在-Eden-分配" class="headerlink" title="对象优先在 Eden 分配"></a>对象优先在 Eden 分配</h2><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<ul>
<li>Minor GC：回收新生代</li>
<li>Major GC：回收老年代</li>
<li>Full GC：回收整个堆</li>
</ul>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p> 大对象是指需要大量连续内存空间的 Java 对象，如很长的字符串或元素数量庞大的数组。 </p>
<p> 一个大对象能够存入 Eden 区的概率比较小，发生分配担保的概率比较大，而分配担保需要涉及大量的复制，就会造成效率低下。 </p>
<p> 虚拟机提供了一个 -XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。（新生代采用复制算法回收垃圾） </p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p> JVM 给每个对象定义了一个<strong>对象年龄计数器</strong>。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。 </p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果在Survivor空间中<strong>相同年龄所有对象</strong>的大小总和&gt;Survivor空间的一半，年龄&gt;=该年龄的对象就可以直接进入老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>为防止Survivor空间不够Minor GC时的复制操作，老年代预留空间做担保。</p>
<ul>
<li>JDK6之前：<ul>
<li>检查老年代最大可用连续空间是否大于新生代所有对象总空间：大于则Minor GC,否则下一步</li>
<li>检查 HandlePromotionFailure 值是否允许担保失败<ul>
<li>允许： 检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小 ：大于则Minor GC（有风险），否则Full GC</li>
<li>不允许：Full GC</li>
</ul>
</li>
</ul>
</li>
<li>JDK6之后：<ul>
<li>抛弃HandlePromotionFailure 值， 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。 </li>
</ul>
</li>
</ul>
<h2 id="JVM触发Full-GC的情况"><a href="#JVM触发Full-GC的情况" class="headerlink" title="JVM触发Full GC的情况"></a>JVM触发Full GC的情况</h2><ul>
<li> System.gc() 方法的调用 ：建议但不一定会 Full GC </li>
<li> 老年代空间不足</li>
<li> 永久代空间不足</li>
<li> CMS GC时有新的对象放入老年代，老年代空间不足</li>
<li> 统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间 </li>
</ul>
<h1 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>查看正在运行的虚拟机进程，显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（LVMID，Local Virtual Machine Identifier）</p>
<p>参数：</p>
<ul>
<li><code>-l</code> 输出主类全名</li>
</ul>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>监视虚拟机各种运行状态信息，主要三类信息：类加载、垃圾收集、运行期编译状况</p>
<p><code>jstat -option VMID 间隔时间（ms） 次数</code></p>
<p>参数：</p>
<ul>
<li><p><code>-gc</code> 监视java堆状况，Eden区、Survivor区（S0,S1）、老年代等的容量，已用空间，垃圾收集时间等信息</p>
</li>
<li><p><code>-class</code> 监视类加载相关信息</p>
</li>
<li><p><code>-compiler</code> 编译统计</p>
</li>
</ul>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>实时查看和调整虚拟机各项参数</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>生成堆转储快照、查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等</p>
<p>先运行这句</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure>

<p>新版的Linux系统加入了 ptrace-scope 机制. 这种机制为了防止用户访问当前正在运行的进程的内存和状态, 而一些调试软件本身就是利用 ptrace 来进行获取某进程的内存状态的(包括GDB),所以在新版本的Linux系统, 默认情况下不允许 </p>
<p><code>jmap [ option ] vmid</code></p>
<p>参数：</p>
<ul>
<li><code>-heap</code> 查看堆的详细信息</li>
<li><code>-dump</code> 生成java堆转储快照，格式：<code>jmap -dump:[live,]format=b,file=&lt;filename&gt; vmid</code></li>
<li><code>-finalizerinfo </code> 查看F-Queue中等待finalizer方法执行的对象</li>
<li><code>-histo</code> 显示堆中对象统计信息，包括类、实例数量、合计容量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo <span class="variable">$pid</span> &gt; /tmp/jmapout/jmap.dmup.histo.`date+%H%M`</span><br><span class="line"><span class="comment">#内存dump</span></span><br></pre></td></tr></table></figure>



<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>生成虚拟机当前时刻的线程快照，通常用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。</p>
<p><code>jstack [ option ] vmid</code></p>
<p>参数：</p>
<ul>
<li><code>-l</code> 显示关于锁的附加信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstack -l <span class="variable">$pid</span> &gt; /tmp/jmapout/jmap.jstack.`date+%H%M`</span><br><span class="line"><span class="comment">#线程dump</span></span><br></pre></td></tr></table></figure>

<h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcmd -l <span class="variable">$pid</span> VM.native_memory detail &gt; /tmp/jmapout/native_memory.`date+%H%M`</span><br><span class="line"><span class="comment">#堆外内存dump</span></span><br></pre></td></tr></table></figure>



<h2 id="OOM-amp-Full-GC"><a href="#OOM-amp-Full-GC" class="headerlink" title="OOM&amp;Full GC"></a>OOM&amp;Full GC</h2><ul>
<li>打印日志</li>
<li>获取dump文件</li>
<li>MAT分析</li>
<li>修改验证</li>
</ul>
<ol>
<li><p>JVM参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20m -Xmx20m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -XX:+HeapDumpOnOutOfMemoryError -XX:+HeapDumpBeforeFullGC -XX:+HeapDumpAfterFullGC -XX:HeapDumpPath=C:\Users\SJTU_116\Desktop\gc</span><br></pre></td></tr></table></figure></li>
<li><p>查看日志</p>
</li>
<li><p>导入hprof文件到MAT中分析</p>
</li>
</ol>
<p>参考这个<a target="_blank" rel="noopener" href="https://www.zhihu.com/zvideo/1407601449760735232">视频</a></p>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>Class 文件是二进制文件 ，有两种数据类型：</p>
<ul>
<li>无符号数： u1、u2、u4、u8 分别代表 1/2/4/8 字节的无符号数 </li>
<li>表： 多个无符号数或者其他表作为数据项构成的复合数据类型 </li>
</ul>
<p>在vim下输入<code>:%!xxd</code>可查看十六进制的Class文件内容。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/class.png" alt="十六进制下class文件内容"></p>
<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p> Class 文件的头 4 个字节， 用来表示这个 Class 文件的类型， 相当于文件后缀名。(cafe babe)</p>
<h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><p>接下来4个字节是版本信息，java只向下兼容。<br>34对应jdk8</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池存放两种类型常量：</p>
<ul>
<li>字面量：java语言中定义的常量，如字符串、final修饰的值</li>
<li>符号引用：定义的各种名字，如类和接口的全限定名、字段的名称和描述符、方法的名字和描述符</li>
</ul>
<p>特点：</p>
<ul>
<li>常量池数量不固定，开头放置一个u2类型的无符号数，记录常量池容量</li>
<li>每个常量都是一个表。第一位是u1标志位，标志常量类型</li>
</ul>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池后的2个字节，用于识别一些类或接口的访问信息，如这个Class是类还是接口、是否是public等</p>
<h2 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h2><ul>
<li> 类索引：u2数据，表示类名</li>
<li> 父类索引：u2数据，表示父类名</li>
<li> 接口索引集合：一组 u2 数据 ，表示实现的接口名</li>
</ul>
<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>存储本类涉及到的成员变量，包括实例变量和类变量，但不包括方法中的局部变量<br>一个成员变量一个字段表<br>不会出现从父类（或接口）中继承而来的字段 </p>
<h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>描述方法的一些信息<br>方法表的属性表集合中有一张 Code 属性表，用于存储当前方法经编译器编译后的字节码指令。 </p>
<h2 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h2><p> 每个属性对应一张属性表 </p>
<h1 id="类加载时机和过程"><a href="#类加载时机和过程" class="headerlink" title="类加载时机和过程"></a>类加载时机和过程</h1><p>类加载：把类加载到内存中的过程</p>
<p>类的生命周期七个：加载、验证、准备、解析、初始化、使用、卸载。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/loadclass.png" alt="类的生命周期"></p>
<p>除了解析以外，其他都要按顺序开始。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><ul>
<li><p>通过类的全限定名来获取类的二进制字节流</p>
</li>
<li><p>将字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
</li>
<li><p>创建一个表示该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p> 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 </p>
<ul>
<li><p>格式验证：字节流是否满足Class文件格式规范</p>
</li>
<li><p>元数据验证：字节码语义分析，符合java语言规范</p>
</li>
<li><p>字节码验证：对方法体验证</p>
</li>
<li><p>符号引用验证：在解析阶段发生</p>
</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为类变量（或称“静态成员变量”）分配内存并设置初始值。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>初始化为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>初始化为123</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p> 将常量池内的符号引用替换为直接引用</p>
<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><p>执行类构造器 <code>&lt;clinit&gt;()</code> 方法 ， <code>&lt;clinit&gt;()</code>  方法是由编译器自动收集类中的所有<strong>类变量的赋值</strong>动作和<strong>静态语句块</strong>（<code>static &#123;&#125;</code> 块）中的语句合并产生的，先执行父类的。</p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>实现“通过一个类的全限定名来获取描述该类的二进制字节流”功能</p>
<h3 id="判断类是否“相等”"><a href="#判断类是否“相等”" class="headerlink" title="判断类是否“相等”"></a>判断类是否“相等”</h3><p>任意一个类，都由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都有一个独立的类名称空间。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必定不相等。 </p>
<p>“相等”：包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。 </p>
<h3 id="加载器种类"><a href="#加载器种类" class="headerlink" title="加载器种类"></a>加载器种类</h3><ul>
<li><p>启动类加载器（Bootstrap ClassLoader）： 负责将存放在 <code> &lt;JAVA_HOME&gt;\lib</code> 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）： 负责加载 <code> &lt;JAVA_HOME&gt;\lib\ext</code> 目录中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）： 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/classloader.png" alt="类加载器双亲委派模型" style="zoom:50%;" />

<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型是描述类加载器之间的层次关系。它要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。（父子关系一般不会以继承的关系实现，而是以组合关系来复用父加载器的代码） </p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。 </p>
<p>在 java.lang.ClassLoader 中的 loadClass() 方法中实现该过程 </p>
<h3 id="ExtClassLoader为什么没有设置parent？"><a href="#ExtClassLoader为什么没有设置parent？" class="headerlink" title="ExtClassLoader为什么没有设置parent？"></a>ExtClassLoader为什么没有设置parent？</h3><p><code>ClassLoader</code>类的<code>getParent()</code>函数可以输出父类加载器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader classLoader = Test.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        System.out.println(classLoader.getParent());</span><br><span class="line">        System.out.println(classLoader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果输出</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@5a61f5df</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>因为BootstrapClassLoader是由c++实现的，所以并不存在一个Java的类，因此会打印出null</p>
<h3 id="为什么要双亲委派模型"><a href="#为什么要双亲委派模型" class="headerlink" title="为什么要双亲委派模型"></a>为什么要双亲委派模型</h3><p>保证基础类仅加载一次，不会让jvm中存在重名的类。</p>
<p>比如String.class，每次加载都委托给父加载器，最终都是BootstrapClassLoader，都保证java核心类都是BootstrapClassLoader加载的，保证了java的安全与稳定性。</p>
<h3 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h3><p>针对java.*开头的类，jvm的实现中已经保证了必须由bootstrp来加载 </p>
<p>但是可以自定义一个类，包名不是java.*，可以放在用户目录下加载。</p>
<h3 id="自己实现ClassLoader"><a href="#自己实现ClassLoader" class="headerlink" title="自己实现ClassLoader"></a>自己实现ClassLoader</h3><p>继承ClassLoader类，重写findClass（String name）方法。</p>
<p>首先看下<code>ClassLoader</code>类的<code>loadClass()</code>的代码:加载类的流程</p>
<ul>
<li>查看是否加载过，加载过就直接返回类</li>
<li>没加载过得话递归往上，让父类类加载器加载，父类为null说明父类就是启动类加载器</li>
<li>如果启动类也无法加载，调用<code>findClass()</code>来加载</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 查看是否已经加载过该类，加载过的类会有缓存，是使用native方法实现的</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//父类不为空则先让父类加载</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//父类是null就是BootstrapClassLoader，使用启动类类加载器加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// 父类类加载器不能加载该类</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果父类未加载该类</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//让当前类加载器加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>自定义加载器并重写<code>findClass()</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于读取.Class文件的路径</span></span><br><span class="line">    <span class="keyword">private</span> String swapPath;</span><br><span class="line">    <span class="comment">//用于标记这些name的类是先由自身加载的</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; useMyClassLoaderLoad;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String swapPath, Set&lt;String&gt; useMyClassLoaderLoad)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.swapPath = swapPath;</span><br><span class="line">        <span class="keyword">this</span>.useMyClassLoaderLoad = useMyClassLoaderLoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span> &amp;&amp; useMyClassLoaderLoad.contains(name))&#123;</span><br><span class="line">            <span class="comment">//特殊的类让我自己加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        <span class="comment">//根据文件系统路径加载class文件，并返回byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = getClassByte(name);</span><br><span class="line">        <span class="comment">//调用ClassLoader提供的方法，将二进制数组转换成Class类的实例</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassByte(String name) &#123;</span><br><span class="line">        String className = name.substring(name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>, name.length()) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(swapPath + className);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">while</span> ((length = fileInputStream.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                byteArrayOutputStream.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到就是启动类无法加载的类或者自己选定的类由findClass函数加载。重写之后就是到.Class所在路径下找到对应的类文件，读取字节流。即“通过一个类的全限定名来获取描述该类的二进制字节流”。</p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个示例类，用于被我们自己的类加载器加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVersion</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前版本是1哦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写个定时任务，一直调用printVersion方法，观察输出，看我们是否替换成功。</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个2s执行一次的定时任务</span></span><br><span class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String swapPath = MyClassLoader.class.getResource(<span class="string">&quot;&quot;</span>).getPath() + <span class="string">&quot;swap/&quot;</span>;</span><br><span class="line">                String className = <span class="string">&quot;com.example.Test&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//每次都实例化一个ClassLoader，这里传入swap路径，和需要特殊加载的类名</span></span><br><span class="line">                MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(swapPath, Sets.newHashSet(className));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//使用自定义的ClassLoader加载类，并调用printVersion方法。</span></span><br><span class="line">                    Object o = myClassLoader.loadClass(className).newInstance();</span><br><span class="line">                    o.getClass().getMethod(<span class="string">&quot;printVersion&quot;</span>).invoke(o);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException |</span><br><span class="line">                        IllegalAccessException |</span><br><span class="line">                        ClassNotFoundException |</span><br><span class="line">                        NoSuchMethodException |</span><br><span class="line">                        InvocationTargetException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>,<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作步骤：</p>
<ol>
<li>先编译下工程，将Test.class拷贝到swap文件夹下。</li>
<li>运行main方法，可观察到控制台一直输出“当前版本是1哦”。</li>
<li>修改Test#pringtVersion方法的源代码，将输出的内容改为”当前版本是2哦”，然后编译工程，将新的Test.class拷贝到swap文件件下，并替换之前的Test.class。</li>
</ol>
<p>输出结果显示没更换前是输出“当前版本是1哦”，更换了以后是输出“当前版本是2哦”</p>
<p>我们在没有重启的情况下，完成了类的热替换。</p>
<p>为什么需要o.getClass().getMethod(“printVersion”).invoke(o);这样通过反射获取method调用，不能先强转成Test，然后test.printVersion()吗</p>
<p>我：因为如果你这么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test = (Test)o;</span><br><span class="line">o.printVersion();</span><br></pre></td></tr></table></figure>

<p>Test.class会隐性的被加载当前类的ClassLoader加载，当前Main方法默认的ClassLoader为AppClassLoader，而不是我们自定义的MyClassLoader。然后会抛出ClassCastException，因为一个类，就算包路径完全一致，但是加载他们的ClassLoader不一样，那么这两个类也会被认为是两个不同的类。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54693308">更多</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/19/jvm_1/" data-id="ckw9lh009002p2ww52hgw58wj" data-title="深入理解JAVA虚拟机" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-jianzhioffer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/10/jianzhioffer/" class="article-date">
  <time class="dt-published" datetime="2020-12-10T07:09:39.000Z" itemprop="datePublished">2020-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/10/jianzhioffer/">剑指Offer刷题笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>JZ1：二维数组中的查找<ul>
<li>左下角开始，遇大右移，遇小上移，直到超过边界都没找到，得false。否则得true。</li>
</ul>
</li>
<li>JZ2：替换空格<ul>
<li>自带函数replace</li>
<li>新建stringbuffer用append()</li>
<li>遍历一遍计数空格,每个空格新长度+2，setLength(),从后往前setCharAt()</li>
</ul>
</li>
<li>JZ3：从尾到头打印链表<ul>
<li>ArrayList.add(0,value)</li>
<li>递归</li>
</ul>
</li>
<li>JZ4：重建二叉树<ul>
<li>递归，前序遍历第一个pre[0]是根节点，在中序遍历中找到pre[0]的位置，对左右分别递归调用函数，可以使用 Arrays.copyOfRange (array,start,end)直接复制数组，左闭右开</li>
</ul>
</li>
<li>JZ5：两个栈实现队列<ul>
<li>出栈：栈2空时，先把栈1转移到栈2，再pop，栈2非空时，直接pop</li>
</ul>
</li>
<li>JZ6：旋转数组的最小数字<ul>
<li>二分法，三种情况讨论</li>
</ul>
</li>
<li>JZ7：斐波那契数列<ul>
<li>当前项是前两项之和</li>
</ul>
</li>
<li>JZ8：跳台阶<ul>
<li>递归</li>
</ul>
</li>
<li>JZ9：变态跳台阶<ul>
<li>递归，f(n)=f(n-1)+f(n-2)+…+f(1)=2*f(n-1)</li>
</ul>
</li>
<li>JZ10：矩形覆盖<ul>
<li>递归，012三种情况单列</li>
</ul>
</li>
<li>JZ11：二进制中1的个数<ul>
<li>n=n&amp;(n-1)可以把二进制数最右边的1置0</li>
</ul>
</li>
<li>JZ12：数值的整次方<ul>
<li>快速幂，时间复杂度logn，指数的二进制形式的1才参与计算</li>
</ul>
</li>
</ul>
<h1 id="JZ13：调整数组顺序使奇数位于偶数前面"><a href="#JZ13：调整数组顺序使奇数位于偶数前面" class="headerlink" title="JZ13：调整数组顺序使奇数位于偶数前面"></a>JZ13：调整数组顺序使奇数位于偶数前面</h1><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变</p>
<p>插入排序思想，使用两个循环。假设前面的已经都是奇数，当前元素：</p>
<ul>
<li><p>如果是偶数，不动；</p>
</li>
<li><p>如果是奇数，与前面的偶数一个个交换。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> tmp=array[j+<span class="number">1</span>];</span><br><span class="line">                        array[j+<span class="number">1</span>]=array[j];</span><br><span class="line">                        array[j]=tmp;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JZ14-链表中倒数第k个结点"><a href="#JZ14-链表中倒数第k个结点" class="headerlink" title="JZ14 链表中倒数第k个结点"></a>JZ14 链表中倒数第k个结点</h1><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p>
<p>快慢双指针：指针p先走k-1步，指针q再开始，两个指针之间的距离是k-1，当p到链表末端，q就是倒数第k个结点。</p>
<p>注意边界情况：</p>
<ul>
<li><p>k&gt;链表长度</p>
</li>
<li><p>k&lt;=0</p>
</li>
<li><p>链表为{}</p>
</li>
</ul>
<p>这三种情况都返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        ListNode q=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            <span class="keyword">if</span>(q==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ15-反转链表"><a href="#JZ15-反转链表" class="headerlink" title="JZ15 反转链表"></a>JZ15 反转链表</h1><p>题目：输入一个链表，反转链表后，输出新链表的表头</p>
<p>用两个指针，p和q分别指向head的前一结点和后一结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode p=<span class="keyword">null</span>;</span><br><span class="line">        ListNode q=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=head.next;</span><br><span class="line">            head.next=p;</span><br><span class="line">            p=head;</span><br><span class="line">            head=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ15.png" alt="图解" style="zoom:50%;" />

<h1 id="JZ16-合并两个排序的链表"><a href="#JZ16-合并两个排序的链表" class="headerlink" title="JZ16 合并两个排序的链表"></a>JZ16 合并两个排序的链表</h1><p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>新建一个结点头head，每次比较list1和list2，把更小的接在head后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode root=head;</span><br><span class="line">        <span class="keyword">while</span>(list1!=<span class="keyword">null</span>&amp;&amp;list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">                head.next=list1;</span><br><span class="line">                head=list1;</span><br><span class="line">                list1=list1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head.next=list2;</span><br><span class="line">                head=list2;</span><br><span class="line">                list2=list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把未结束的链表连接到合并后的链表尾部</span></span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next=list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head.next=list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ17-树的子结构"><a href="#JZ17-树的子结构" class="headerlink" title="JZ17 树的子结构"></a>JZ17 树的子结构</h1><p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>递归思想，使用两个递归：</p>
<ul>
<li><p>第一个递归：当前结点是否等于子结构树的根结点，是则执行第二个递归；否则分别对左节点和右节点递归调用</p>
</li>
<li><p>第二个递归：判断当前结点是否和子结构树的对应结点相等，不相等则返回false，相等则再对左节点和右节点递归调用</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">                result=DoesTree1hasTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                result=HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                result=HasSubtree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">DoesTree1hasTree2</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> DoesTree1hasTree2(root1.left,root2.left)&amp;&amp;DoesTree1hasTree2(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ18-二叉树的镜像"><a href="#JZ18-二叉树的镜像" class="headerlink" title="JZ18 二叉树的镜像"></a>JZ18 二叉树的镜像</h1><p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<p>递归：交换左右结点，分别对左右结点递归调用函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        TreeNode tmp=root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=tmp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用栈，每次把左右结点压入栈中实现前序遍历，避免递归。</p>
<h1 id="JZ19-顺时针打印矩阵"><a href="#JZ19-顺时针打印矩阵" class="headerlink" title="JZ19 顺时针打印矩阵"></a>JZ19 顺时针打印矩阵</h1><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>三个变量row,col,start。注意开闭：</p>
<ul>
<li><p>[start,col)</p>
</li>
<li><p>[start+1,row)</p>
</li>
<li><p>[col-2,start]</p>
</li>
<li><p>[row-2,start)</p>
</li>
</ul>
<p>外层循环当<code>row&gt;start&amp;&amp;col&gt;start</code>时结束</p>
<p>单行的情况，走完第一步就返回</p>
<p>单列的情况，走完第二步就返回</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/shunshizhenjuzheng.png" alt="图解"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&gt;start&amp;&amp;col&gt;start)&#123;</span><br><span class="line">            printMatrixIner(matrix,row,col,start,result);</span><br><span class="line">            row--;</span><br><span class="line">            col--;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMatrixIner</span><span class="params">(<span class="keyword">int</span> [][] matrix,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> start,ArrayList&lt;Integer&gt; result)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;col;i++)&#123;</span><br><span class="line">            result.add(matrix[start][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row-start==<span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//只有一行，打印完直接return</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">            result.add(matrix[i][col-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col-start==<span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//只有一列，打印完直接return</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=col-<span class="number">2</span>;i&gt;=start;i--)&#123;</span><br><span class="line">            result.add(matrix[row-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">2</span>;i&gt;start;i--)&#123;</span><br><span class="line">            result.add(matrix[i][start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ20-包含min函数的栈"><a href="#JZ20-包含min函数的栈" class="headerlink" title="JZ20 包含min函数的栈"></a>JZ20 包含min函数的栈</h1><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p>用两个栈，其中一个栈（stackMin）每次push时压入当前最小值（要么是新元素，要么是stackMin的栈顶元素）。</p>
<ul>
<li>判断栈空：stack.empty()</li>
<li>查看栈顶（不删除）：stack.peek()</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/stackmin.png" alt="stackmin" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackOrin=<span class="keyword">new</span> Stack&lt;Integer&gt; ();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin=<span class="keyword">new</span> Stack&lt;Integer&gt; ();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stackOrin.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackMin.empty()||stackMin.peek()&gt;node)&#123;</span><br><span class="line">            stackMin.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stackMin.push(stackMin.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackOrin.pop();</span><br><span class="line">        stackMin.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackOrin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ21-栈的压入和弹出序列"><a href="#JZ21-栈的压入和弹出序列" class="headerlink" title="JZ21 栈的压入和弹出序列"></a>JZ21 栈的压入和弹出序列</h1><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>一个栈模拟压入过程，不断判断栈顶元素和出栈序列是否相等，相等则出栈，不等则继续压入栈。最后栈为空则返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; myStack=<span class="keyword">new</span> Stack&lt;Integer&gt; ();</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">            myStack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(flag&lt;popA.length&amp;&amp;myStack.peek()==popA[flag])&#123;</span><br><span class="line">                myStack.pop();</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ22-从上往下打印二叉树"><a href="#JZ22-从上往下打印二叉树" class="headerlink" title="JZ22 从上往下打印二叉树"></a>JZ22 从上往下打印二叉树</h1><p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>其实就是实现二叉树层序遍历：队列+前序遍历</p>
<ul>
<li>队列：<code>Queue &lt;TreeNode&gt; myqueue=new LinkedList &lt;TreeNode&gt;();</code></li>
<li>队列加元素：offer()</li>
<li>删队头：poll()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        Queue &lt;TreeNode&gt; myqueue=<span class="keyword">new</span> LinkedList &lt;TreeNode&gt;();</span><br><span class="line">        myqueue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!myqueue.isEmpty())&#123;</span><br><span class="line">            TreeNode tmp=myqueue.poll();</span><br><span class="line">            result.add(tmp.val);</span><br><span class="line">            <span class="keyword">if</span>(tmp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                myqueue.offer(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                myqueue.offer(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ23-二叉搜索树的后序遍历序列"><a href="#JZ23-二叉搜索树的后序遍历序列" class="headerlink" title="JZ23 二叉搜索树的后序遍历序列"></a>JZ23 二叉搜索树的后序遍历序列</h1><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<p>二叉搜索树（BST）</p>
<ul>
<li><p>左子树都比根节点小，右子树都比根节点大。</p>
</li>
<li><p>后序遍历的最后一位是根节点，前面的序列一定可以分成两部分（或者一部分），一部分小于根节点，一部分大于根节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = subProcess(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">subProcess</span><span class="params">(<span class="keyword">int</span> []sequence,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=end-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(sequence[tmp]&gt;sequence[end]&amp;&amp;tmp&gt;start)tmp--;</span><br><span class="line">        <span class="keyword">if</span>(tmp==start)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=tmp;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i]&gt;sequence[end])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subProcess(sequence,start,tmp)&amp;&amp;subProcess(sequence,tmp+<span class="number">1</span>,end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<ul>
<li><p>从最后一位往前遍历，找到比根节点小的数，序号为tmp，再从start遍历到tmp，看是不是都小于根节点，不是就返回false。</p>
</li>
<li><p>如果start&gt;=end，就返回true</p>
</li>
<li><p>分别对小于根节点的序列和大于根节点的序列递归调用函数</p>
</li>
</ul>
<p>注意对于根节点前面的数都比根节点大的情况（只有右子树），此时tmp==start,可以直接返回true</p>
<h1 id="JZ24-二叉树和为某一值的路径"><a href="#JZ24-二叉树和为某一值的路径" class="headerlink" title="JZ24 二叉树和为某一值的路径"></a>JZ24 二叉树和为某一值的路径</h1><p>题目：输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<ul>
<li>递归，用一个<code>ArrayList&lt;Integer&gt;</code>保存测试路径，加上根节点的val等于target，且没有左右节点了就返回，否则对左右子树递归调用。</li>
<li>注意调用结束后要把最后一个节点remove，才能回退到上一个节点状态。</li>
<li>result添加时要新建一个新的<code>ArrayList&lt;Integer&gt;</code>，这样才不会因为后续path的更新而受到影响。</li>
<li>对于字典排序，原始的剑指offer并没有这个要求，排序可以重写<code>Collections.sort</code>的<code>compare</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result =<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        help(root,target);</span><br><span class="line">        Collections.sort(result,<span class="keyword">new</span> Comparator&lt;ArrayList&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ArrayList&lt;Integer&gt; o1, ArrayList&lt;Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 返回值为int类型，大于0表示正序，小于0表示逆序</span></span><br><span class="line">                <span class="keyword">return</span> o2.size()-o1.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        target-=root.val;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        help(root.left,target);</span><br><span class="line">        help(root.right,target);</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ25-复杂链表的复制"><a href="#JZ25-复杂链表的复制" class="headerlink" title="JZ25 复杂链表的复制"></a>JZ25 复杂链表的复制</h1><p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<ul>
<li><p>先在原链接上复制，再匹配对应的随机链接，最后拆分原始节点和克隆节点</p>
</li>
<li><p>特别注意使用<code>.next</code>的时候，这个节点是否是null，如果是还调用的话，会报指针null错</p>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/jz25.png" alt="流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode currentNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode tmp=<span class="keyword">new</span> RandomListNode(currentNode.label);</span><br><span class="line">            tmp.next=currentNode.next;</span><br><span class="line">            currentNode.next=tmp;</span><br><span class="line">            currentNode=tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode=pHead;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            currentNode.next.random=currentNode.random==<span class="keyword">null</span>?<span class="keyword">null</span>:currentNode.random.next;</span><br><span class="line">            currentNode=currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode=pHead;</span><br><span class="line">        RandomListNode result=pHead.next;</span><br><span class="line">        <span class="keyword">while</span>(currentNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode tmp=currentNode.next;</span><br><span class="line">            currentNode.next=tmp.next;</span><br><span class="line">            tmp.next=tmp.next==<span class="keyword">null</span>?<span class="keyword">null</span>:tmp.next.next;</span><br><span class="line">            currentNode=currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ26-二叉搜索树与双向链表"><a href="#JZ26-二叉搜索树与双向链表" class="headerlink" title="JZ26 二叉搜索树与双向链表"></a>JZ26 二叉搜索树与双向链表</h1><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>递归：即假设经过这个函数后，左右子树都整理好，并返回当前头结点</p>
<ul>
<li>如果左右子树都为null，则返回当前节点</li>
<li>当前节点和整理好的左子树的末端节点连接，和整理好的右子树的头结点连接</li>
<li>最终返回值：如果有左子树，返回整理好的左子树的头结点；如果没有，返回当前节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)<span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left==<span class="keyword">null</span>&amp;&amp;pRootOfTree.right==<span class="keyword">null</span>)<span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        TreeNode finalResult=pRootOfTree;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode head=Convert(pRootOfTree.right);</span><br><span class="line">            pRootOfTree.right=head;</span><br><span class="line">            head.left=pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode head=Convert(pRootOfTree.left);</span><br><span class="line">            TreeNode tmp=head;</span><br><span class="line">            <span class="keyword">while</span>(tmp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                tmp=tmp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.right=pRootOfTree;</span><br><span class="line">            pRootOfTree.left=tmp;</span><br><span class="line">            finalResult=head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ27-字符串排列"><a href="#JZ27-字符串排列" class="headerlink" title="JZ27 字符串排列"></a>JZ27 字符串排列</h1><p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba</p>
<p>递归+回溯法</p>
<ul>
<li>String转char数组：<code>toCharArray()</code></li>
<li>char数组转String：<code>String s=String.valueOf(charstr);</code></li>
<li>第0位分别和第012位交换得到第二行排列</li>
<li>第1位分别和12位交换得到第三行排列</li>
<li>到达最终叶节点（index==chararray.length-1),该排列加入结果队列</li>
<li>字典序排列：<code>Collections.sort()</code></li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ27.png" alt="回溯过程"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            PermutationHelp(str.toCharArray(),<span class="number">0</span>,result);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PermutationHelp</span><span class="params">(<span class="keyword">char</span>[] charstr,<span class="keyword">int</span> i,ArrayList&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=charstr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;charstr.length;j++)&#123;</span><br><span class="line">                swap(charstr,i,j);</span><br><span class="line">                PermutationHelp(charstr,i+<span class="number">1</span>,result);</span><br><span class="line">                swap(charstr,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            String s=String.valueOf(charstr);</span><br><span class="line">            <span class="keyword">if</span>(!result.contains(s))result.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] charstr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=charstr[i];</span><br><span class="line">        charstr[i]=charstr[j];</span><br><span class="line">        charstr[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ28-数组中超过一半的数"><a href="#JZ28-数组中超过一半的数" class="headerlink" title="JZ28 数组中超过一半的数"></a>JZ28 数组中超过一半的数</h1><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<ul>
<li>思想：如果两个数不相等，就消去这两个数，最坏情况下，每次消去一个众数和一个非众数，那么如果存在众数，最后留下的数肯定是众数。</li>
<li>用一个变量candi保存候选数，一个变量num保存候选数出现次数</li>
<li>遍历数组，候选数和下一个数相等，num++；不等，num–；num==0,下一个遍历的数成为新的候选数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candi=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                candi=array[i];</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(candi==array[i])&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tmp:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp==candi)num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num&gt;array.length/<span class="number">2</span>?candi:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ29-最小的K个数"><a href="#JZ29-最小的K个数" class="headerlink" title="JZ29 最小的K个数"></a>JZ29 最小的K个数</h1><p>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>思路一：排序，取前K个。Arrays.sort()</p>
<p>思路二：用优先级队列<code>PriorityQueue&lt;Integer&gt;</code>，通过重写比较函数，降序排列（队列头是最大值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Comparator&lt;Integer&gt; cmp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a, Integer b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b-a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input.length==<span class="number">0</span>||k&gt;input.length||k==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; myQueue=<span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(k,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length;i++)&#123;</span><br><span class="line">            myQueue.offer(input[i]);</span><br><span class="line">            <span class="keyword">if</span>(myQueue.size()&gt;k)myQueue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            result.add(myQueue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ30-连续子数组的最大和"><a href="#JZ30-连续子数组的最大和" class="headerlink" title="JZ30 连续子数组的最大和"></a>JZ30 连续子数组的最大和</h1><p>题目：输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n).</p>
<p>两个变量，sum存储子数组的和，max存储和最大的子数组和。如果sum+当前数比当前数小，sum更新为当前数。如果sum比max大，更新max为sum。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+array[i]&lt;array[i])&#123;</span><br><span class="line">                sum=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max)max=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ31-整数中1出现的次数"><a href="#JZ31-整数中1出现的次数" class="headerlink" title="JZ31 整数中1出现的次数"></a>JZ31 整数中1出现的次数</h1><p>归纳：以百位为例</p>
<ul>
<li><p>该数百位为0，例如12012，则从0到12012的数，百位为1的有100<del>199,1100</del>1199，…，11100~11199，共12*100个，即高位数决定</p>
</li>
<li><p>该数百位为1，例如12112，则从0到12112的数，百位为1的有100<del>199,1100</del>1199，…，11100<del>11199和12100</del>12112共12*100+12+1个，高位数和低位数决定</p>
</li>
<li><p>该数百位为2<del>9，例如12212，则从0到12212的数，百位为1的有100</del>199,1100<del>1199，…，11100</del>11199和12100~12199共（12+1）*100个</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=(n/i)%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> high=n/(i*<span class="number">10</span>);</span><br><span class="line">                sum+=(high*i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> high=n/(i*<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">int</span> low=n%i;</span><br><span class="line">                sum+=(high*i+low+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> high=n/(i*<span class="number">10</span>);</span><br><span class="line">                sum+=((high+<span class="number">1</span>)*i);</span><br><span class="line">            &#125;</span><br><span class="line">            i*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ32-把数组排成最小的数"><a href="#JZ32-把数组排成最小的数" class="headerlink" title="JZ32 把数组排成最小的数"></a>JZ32 把数组排成最小的数</h1><p>问题： 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 </p>
<p> 两个字符串a,b，如果a + b &lt; b + a, 我们希望a排在b的前面。 自定义排序规则，使得ArrayList中字符串都满足如上规则，那么最后的结果肯定是最小的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; myCmp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer a,Integer b)</span></span>&#123;</span><br><span class="line">            String ab=a+<span class="string">&quot;&quot;</span>+b;</span><br><span class="line">            String ba=b+<span class="string">&quot;&quot;</span>+a;</span><br><span class="line">            <span class="keyword">return</span> ab.compareTo(ba);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        ArrayList&lt;Integer&gt; myArray=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:numbers)&#123;</span><br><span class="line">            myArray.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(myArray,myCmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:myArray)&#123;</span><br><span class="line">            result+=(<span class="string">&quot;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ33-丑数"><a href="#JZ33-丑数" class="headerlink" title="JZ33 丑数"></a>JZ33 丑数</h1><p>题目： 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 </p>
<ul>
<li>一个丑数是一个比他小的丑数乘以2、3、5得到的</li>
<li>生成丑数的过程中，每个丑数只会分别乘以1次2、3、5</li>
<li>用三个int：n2, n3, n5分别记录还未乘以过2, 3, 5的位置</li>
<li>每次将n2, n3, n5这三个位置的丑数生成的新丑数中最小的那个加入结果数组</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ33.PNG" alt="过程" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="keyword">int</span> n2=<span class="number">0</span>,n3=<span class="number">0</span>,n5=<span class="number">0</span>;</span><br><span class="line">        result[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newcs=minOfThree(result[n2]*<span class="number">2</span>,result[n3]*<span class="number">3</span>,result[n5]*<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(newcs==result[n2]*<span class="number">2</span>)n2++;</span><br><span class="line">            <span class="keyword">if</span>(newcs==result[n3]*<span class="number">3</span>)n3++;</span><br><span class="line">            <span class="keyword">if</span>(newcs==result[n5]*<span class="number">5</span>)n5++;</span><br><span class="line">            result[i]=newcs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOfThree</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min=a&lt;b?a:b;</span><br><span class="line">        min=min&lt;c?min:c;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ34-第一个只出现一次的字符"><a href="#JZ34-第一个只出现一次的字符" class="headerlink" title="JZ34 第一个只出现一次的字符"></a>JZ34 第一个只出现一次的字符</h1><p>题目：在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数 )</p>
<ul>
<li>创建一个数组，index是字符的ASCII值，value是该字符出现次数。</li>
<li>第一次遍历str,记录得到每个字符出现次数，第二次遍历str，得到第一个出现次数为1的字符</li>
<li>字符的ASCII：<code>Integer.valueOf(&#39;a&#39;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            result[Integer.valueOf(str.charAt(i))]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[Integer.valueOf(str.charAt(i))]==<span class="number">1</span>)<span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ35-数组中的逆序对"><a href="#JZ35-数组中的逆序对" class="headerlink" title="JZ35 数组中的逆序对"></a>JZ35 数组中的逆序对</h1><p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>对于$50%$的数据,$size\leq 10^4$<br>对于$70%$的数据,$size\leq 10^5$<br>对于$100%$的数据,$size\leq 2*10^5$</p>
<p>输入描述: 题目保证输入的数组中没有的相同的数字</p>
<p>思路：递归，把数组均分为两个数组</p>
<ul>
<li><p>左段数组排序并计算逆序对数</p>
</li>
<li><p>右段数组排序并计算逆序对数</p>
</li>
<li><p>将两个排好序的数组合并并计算逆序对数。</p>
</li>
</ul>
<p>递归到底的条件是数组中只有一个数。</p>
<p>两个数组合并：由于数组已经排好序，从左到右递增</p>
<ul>
<li>使用两个指针left和right指向两个数组的最大值。</li>
<li>然后使用归并排序思想操作</li>
<li>left和right比，大的放到tmp中。如果left大，逆序对数result还要加上right-mid</li>
<li>最后如果其中一个数组先遍历完，把另一个数组剩下的依序放入tmp中</li>
<li>在tmp数组中得到排好序的数组，最后把array数组中对应的部分改为tmp中排好序的结果：</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ35.png" alt="JZ35" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] tmp=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=array.length-<span class="number">1</span>;</span><br><span class="line">        cutPairs(array,tmp,start,end);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cutPairs</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span>[]tmp,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(end-start&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cutPairs(array,tmp,start,(end+start)/<span class="number">2</span>);</span><br><span class="line">            cutPairs(array,tmp,(end+start)/<span class="number">2</span>+<span class="number">1</span>,end);</span><br><span class="line">            merge(array,tmp,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span>[]tmp,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(end+start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left=mid,right=end;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=end;i&gt;start-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;=start&amp;&amp;right&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[left]&gt;array[right])&#123;</span><br><span class="line">                    tmp[i]=array[left];</span><br><span class="line">                    result+=(right-mid);</span><br><span class="line">                    result=result%<span class="number">1000000007</span>;</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[i]=array[right];</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(left&lt;start)&#123;</span><br><span class="line">                    tmp[i]=array[right];</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tmp[i]=array[left];</span><br><span class="line">                    left--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=end;i&gt;start-<span class="number">1</span>;i--)&#123;</span><br><span class="line">            array[i]=tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JZ36-两个链表的第一个公共结点"><a href="#JZ36-两个链表的第一个公共结点" class="headerlink" title="JZ36 两个链表的第一个公共结点"></a>JZ36 两个链表的第一个公共结点</h1><p>题目： 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） </p>
<ul>
<li>有了第一个公共点后，之后的结点都是公共点（因为单链表只有一个next）</li>
<li>使用两个指针，分别从两个链表头开始遍历，遍历到尾端时（next==null）再从另一条链表头遍历，这样他们就会同时到达链表末端（下图中的5结点），也就是说他们会在第一个公共结点相遇（下图中的8）</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ36.png" alt="JZ36"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode p1=pHead1;</span><br><span class="line">        ListNode p2=pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead1==<span class="keyword">null</span>||pHead2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="keyword">null</span>&amp;&amp;p2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="keyword">null</span>)p1=pHead2;</span><br><span class="line">            <span class="keyword">if</span>(p2==<span class="keyword">null</span>)p2=pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ37-数字在排序数组中出现的次数"><a href="#JZ37-数字在排序数组中出现的次数" class="headerlink" title="JZ37 数字在排序数组中出现的次数"></a>JZ37 数字在排序数组中出现的次数</h1><p>题目：</p>
<ul>
<li>二分查找法查找k，找到k后，往前计数有多少个k，往后计数有多少个k</li>
<li>上一种方法时间复杂度O(n)，改进：使用二分法查找k，找到后对前半段继续二分查找k，直到该k前一位不等于k，则表示找到了第一个k，同理找最后一个k，index相减得到次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> subGet(array,k,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subGet</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> k,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">int</span> index=mid;</span><br><span class="line">            <span class="keyword">while</span>(index&gt;=start&amp;&amp;array[index]==k)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">            index=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;=end&amp;&amp;array[index]==k)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&gt;k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==start)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> subGet(array,k,start,mid-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==end)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> subGet(array,k,mid+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ38-二叉树深度"><a href="#JZ38-二叉树深度" class="headerlink" title="JZ38 二叉树深度"></a>JZ38 二叉树深度</h1><ul>
<li>递归</li>
<li>非递归：层次遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        left=TreeDepth(root.left);</span><br><span class="line">        right=TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ39-平衡二叉树"><a href="#JZ39-平衡二叉树" class="headerlink" title="JZ39 平衡二叉树"></a>JZ39 平衡二叉树</h1><p>题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。<strong>平衡二叉树</strong>（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>递归获取子树深度，设定非平衡二叉树深度为-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> getDepth(root)!=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=getDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(right-left)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(right,left)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ40-数组中只出现一次的数字"><a href="#JZ40-数组中只出现一次的数字" class="headerlink" title="JZ40 数组中只出现一次的数字"></a>JZ40 数组中只出现一次的数字</h1><p>题目： 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 </p>
<ul>
<li><p>两数相等，异或为0；一个数和0异或，为它本身</p>
</li>
<li><p>把数组中所有数异或，得到的就是那两个只出现一次的数的异或</p>
</li>
<li><p>一个数和它的负数（即补码，取反加1）相与，得到的是第一个出现1的位置：10101&amp;01011=00001</p>
</li>
<li><p>按上述位的位置，数组分为两部分，改位为1或0</p>
</li>
<li><p>每部分再内部异或即可得到只出现一次的数字</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;</span><br><span class="line">            tmp^=i;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp&amp;=(-tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i&amp;tmp)==<span class="number">0</span>)&#123;</span><br><span class="line">                num1[<span class="number">0</span>]^=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>]^=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ41-和为S的连续正数序列"><a href="#JZ41-和为S的连续正数序列" class="headerlink" title="JZ41 和为S的连续正数序列"></a>JZ41 和为S的连续正数序列</h1><p>题目： 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<p>滑动窗口：</p>
<ul>
<li>两个指针left和right，如果窗口内的和小于S，right++;如果大于，left++，等于就把结果加入result中。</li>
<li>由于至少包括两个数，所以循环停止的条件是left&gt;S/2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">2</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">3</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=sum/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumtmp=(left+right)*(right-left+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sumtmp&gt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sumtmp&lt;sum)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; resulttmp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">                    resulttmp.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                result.add((resulttmp));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ42-和为S的两个数字"><a href="#JZ42-和为S的两个数字" class="headerlink" title="JZ42 和为S的两个数字"></a>JZ42 和为S的两个数字</h1><p>题目： 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
<ul>
<li>left和right两个指针。<code>left=0    right=array.length-1</code></li>
<li>left小的，两个数的乘积更小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;=<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sumtmp=array[left]+array[right];</span><br><span class="line">            <span class="keyword">if</span>(sumtmp&lt;sum)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sumtmp&gt;sum)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(array[left]);</span><br><span class="line">                result.add(array[right]);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ43-左旋转字符串"><a href="#JZ43-左旋转字符串" class="headerlink" title="JZ43 左旋转字符串"></a>JZ43 左旋转字符串</h1><p>题目： 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ </p>
<p>主要两个函数：<code>String.concat()</code>和<code>String.substring()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">&quot;&quot;</span>||str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)<span class="keyword">return</span> str;</span><br><span class="line">        n=n%str.length();</span><br><span class="line">        <span class="keyword">return</span> str.concat(str).substring(n,str.length()+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ44-翻转单词顺序列"><a href="#JZ44-翻转单词顺序列" class="headerlink" title="JZ44 翻转单词顺序列"></a>JZ44 翻转单词顺序列</h1><p>题目： 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ </p>
<p>创建一个<code>ArrayList&lt;String&gt;</code>来保存每个单词，用两个指针遍历，分别记录单词起始字符和终止字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)<span class="keyword">return</span> str;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        ArrayList&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;str.length())&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;str.length()&amp;&amp;str.charAt(left)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>&amp;&amp;left==str.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> str;</span><br><span class="line">            &#125;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            right=left+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;str.length()&amp;&amp;str.charAt(right)!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(str.substring(left,right));</span><br><span class="line">            left=right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String finalresult=result.get(result.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=result.size()-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            finalresult+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">            finalresult+=result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalresult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ45-扑克牌顺子"><a href="#JZ45-扑克牌顺子" class="headerlink" title="JZ45 扑克牌顺子"></a>JZ45 扑克牌顺子</h1><p>题目： LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 </p>
<p>先排序，然后找到除去0以外的最小的数和最大的数。</p>
<ul>
<li>如果除0外，数组中有相等的数，则不是顺子</li>
<li>如果两数之差&lt;=<code>numbers,length-1</code>，则是顺子；否则不是</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.length==<span class="number">0</span>||numbers==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[start]==<span class="number">0</span>&amp;&amp;start&lt;numbers.length)start++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[i+<span class="number">1</span>])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dis=numbers[numbers.length-<span class="number">1</span>]-numbers[start];</span><br><span class="line">        <span class="keyword">if</span>(dis&lt;=numbers.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ46-圆圈中最后剩下的数"><a href="#JZ46-圆圈中最后剩下的数" class="headerlink" title="JZ46 圆圈中最后剩下的数"></a>JZ46 圆圈中最后剩下的数</h1><p>题目：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<p>如果没有小朋友，请返回-1</p>
<p>递归： 长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。 假设我们已知n - 1的序列最后留下的是 f(n - 1, m) 号小朋友，那么对于n个小朋友的序列，f(n - 1, m) 号小朋友的位置其实是(f(n - 1, m) + m )%n</p>
<p>下图中就是，对于6个小朋友时，假设已知最后留下的是0号小朋友，那么在上一轮中，0号小朋友的位置就是3=（0+3）%7</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/JZ46.png" alt="图示" style="zoom:70%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (m+LastRemaining_Solution(n-<span class="number">1</span>,m))%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ47-1-2-3-…-n"><a href="#JZ47-1-2-3-…-n" class="headerlink" title="JZ47 1+2+3+…+n"></a>JZ47 1+2+3+…+n</h1><p>递归，<code>&amp;&amp;</code>运算先算左边，成立再算右边，不成立就不算右边了；而<code>&amp;</code>两边同时算。所以可以用<code>&amp;&amp;</code>来实现当i=0时就不递归了（右边不继续算了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ite=n;</span><br><span class="line">        <span class="keyword">boolean</span> flag=(n!=<span class="number">0</span>)&amp;&amp;((ite+=Sum_Solution(n-<span class="number">1</span>))!=<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ48-不用加减乘除做加法"><a href="#JZ48-不用加减乘除做加法" class="headerlink" title="JZ48 不用加减乘除做加法"></a>JZ48 不用加减乘除做加法</h1><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>二进制中，异或<code>^</code>就是相加（不含进位），按位与<code>&amp;</code>就是求进位，再用递归即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=num1^num2;</span><br><span class="line">        <span class="keyword">int</span> carry=(num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(carry==<span class="number">0</span>)<span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> Add(sum,carry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ49-字符串转换成整数"><a href="#JZ49-字符串转换成整数" class="headerlink" title="JZ49 字符串转换成整数"></a>JZ49 字符串转换成整数</h1><p>题目：将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<ul>
<li><p>输入描述:输入一个字符串,包括数字字母符号,可以为空</p>
</li>
<li><p>返回值描述:如果是合法的数值表达则返回该数字，否则返回0</p>
</li>
</ul>
<p>思路：</p>
<ul>
<li>0位只能是’+’ ‘-‘或者数字</li>
<li>中间有非数字就返回0</li>
<li>注意越界，<code>Integer.MAX_VALUE</code>和<code>Integer.MIN_VALUE</code>，可以先用long存储数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> num=<span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">int</span> zf=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">0</span>||str==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;str.charAt(i)==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                zf=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;str.charAt(i)==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                zf=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((str.charAt(i)-<span class="string">&#x27;0&#x27;</span>&gt;=<span class="number">0</span>)&amp;&amp;(<span class="string">&#x27;9&#x27;</span>-str.charAt(i)&gt;=<span class="number">0</span>))&#123;</span><br><span class="line">                num=num*<span class="number">10</span>+(str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zf==<span class="number">0</span>&amp;&amp;num&gt;Integer.MAX_VALUE)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(zf==<span class="number">1</span>&amp;&amp;(-num&lt;Integer.MIN_VALUE))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result=(<span class="keyword">int</span>)num;</span><br><span class="line">        <span class="keyword">return</span> zf==<span class="number">0</span>?result:-result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JZ50-数组中重复的数字："><a href="#JZ50-数组中重复的数字：" class="headerlink" title="JZ50 数组中重复的数字："></a>JZ50 数组中重复的数字：</h1><ul>
<li>利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数+n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。不需要额外的空间消耗，时间效率是O(n)</li>
<li>HashMap</li>
</ul>
<h1 id="JZ51-构建乘积数组"><a href="#JZ51-构建乘积数组" class="headerlink" title="JZ51 构建乘积数组"></a>JZ51 构建乘积数组</h1><p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…*A[i-1]<em>A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<p>注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];</p>
<p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p>
<p>思路：</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01252.png" style="zoom:67%;" />

<p>先计算下三角到B[]中，再计算上三角到B[]中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> []B=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            tmp*=A[i-<span class="number">1</span>];</span><br><span class="line">            B[i]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            tmp*=A[i+<span class="number">1</span>];</span><br><span class="line">            B[i]*=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ52-正则表达式匹配"><a href="#JZ52-正则表达式匹配" class="headerlink" title="JZ52 正则表达式匹配"></a>JZ52 正则表达式匹配</h1><p>使用递归</p>
<ul>
<li><p>模式中的第二个字符是’*’时：</p>
<ul>
<li><p>字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。</p>
</li>
<li><p>字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</p>
<ul>
<li>模式后移2字符，相当于x*被忽略；</li>
<li>字符串后移1字符，模式后移2字符；</li>
<li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</li>
</ul>
</li>
</ul>
</li>
<li><p>模式中的第二个字符不是’*’时</p>
<ul>
<li>字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li>
<li>字符串第一个字符和模式中的第一个字符相不匹配，直接返回false</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有效性检验：str到尾，pattern到尾，匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pattern先到尾，匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位</span></span><br><span class="line">    <span class="keyword">if</span> (patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || </span><br><span class="line">            (pattern[patternIndex] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//x*匹配0个字符</span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">2</span>)<span class="comment">//匹配1个字符</span></span><br><span class="line">                    || matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex);<span class="comment">//*匹配多个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str, strIndex, pattern, patternIndex + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((strIndex != str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) || </span><br><span class="line">        (pattern[patternIndex] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; strIndex != str.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, strIndex + <span class="number">1</span>, pattern, patternIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ53-表示数值的字符串"><a href="#JZ53-表示数值的字符串" class="headerlink" title="JZ53 表示数值的字符串"></a>JZ53 表示数值的字符串</h1><p>题目：</p>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>思路：</p>
<ul>
<li>只能有一个小数点</li>
<li>只能有1个e</li>
<li>e后面必须有一个数且是整数</li>
<li>正负号只能出现在第一位或e后面的第一位</li>
<li>小数点前一位只能是0~9或者+-，可以是第一位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flagfloat=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flage=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;+&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flage&amp;&amp;(str[i]==<span class="string">&#x27;e&#x27;</span>||str[i]==<span class="string">&#x27;E&#x27;</span>))&#123;</span><br><span class="line">                flage=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;str.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[i+<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>||str[i+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)i++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((!flagfloat)&amp;&amp;(!flage)&amp;&amp;(str[i]==<span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                flagfloat=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((str[i-<span class="number">1</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i-<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)||</span><br><span class="line">                        str[i-<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>||</span><br><span class="line">                        str[i-<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ54-字符流中第一个不重复的字符"><a href="#JZ54-字符流中第一个不重复的字符" class="headerlink" title="JZ54 字符流中第一个不重复的字符"></a>JZ54 字符流中第一个不重复的字符</h1><p>题目：</p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p>思路：</p>
<ul>
<li>用一个数组存储每个字符出现的次数，没出现是0，出现1次是1，超过1次是2.</li>
<li>用一个队列存储出现过的字符，多次出现不重复入队</li>
<li>每次找只出现一次的字符：查看队头，数组中对应值是1，则返回该字符，不是1就出队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] allchar=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    Queue&lt;Character&gt; charqueue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(allchar[ch]==<span class="number">0</span>)&#123;</span><br><span class="line">            charqueue.offer(ch);</span><br><span class="line">            allchar[ch]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(allchar[ch]==<span class="number">1</span>)&#123;</span><br><span class="line">            allchar[ch]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!charqueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp=charqueue.peek();</span><br><span class="line">            <span class="keyword">if</span>(allchar[tmp]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                charqueue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ55-链表中环的入口结点"><a href="#JZ55-链表中环的入口结点" class="headerlink" title="JZ55 链表中环的入口结点"></a>JZ55 链表中环的入口结点</h1><p>题目：</p>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<p>思路：</p>
<p>快慢指针:</p>
<p><strong>两个结论：</strong></p>
<ol>
<li><p>设置快慢指针从head开始走，快指针每次走两步，慢指针每次走一步。假如有环，他们最后一定相遇。</p>
</li>
<li><p>两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇与环入口。</p>
</li>
</ol>
<p><strong>证明结论1</strong>：设置快慢指针fast和low，fast每次走两步，low每次走一步。假如有环，两者一定会相遇（因为low一旦进环，可看作fast在后面追赶low的过程，每次两者都接近一步，最后一定能追上）。</p>
<p><strong>证明结论2：</strong></p>
<p>设：</p>
<p>链表头到环入口长度为–<strong>a</strong></p>
<p>环入口到相遇点长度为–<strong>b</strong></p>
<p>相遇点到环入口长度为–<strong>c</strong></p>
<p>相遇时</p>
<p><strong>快指针路程=a+(b+c)k+b</strong> ，k&gt;=1 其中b+c为环的长度，k为绕环的圈数（k&gt;=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。</p>
<p><strong>慢指针路程=a+b</strong></p>
<p>快指针走的路程是慢指针的两倍，所以：</p>
<p><strong>（a+b）*2=a+(b+c)k+b</strong></p>
<p>化简可得：</p>
<p><strong>a=(k-1)(b+c)+c</strong> 这个式子的意思是： <strong>链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度</strong>。其中k&gt;=1,所以<strong>k-1&gt;=0</strong>圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01261.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode pfast=pHead;</span><br><span class="line">        ListNode pslow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(pfast!=<span class="keyword">null</span>&amp;&amp;pfast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pfast=pfast.next.next;</span><br><span class="line">            pslow=pslow.next;</span><br><span class="line">            <span class="keyword">if</span>(pslow==pfast)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pfast==<span class="keyword">null</span>||pfast.next==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        pslow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(pslow!=pfast)&#123;</span><br><span class="line">            pslow=pslow.next;</span><br><span class="line">            pfast=pfast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pslow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ56-删除链表中重复的结点"><a href="#JZ56-删除链表中重复的结点" class="headerlink" title="JZ56 删除链表中重复的结点"></a>JZ56 删除链表中重复的结点</h1><p>题目：</p>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>思路：</p>
<ul>
<li>两个指针，一个记录前一个结点，一个记录当前结点</li>
<li>创建一个meta结点接在pHead前，以处理第一个结点就是重复结点的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode meta=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        meta.next=pHead;</span><br><span class="line">        ListNode p1=meta;</span><br><span class="line">        ListNode p2=pHead;</span><br><span class="line">        <span class="keyword">if</span>(p2==<span class="keyword">null</span>)<span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">while</span>(p2!=<span class="keyword">null</span>&amp;&amp;p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p2.next.val==p2.val)&#123;</span><br><span class="line">                <span class="keyword">while</span>(p2.next!=<span class="keyword">null</span>&amp;&amp;p2.next.val==p2.val)&#123;</span><br><span class="line">                    p2=p2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                p1.next=p2.next;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> meta.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ57-二叉树的下一个结点"><a href="#JZ57-二叉树的下一个结点" class="headerlink" title="JZ57 二叉树的下一个结点"></a>JZ57 二叉树的下一个结点</h1><p>题目：</p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p>思路：</p>
<ul>
<li>有右孩子，找到右孩子的最左左孩子</li>
<li>没有右孩子<ul>
<li>节点是父节点的左孩子，返回父节点</li>
<li>节点是父节点的右孩子，递归父节点</li>
<li>节点或父节点是null，返回null</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeLinkNode tmpNode;</span><br><span class="line">        <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tmpNode=pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(tmpNode.left!=<span class="keyword">null</span>)tmpNode=tmpNode.left;</span><br><span class="line">            <span class="keyword">return</span> tmpNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rightNode(pNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeLinkNode <span class="title">rightNode</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode==<span class="keyword">null</span>||pNode.next==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode.next.left==pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> rightNode(pNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ58-对称的二叉树"><a href="#JZ58-对称的二叉树" class="headerlink" title="JZ58 对称的二叉树"></a>JZ58 对称的二叉树</h1><p>题目：</p>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<p>思路：</p>
<ul>
<li><p>递归：左孩子的左孩子等于右孩子的右孩子，左孩子的右孩子等于右孩子的左孩子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> comp(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">comp</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp;right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val==right.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> comp(left.left,right.right)&amp;&amp;comp(left.right,right.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用栈实现DFS，每次成对入栈，成对出栈(注意：null也会入栈)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(pRoot.left);</span><br><span class="line">        s.push(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            TreeNode right = s.pop();<span class="comment">//成对取出</span></span><br><span class="line">            TreeNode left = s.pop();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//成对插入</span></span><br><span class="line">            s.push(left.left);</span><br><span class="line">            s.push(right.right);</span><br><span class="line">            s.push(left.right);</span><br><span class="line">            s.push(right.left);</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用队列实现BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetricalBFS</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       Queue&lt;TreeNode&gt; s = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       s.offer(pRoot.left);</span><br><span class="line">       s.offer(pRoot.right);</span><br><span class="line">       <span class="keyword">while</span>(!s.isEmpty()) &#123;</span><br><span class="line">           TreeNode left= s.poll();<span class="comment">//成对取出</span></span><br><span class="line">           TreeNode right= s.poll();</span><br><span class="line">           <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//成对插入</span></span><br><span class="line">           s.offer(left.left);</span><br><span class="line">           s.offer(right.right);</span><br><span class="line">           s.offer(left.right);</span><br><span class="line">           s.offer(right.left);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="JZ59-按之字形顺序打印二叉树"><a href="#JZ59-按之字形顺序打印二叉树" class="headerlink" title="JZ59 按之字形顺序打印二叉树"></a>JZ59 按之字形顺序打印二叉树</h1><p>题目：</p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>思路：</p>
<ul>
<li>层序遍历，然后分奇偶插入Deque的前后</li>
<li>层序遍历，然后分奇偶插入做Collections.reverse</li>
<li>用两个栈。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stackji=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stackou=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        stackji.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!stackou.empty()||!stackji.empty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; jishu=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stackji.empty())&#123;</span><br><span class="line">                TreeNode tmp=stackji.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">                jishu.add(tmp.val);</span><br><span class="line">                stackou.push(tmp.left);</span><br><span class="line">                stackou.push(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; oushu=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!stackou.empty())&#123;</span><br><span class="line">                TreeNode tmp2=stackou.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp2==<span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">                oushu.add(tmp2.val);</span><br><span class="line">                stackji.push(tmp2.right);</span><br><span class="line">                stackji.push(tmp2.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!jishu.isEmpty())result.add(jishu);</span><br><span class="line">            <span class="keyword">if</span>(!oushu.isEmpty())result.add(oushu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ60-把二叉树打印成多行"><a href="#JZ60-把二叉树打印成多行" class="headerlink" title="JZ60 把二叉树打印成多行"></a>JZ60 把二叉树打印成多行</h1><p>题目：</p>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行</p>
<p>思路：</p>
<p>层序遍历</p>
<h1 id="JZ61-序列化二叉树"><a href="#JZ61-序列化二叉树" class="headerlink" title="JZ61 序列化二叉树"></a>JZ61 序列化二叉树</h1><p>题目：</p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p>
<p>例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树</p>
<p>思路：</p>
<p>以前序遍历为例，写个前序遍历，再写个递归来反序列化。重点是：</p>
<ul>
<li>String类型要比较的话要用<code>equals()</code></li>
<li>String类型分割用<code>split()</code>成String[]</li>
<li>String转Int用<code>Integer.parseInt()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        Stack&lt;TreeNode&gt; myStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        myStack.push(root);</span><br><span class="line">        TreeNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(!myStack.empty())&#123;</span><br><span class="line">            tmp=myStack.pop();</span><br><span class="line">            <span class="keyword">if</span>(tmp==<span class="keyword">null</span>)&#123;</span><br><span class="line">                result.append(<span class="string">&quot;#!&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.append(String.valueOf(tmp.val)+<span class="string">&quot;!&quot;</span>);</span><br><span class="line">                myStack.push(tmp.right);</span><br><span class="line">                myStack.push(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        String[]strnew=str.split(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Des(strnew);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">Des</span><span class="params">(String []strnew)</span></span>&#123;</span><br><span class="line">        TreeNode newtree=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(strnew[index].equals(<span class="string">&quot;#&quot;</span>))&#123;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">return</span> newtree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> now=Integer.parseInt(strnew[index]);</span><br><span class="line">            newtree=<span class="keyword">new</span> TreeNode(now);</span><br><span class="line">            index++;</span><br><span class="line">            newtree.left=Des(strnew);</span><br><span class="line">            newtree.right=Des(strnew);</span><br><span class="line">            <span class="keyword">return</span> newtree;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ62-二叉搜索树的第k个结点"><a href="#JZ62-二叉搜索树的第k个结点" class="headerlink" title="JZ62 二叉搜索树的第k个结点"></a>JZ62 二叉搜索树的第k个结点</h1><p>题目：</p>
<p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p>
<p>思路：</p>
<p>中序遍历，注意k的界限判定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        TreeNode newnode=pRoot;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; relink=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; restack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!restack.empty()||newnode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(newnode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                restack.push(newnode);</span><br><span class="line">                newnode=newnode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode tmp=restack.pop();</span><br><span class="line">            relink.add(tmp);</span><br><span class="line">            newnode=tmp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;relink.size())<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> relink.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ63-数据流中的中位数"><a href="#JZ63-数据流中的中位数" class="headerlink" title="JZ63 数据流中的中位数"></a>JZ63 数据流中的中位数</h1><p>题目：</p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p>思路：</p>
<p>用两个优先级队列，一个小顶堆min一个大顶堆max，min队首是队中最小值，max队首是队中最大值。保证min的队首&gt;max的队首。每次都插入新数据到min，如果min队首小于max了，就将队首放到max中。如果两个堆的size相差2了，就平衡一下两个堆的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(maxcp);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Integer&gt; maxcp=<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer c1,Integer c2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(c2-c1);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        minHeap.offer(num);</span><br><span class="line">        <span class="keyword">if</span>(!maxHeap.isEmpty()&amp;&amp;minHeap.peek()&lt;maxHeap.peek())&#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size()-maxHeap.size()==<span class="number">2</span>)&#123;</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size()-maxHeap.size()==-<span class="number">2</span>)&#123;</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minHeap.size()&gt;maxHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.peek().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(minHeap.size()&lt;maxHeap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.peek().doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek().doubleValue()+minHeap.peek().doubleValue())/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ64-滑动窗口的最大值"><a href="#JZ64-滑动窗口的最大值" class="headerlink" title="JZ64 滑动窗口的最大值"></a>JZ64 滑动窗口的最大值</h1><p>题目：</p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<p>窗口大于数组长度的时候，返回空</p>
<p>思路：</p>
<p>假设我们当前遍历到下标i，对于下标i+1的元素（假设i和i+1都在同一个窗口）</p>
<ul>
<li>如果arr[i+1] &gt;arr[i], 那么arr[i]永远不可能是窗口最大值</li>
<li>如果arr[i+1] &lt; arr[i]，那么arr[i]和arr[i+1]都需要保留，因为之后可能arr[i]之前的最大值会失效</li>
</ul>
<p>所以使用双端队列<code>ArrayDeque</code></p>
<ol>
<li><p>遍历数组的每一个元素，</p>
</li>
<li><p>如果容器为空，则直接将当前元素加入到容器中。</p>
</li>
<li><p>如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续讲当前元素和容器的最后一个元素比较</p>
</li>
<li><p>如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾</p>
</li>
<li><p>如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(size&gt;num.length||size&lt;=<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; wd=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wd.isEmpty())&#123; <span class="comment">//2</span></span><br><span class="line">                wd.addFirst(num[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=size&amp;&amp;num[i-size]==wd.peek())&#123;<span class="comment">//5</span></span><br><span class="line">                    wd.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!wd.isEmpty()&amp;&amp;(num[i]&gt;wd.getLast()))&#123; <span class="comment">//3</span></span><br><span class="line">                    wd.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                wd.addLast(num[i]);<span class="comment">//4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=size-<span class="number">1</span>)result.add(wd.getFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ65-矩阵中的路径"><a href="#JZ65-矩阵中的路径" class="headerlink" title="JZ65 矩阵中的路径"></a>JZ65 矩阵中的路径</h1><p>题目：</p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如<br>$$<br>\begin{bmatrix} a &amp; b &amp; c &amp;e \ s &amp; f &amp; c &amp; s \ a &amp; d &amp; e&amp; e\ \end{bmatrix}<br>$$</p>
<p>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p>思路：</p>
<p>使用回溯递归。</p>
<p>算法框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[]done=<span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line">                <span class="keyword">int</span> stridx=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(head(i,j,done,rows,cols,matrix,str,stridx))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">head</span><span class="params">(<span class="keyword">int</span> nowrow,<span class="keyword">int</span> nowcol,<span class="keyword">int</span> []done,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">int</span> rows,<span class="keyword">int</span> cols,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">char</span>[]matrix,<span class="keyword">char</span>[]str,<span class="keyword">int</span> stridx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[nowrow*cols+nowcol]!=str[stridx])&#123;<span class="comment">//当前元素和str的当前元素不等，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            stridx++;</span><br><span class="line">            <span class="keyword">if</span>(stridx==str.length)<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//str全部元素都遍历完，返回true</span></span><br><span class="line">            done[nowrow*cols+nowcol]=<span class="number">1</span>;<span class="comment">//当前元素已访问，将done数组当前元素位置标为1</span></span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            <span class="keyword">if</span>(nowcol-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;done[nowrow*cols+nowcol-<span class="number">1</span>]!=<span class="number">1</span>)&#123;<span class="comment">//左边元素边界合法且未被访问</span></span><br><span class="line">                <span class="keyword">boolean</span> bleft=head(nowrow,nowcol-<span class="number">1</span>,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bleft)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            <span class="keyword">if</span>(nowcol+<span class="number">1</span>&lt;cols&amp;&amp;done[nowrow*cols+nowcol+<span class="number">1</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> bright=head(nowrow,nowcol+<span class="number">1</span>,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bright)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//up</span></span><br><span class="line">            <span class="keyword">if</span>(nowrow-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;done[(nowrow-<span class="number">1</span>)*cols+nowcol]!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> bup=head(nowrow-<span class="number">1</span>,nowcol,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bup)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//down</span></span><br><span class="line">            <span class="keyword">if</span>(nowrow+<span class="number">1</span>&lt;rows&amp;&amp;done[(nowrow+<span class="number">1</span>)*cols+nowcol]!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> bdown=head(nowrow+<span class="number">1</span>,nowcol,done,rows,cols,matrix,str,stridx);</span><br><span class="line">                <span class="keyword">if</span>(bdown)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ66-机器人的运动范围"><a href="#JZ66-机器人的运动范围" class="headerlink" title="JZ66 机器人的运动范围"></a>JZ66 机器人的运动范围</h1><p>题目：</p>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：</p>
<p>回溯递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][]done=<span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        next(threshold,rows,cols,<span class="number">0</span>,<span class="number">0</span>,done);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> thre,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> nowrow,<span class="keyword">int</span> nowcol,<span class="keyword">int</span>[][]done)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nowrow&lt;rows &amp;&amp; nowcol&lt;cols &amp;&amp; nowrow&gt;=<span class="number">0</span> &amp;&amp; nowcol&gt;=<span class="number">0</span> &amp;&amp; <span class="comment">//格子坐标不越界</span></span><br><span class="line">           done[nowrow][nowcol]!=<span class="number">1</span>&amp;&amp;  <span class="comment">//格子未被访问</span></span><br><span class="line">           legal(nowrow,nowcol,thre))&#123;   <span class="comment">//格子小于等于阈值</span></span><br><span class="line">            num++;</span><br><span class="line">            done[nowrow][nowcol]=<span class="number">1</span>;</span><br><span class="line">            next(thre,rows,cols,nowrow,nowcol-<span class="number">1</span>,done);<span class="comment">//left</span></span><br><span class="line">            next(thre,rows,cols,nowrow,nowcol+<span class="number">1</span>,done);<span class="comment">//right</span></span><br><span class="line">            next(thre,rows,cols,nowrow+<span class="number">1</span>,nowcol,done);<span class="comment">//up</span></span><br><span class="line">            next(thre,rows,cols,nowrow-<span class="number">1</span>,nowcol,done);<span class="comment">//down</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">legal</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> thre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row!=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp+=row%<span class="number">10</span>;</span><br><span class="line">            row/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(col!=<span class="number">0</span>)&#123;</span><br><span class="line">            tmp+=col%<span class="number">10</span>;</span><br><span class="line">            col/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;thre)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JZ67-剪绳子"><a href="#JZ67-剪绳子" class="headerlink" title="JZ67 剪绳子"></a>JZ67 剪绳子</h1><p>题目：</p>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路：</p>
<p>暴力递归会超时，采用一个数组，记录已经计算过的值。</p>
<p>另外注意对于2,3来说，如果是绳子长，那么最大值分别是1和2，如果是递归中，那么最大值是2和3.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] done=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">3</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">            done[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> back(target,done);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> target,<span class="keyword">int</span>[]done)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">4</span>)<span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;target;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(done[target-i]==<span class="number">0</span>)&#123;</span><br><span class="line">                done[target-i]=back(target-i,done);</span><br><span class="line">            &#125;</span><br><span class="line">            maxnum=Math.max(maxnum,i*done[target-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/10/jianzhioffer/" data-id="ckw9lh00w00322ww5hmvcac4v" data-title="剑指Offer刷题笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-iot" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/02/iot/" class="article-date">
  <time class="dt-published" datetime="2020-10-02T13:29:42.000Z" itemprop="datePublished">2020-10-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/02/iot/">腾讯物联网-甲醛检测</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>公司整了一个活动，每个参与活动的同学可以得到一块腾讯物联网的开发板和一个甲醛传感器，只要能按照教程完成这个甲醛监测仪，就可以保留它，否则得归还回去。这么快乐的白嫖机会，怎么能够错过，果断报名参加。</p>
<h1 id="甲醛监测仪介绍"><a href="#甲醛监测仪介绍" class="headerlink" title="甲醛监测仪介绍"></a>甲醛监测仪介绍</h1><p>甲醛是室内一项非常重要的指标，购买一台甲醛监测仪又显得太不划算，今天就来教大家如何使用TOS_EVB_G0开发板 + TencentOS-tiny物联网操作系统，来自制一个简单的甲醛监测仪。</p>
<p>本项目制作的甲醛监测仪可以实时的检测室内甲醛浓度，在OLED屏幕上显示具体数值，同时还可以将数据实时上报到腾讯云物联网开发平台IoT Explorer，用户可以在“腾讯连连”小程序实时查看数据，并通过公众号及时接收告警信息。</p>
<p>本项目所需要的物品清单有：</p>
<ul>
<li>TOS_EVB_G0开发板 x 1</li>
<li>英国 Dart 甲醛传感器 x 1</li>
<li>E53甲醛传感器底板 x 1</li>
</ul>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbbdqlnzjj30ua0ezq9l.jpg" alt="42437851d3658d1208612eb74b4d3a92"></p>
<p><strong>成品组装图（安装各接插件时，请务必参考成品图，不要弄错方向，否则可能烧坏MCU）</strong></p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1gjbbekmz7rj30yf0rs7f6.jpg" alt="018ddcf5a7f3944b38bb12a9837df72a"></p>
<p>好啦~接下来开始我们的制作！</p>
<h1 id="TOS-EVB-G0开发板"><a href="#TOS-EVB-G0开发板" class="headerlink" title="TOS_EVB_G0开发板"></a>TOS_EVB_G0开发板</h1><h2 id="开发板特性"><a href="#开发板特性" class="headerlink" title="开发板特性"></a>开发板特性</h2><p>TOS_EVB_G0 开发板是由腾讯TencentOS-tiny团队设计的一款物联网开发板，板载资源如下：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbbomftm9j30q50ifdmi.jpg" alt="45564fdbaf9f5d00ddfda2927c9e6555"></p>
<ul>
<li>主控芯片采用STM32G070RB，Flash空间仅有128KB、RAM空间仅有20KB；</li>
<li>板载腾讯云定制固件版ESP8266 WIFI模组；</li>
<li>板载E53传感器标准接口，方便连接各种E53传感器；</li>
<li>板载0.91’OLED显示屏幕；</li>
<li>板载8MB SPI Flash，可用于固件升级；</li>
<li>板载CH340 转串口连接，可以使用一根USB线连接至电脑，查看串口日志；</li>
</ul>
<p>下面是每部分详细的说明。</p>
<h2 id="开发板硬件电路详解"><a href="#开发板硬件电路详解" class="headerlink" title="开发板硬件电路详解"></a>开发板硬件电路详解</h2><h3 id="最小系统电路"><a href="#最小系统电路" class="headerlink" title="最小系统电路"></a>最小系统电路</h3><p>最小系统部分由电源电路、时钟电路、Boot电路、复位电路、下载电路组成：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbbp29727j30p50j7wkh.jpg" alt="2020091215453594"></p>
<h3 id="WIFI电路"><a href="#WIFI电路" class="headerlink" title="WIFI电路"></a>WIFI电路</h3><p>WIFI部分包括ESP8266 WIFI模组供电电路、串口通信电路：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbbpduzroj30mk086dha.jpg" alt="20200912154639745"></p>
<h3 id="E53扩展接口电路"><a href="#E53扩展接口电路" class="headerlink" title="E53扩展接口电路"></a>E53扩展接口电路</h3><p>E53扩展接口供外部传感器连接，包括：一个串口、一个SPI接口、一个IIC接口、四个普通GPIO口、一个ADC模拟采集接口，一个DAC模拟输出接口，如图：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbbpmwze3j30kx081abv.jpg" alt="20200912154756810"></p>
<h3 id="USB转串口电路"><a href="#USB转串口电路" class="headerlink" title="USB转串口电路"></a>USB转串口电路</h3><p>USB转串口电路将串口信息转换为USB口信号，使得开发板可以直接通过USB线连接至PC，在PC上使用串口助手查看日志：</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbbpyhet5j30ln08rdho.jpg" alt="20200912155018316"></p>
<h3 id="OLED显示屏幕电路"><a href="#OLED显示屏幕电路" class="headerlink" title="OLED显示屏幕电路"></a>OLED显示屏幕电路</h3><p>OLED屏幕部分包括OLED供电部分和通信部分：</p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1gjbbq9oz4qj30gz0euabt.jpg" alt="20200912155131688"></p>
<h3 id="连接Micor-USB线"><a href="#连接Micor-USB线" class="headerlink" title="连接Micor USB线"></a>连接Micor USB线</h3><p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbbrf5ss6j31130o9wqn.jpg" alt="a00746e285381da66af9f9eb4b556078"></p>
<h3 id="连接ST-Link下载器"><a href="#连接ST-Link下载器" class="headerlink" title="连接ST-Link下载器"></a>连接ST-Link下载器</h3><p>开发板3v3—&gt; STlink  3.3V<br>开发板DIO—&gt; STlink  SWDIO<br>开发板CLK—&gt; STlink  SWCLK<br>开发板GND—&gt; STlink  GND<br><strong>请大家参考下图进行连接，千万不要接反接错，以免烧掉MCU</strong></p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbbroxdcoj30yj0llai9.jpg" alt="4ab5937dd0221e4ad1b0109b2f028aa1"></p>
<h2 id="开发板软件环境准备"><a href="#开发板软件环境准备" class="headerlink" title="开发板软件环境准备"></a>开发板软件环境准备</h2><h3 id="MDK软件介绍"><a href="#MDK软件介绍" class="headerlink" title="MDK软件介绍"></a>MDK软件介绍</h3><p>MDK 即RealView MDK 或MDK-ARM（Microcontroller Development kit），是 ARM 公司收购Keil公司以后，基于uVision界面推出的针对ARM7、ARM9、Cortex-M0、Cortex-M1、Cortex-M2、Cortex-M3、Cortex-R4等ARM处理器的嵌入式软件开发工具。MDK-ARM 集成了业内最领先的技术，包括 uVision4 集成开发环境与 RealView 编译器RVCT。支持 ARM7、ARM9 和最新的Cortex-M3/M1/M0 核处理器，自动配置启动代码，集成 Flash 烧写模块，强大的 Simulation 设备模拟，性能分析等功能，与 ARM 之前的工具包 ADS 等相比，RealView 编译器的最新版本可将性能改善超过 20%。</p>
<p>Keil公司开发的ARM开发工具MDK，是用来开发基于ARM核的系列微控制器的嵌入式应用程序。它适合不同层次的开发者使用，包括专业的应用程序开发工程师和嵌入式软件开发的入门者。MDK包含了工业标准的Keil C编译器、宏汇编器、调试器、实时内核等组件，支持所有基于ARM的设备，能帮助工程师按照计划完成项目。</p>
<h3 id="MDK安装"><a href="#MDK安装" class="headerlink" title="MDK安装"></a>MDK安装</h3><p>登录MDK官网，下载MDK5软件，下载地址：<br><a target="_blank" rel="noopener" href="http://www2.keil.com/mdk5">http://www2.keil.com/mdk5</a>  或者 <a target="_blank" rel="noopener" href="https://www.keil.com/download/product/">https://www.keil.com/download/product/</a></p>
<p>下载的版本最好在5.24以上，本开发教程以5.24版本为例，双击MDK524应用程序文件，点击next&gt;&gt;。</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbbs6hh9nj30kg0cx0t2.jpg" alt="20200912160353792"></p>
<p>打上 I agree前面的勾勾，即是同意一些安装协议。点击next&gt;&gt;。</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbbsjtnvlj30kg0cxdgt.jpg" alt="20200912160415757"></p>
<p>选择安装路径，可以默认也可以安装在我们自己建立的文件夹下。点击next&gt;&gt;。</p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1gjbbswaeuwj30kg0cx3yt.jpg" alt="20200912160425324"></p>
<p>这里填写的是我们的一些信息，填写完整后，继续next&gt;&gt;。</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbbt5639gj30kg0cx3ys.jpg" alt="20200912160432240"></p>
<p>然后等待安装完成即可。</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbbtgo3vcj30kg0cx74i.jpg" alt="20200912160448600"></p>
<p>安装完成，点击Finish。</p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1gjbbtv29igj30kg0cx74j.jpg" alt="20200912160455488"></p>
<p>然后会跳出来这个界面，这个我们后面再讲，先点OK，把弹框都叉掉。</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbbxcj2koj30p60hsgp1.jpg" alt="20200912160508347"></p>
<p>激活MDK，导入License,激活MDK后便可使用了。</p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1gjbbxmbklyj30p108w3zt.jpg" alt="20200912160520293"></p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbby5t4w0j30lj0gs407.jpg" alt="202009121605276"></p>
<p>这个当然就是用个注册机搞一下啦</p>
<h3 id="MDK安装-1"><a href="#MDK安装-1" class="headerlink" title="MDK安装"></a>MDK安装</h3><p>安装完MDK后，我们需要安装开发套件中单片机型号对应的Pack。<br><strong>安装方式一</strong>  登录官网：<a target="_blank" rel="noopener" href="http://www.keil.com/dd2/pack/">http://www.keil.com/dd2/pack/</a> </p>
<p>下载Keil.STM32G0xx_DFP.x.x.x.pack 后安装。</p>
<p><strong>安装方式二</strong>  MDK软件上在线安装</p>
<p>打开软件，在导航栏打开Pack安装界面，然后选择ok选项。</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbbyw79lkj30p10bbjsj.jpg" alt="20200912160604878"></p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbbz685vcj30fp0ao74o.jpg" alt="20200912160612930"></p>
<p>进入在线安装界面，选着STM32G0XX Pack,点击Install进行安装。</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbbzkkcofj31400mi77i.jpg" alt="20200912160628442"></p>
<p>至此，我们开发板的单片机程序开发环境已经搭建完毕，重启MDK软件就可以使用了。</p>
<h3 id="ST-Link驱动安装"><a href="#ST-Link驱动安装" class="headerlink" title="ST-Link驱动安装"></a>ST-Link驱动安装</h3><p>前面讲了开发板单片机程序的开发环境的搭建，但是为了将程序烧录到开发板中我们还需要使用仿真器。我们这套开发板选用ST公司的ST-Link V2仿真器进行开发板程序的烧写和仿真，下面介绍ST-Link驱动的安装及环境搭建。<br>在ST官网下载ST-Link驱动，<br><a target="_blank" rel="noopener" href="https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html">https://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-utilities/stsw-link009.html</a></p>
<p>（驱动有2种： 32位电脑系统安装“dpinst_x86”、64位电脑系统安装“dpinst_amd64”）。 </p>
<p>运行对应的驱动，安装ST-Link V2驱动程序。安装路径尽量保持默认路径。</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbc03cmn7j30hv0eagnb.jpg" alt="20200912160951881"></p>
<p>安装完成后, 将ST-Link通过USB接口连入电脑。打开“设备管理器”。若看到如下图所示，表示驱动安装成功。</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbc0jc57gj30lp0fwt9o.jpg" alt="20200912163834675"></p>
<p>这里提醒 2 点:<br>1，    各种 windows 版本设备名称和所在设备管理器栏目可能不一样，例如 WIN10 插上STLINK 后显示的是 STM32 STLINK。<br>2，    如果设备名称旁边显示的是黄色的叹号，请直接点击设备名称，然后在弹出的界面点击更新设备驱动<br>至此， ST-Link 驱动已经安装完成。接下来大家只需要在 MDK工程里面配置一下 ST-Link即可。</p>
<h3 id="CH340串口驱动安装"><a href="#CH340串口驱动安装" class="headerlink" title="CH340串口驱动安装"></a>CH340串口驱动安装</h3><p>互联网搜索下载CH340 串口芯片的驱动<br>安装方法：打开驱动安装程序点击安装即可。</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbc14xlykj30kz02o0sm.jpg" alt="20200912161124298"></p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbc1beds3j30bo07kglu.jpg" alt="20200912161131269"></p>
<p>注：若安装失败，请先点击卸载，后点击安装。</p>
<h3 id="串口调试助手的安装与使用"><a href="#串口调试助手的安装与使用" class="headerlink" title="串口调试助手的安装与使用"></a>串口调试助手的安装与使用</h3><p>工具下载： <a target="_blank" rel="noopener" href="http://www.daxia.com/download/sscom.rar">http://www.daxia.com/download/sscom.rar</a></p>
<p>安装方法：串口调试助手sscom5.13.1是免安装的，解压出压缩包即可直接使用。</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbc1kj0lij30s80iy422.jpg" alt="20200912161144942"></p>
<p>根据PC和终端之间的连接，选择正确的串行端口。<br>打开电脑的设备管理器，在端口列表可以看到PC与开发板连接的端口号。</p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1gjbc20nvcbj30lp0fwdgs.jpg" alt="20200912163536203"></p>
<p>我这里显示的是COM26，所以要在sscom工具中选择COM26，开发板程序波特率设置为115200，所以我在sscom串口工具中选择115200波特率。</p>
<h1 id="烧写腾讯云定制固件"><a href="#烧写腾讯云定制固件" class="headerlink" title="烧写腾讯云定制固件"></a>烧写腾讯云定制固件</h1><h2 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h2><p>腾讯云IoT AT指令是一套针对使用通讯模组（2G/4G/NB/WIFI）接入腾讯云物联平台的定制AT指令集，如果通讯模组实现了该指令集，则设备接入和通讯更为简单，所需代码量更少。 ESP8266作为IoT领域使用最广泛的一款WiFi芯片/模组，腾讯云在其通用AT指令基础上，增加了腾讯云IoT AT指令集，形成一个定制的模组固件QCloud_IoT_AT_ESP8266。</p>
<p>下载链接：<a target="_blank" rel="noopener" href="https://github.com/tencentyun/qcloud-iot-esp-wifi">https://github.com/tencentyun/qcloud-iot-esp-wifi</a></p>
<p>使用git下载的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tencentyun/qcloud-iot-esp-wifi.git</span><br></pre></td></tr></table></figure>

<p>下载之后即可在图中圈出的文件夹中看到定制固件：</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbc2dn8pcj30gx04ydg1.jpg" alt="20200912164445221"></p>
<h2 id="下载烧写工具"><a href="#下载烧写工具" class="headerlink" title="下载烧写工具"></a>下载烧写工具</h2><p>使用乐鑫官方下载工具ESPFlashDownloadTool，下载链接如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.espressif.com/zh-hans/support/download/other-tools">https://www.espressif.com/zh-hans/support/download/other-tools</a></p>
<p>点击下载Flash 下载工具（ESP8266 &amp; ESP32 &amp; ESP32-S2）：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbc3hifeoj30py059jri.jpg" alt="20200912170728154"></p>
<p>下载之后解压即可。</p>
<h2 id="固件说明"><a href="#固件说明" class="headerlink" title="固件说明"></a>固件说明</h2><p>腾讯云IoT定制的AT模组固件QCloud_IoT_AT_ESP8266，适用于所有FLASH大小为2MB或者2MB以上的ESP8266模组。</p>
<p>AT串口使用UART0，默认的Tx为GPIO1，Rx为GPIO3。但因为ESP8266的UART0 默认会在上电启动期间输出一些打印，如果打印信息影响设备功能，可在上电期间将 U0TXD(GPIO1)、U0RXD(GPIO3) 分别与 U0RTS (GPIO15)，U0CTS(GPIO13)进行交换，以屏蔽打印。因此提供两个版本的固件：</p>
<ul>
<li>名称包含UART_1_3的固件串口使用的Tx为GPIO1，Rx为GPIO3。</li>
<li>名称包含UART_15_13的固件串口使用的Tx为GPIO15，Rx为GPIO13。</li>
</ul>
<p>进入QCloud_IoT_AT_ESP8266_FW，本文中我们使用第一个固件：</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbc3v49ldj30kn03774c.jpg" alt="20200912164714338"></p>
<h2 id="烧写固件"><a href="#烧写固件" class="headerlink" title="烧写固件"></a>烧写固件</h2><h3 id="切换boot选择端子和串口选择端子"><a href="#切换boot选择端子和串口选择端子" class="headerlink" title="切换boot选择端子和串口选择端子"></a>切换boot选择端子和串口选择端子</h3><p>① 将开发板上的ESP8266启动引脚配置端子切换到低电平；</p>
<p>② 将开发板上的串口选择端子置于中间，使ESP8266直接与PC串口连接：</p>
<p>方法参考下图：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbc47h0itj30zk0qotk3.jpg" alt="733a1c7406bcc2621e751ca07f0be0f7"></p>
<h3 id="运行Flash烧写工具"><a href="#运行Flash烧写工具" class="headerlink" title="运行Flash烧写工具"></a>运行Flash烧写工具</h3><p>双击工具，运行：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbc5mavm9j30in068t90.jpg" alt="2020091217093379"></p>
<p>选择开发者模式：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbc627n77j307y07lq2t.jpg" alt="20200912171110420"></p>
<p>选择ESP8266下载工具：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbc7a4wqgj307y0f3dfw.jpg" alt="20200912171139314"></p>
<h3 id="开始下载"><a href="#开始下载" class="headerlink" title="开始下载"></a>开始下载</h3><p>按照图中进行操作：+</p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1gjbc7m17bmj30f40iumyb.jpg" alt="20200912171454660"></p>
<p>点击下载之后，按下开发板上的复位键，Flash下载工具开始下载：</p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1gjbc7uhbh4j30f40iuab6.jpg" alt="20200912171547158"></p>
<p>若没有显示，请检查接线端子是否连接正确。</p>
<h3 id="下载完成"><a href="#下载完成" class="headerlink" title="下载完成"></a>下载完成</h3><p>下载完成之后如图：</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbc8cuuhij30f40iu0tu.jpg" alt="20200912171748705"></p>
<p>关闭工具，将boot选择引脚拔下，将串口选择端子恢复默认。</p>
<p><strong>注意：完成固件下载后，一定切记将跳线端子恢复到默认状态，默认端子怎么短接可以参考前面完整的组装成品图，否则wifi将没法工作，MCU也没法控制wifi。</strong></p>
<h1 id="基于TencentOS-tiny接入腾讯云IoT-Explorer指引"><a href="#基于TencentOS-tiny接入腾讯云IoT-Explorer指引" class="headerlink" title="基于TencentOS tiny接入腾讯云IoT Explorer指引"></a>基于TencentOS tiny接入腾讯云IoT Explorer指引</h1><p>基于TencentOS Tiny EVB G0要完成腾讯云IoT Explorer对接，需要完成两个部分的工作。<br>一是：腾讯云IoT explorer 上完成项目、产品、设备创建、参数配置<br>二是：基于TencentOS Tiny完成应用开发，向腾讯云上报业务数据。</p>
<h2 id="云端操作步骤"><a href="#云端操作步骤" class="headerlink" title="云端操作步骤"></a>云端操作步骤</h2><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>登录<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/iotexplorer">腾讯云物联网开发平台</a>，点击新建项目，填写项目名称和简介：</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbc917aq6j30ga09xmx9.jpg" alt="20200912184744294"></p>
<h3 id="新建产品"><a href="#新建产品" class="headerlink" title="新建产品"></a>新建产品</h3><p>点击项目名称进入到该项目中，点击新建产品：</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbc99ra4cj30hb0g8aaj.jpg" alt="20200912184815961"></p>
<p>产品新建成功后，可在产品列表页查看到：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbc9i1kpnj31240g3dgb.jpg" alt="20200912184830658"></p>
<h3 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h3><p>进入产品，点击【数据模板】，点击【导入JSON】，导入下面的JSON代码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;profile&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;ProductId&quot;</span>: <span class="string">&quot;BDDSF87WEA&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;CategoryId&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;ch20_ppm_value&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;甲醛浓度值&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;r&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;define&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;float&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;min&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;max&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;step&quot;</span>: <span class="string">&quot;0.001&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;ppm(mg/m3)&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;required&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;events&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;actions&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入之后自动根据json文件创建的属性如下：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbc9rmyj3j31270gcdhb.jpg" alt="20200912184912590"></p>
<h3 id="创建设备"><a href="#创建设备" class="headerlink" title="创建设备"></a>创建设备</h3><p>点击【设备调试】，进入后点击【新建设备】，创建真实设备：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbca26ajrj30gf06t74a.jpg" alt="20200912184935188"></p>
<p>创建成功之后进入设备，查看到产品ID、设备名称、设备秘钥：</p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1gjbcahje8pj312a0i5gmo.jpg" alt="20200912185005892"></p>
<h2 id="基于TencentOS-Tiny-完成设备侧应用开发"><a href="#基于TencentOS-Tiny-完成设备侧应用开发" class="headerlink" title="基于TencentOS Tiny 完成设备侧应用开发"></a>基于TencentOS Tiny 完成设备侧应用开发</h2><p>进入 &lt; TencentOS-tiny\board\TencentOS_tiny_EVB_G0\KEIL\mqtt_iot_explorer_tc_ch20_oled&gt; 目录，打开TencentOS_tiny.uvprojx工程。</p>
<h3 id="修改WIFI接入信息"><a href="#修改WIFI接入信息" class="headerlink" title="修改WIFI接入信息"></a>修改WIFI接入信息</h3><p>打开<code>mqtt_iot_explorer_tc_ch20_oled.c</code>文件编辑，修改要接入WIFI的名称和密码（建议使用手机热点，不要有特殊字符）：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbcasxfi2j30no079gm1.jpg" alt="20200912190022439"></p>
<h3 id="修改云端对接信息"><a href="#修改云端对接信息" class="headerlink" title="修改云端对接信息"></a>修改云端对接信息</h3><p>同样在此文件宏，修改云端配置信息，使用之前在云端查看的信息替换：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbcb0a0ewj30nr06b3yx.jpg" alt="20200912190253688"></p>
<h3 id="编译工程"><a href="#编译工程" class="headerlink" title="编译工程"></a>编译工程</h3><p>点击编译按钮，编译整个工程：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbcbbhza1j30rj0cdgmq.jpg" alt="20200912190501209"></p>
<h3 id="下载程序"><a href="#下载程序" class="headerlink" title="下载程序"></a>下载程序</h3><p>点击进入工程配置界面按纽，进入工程配置界面：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbce4mx3tj30o907ymxv.jpg" alt="20200912163002371"></p>
<p>选择Debug选项，进入仿真器设置界面。</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbccft5igj30he0d2aas.jpg" alt="20200912163019926"></p>
<p>下拉仿真器选择列表，选着ST-Link Debugger并勾选右侧Use,点击Settings进入ST-Link V2仿真器配置界面。</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbccows5oj30he0d2750.jpg" alt="20200912163044635"></p>
<p>开发板设计的程序烧录方式为SW，此处Unit选择ST-Link/V2,且Port选择SW,并确认右侧框内是否检测出SW设备，点击&lt;确认&gt;保存配置。</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbccx2cf4j30ll0hkdgy.jpg" alt="20200912163441583"></p>
<p>点击确定之后，回到主界面，点击下载按钮：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbcdacpa4j30r50cggmp.jpg" alt="20200912190649662"></p>
<h3 id="使用串口助手查看日志"><a href="#使用串口助手查看日志" class="headerlink" title="使用串口助手查看日志"></a>使用串口助手查看日志</h3><p>运行sscom软件，打开电脑上开发板对应的串口，比如我选择COM26，点击【打开串口】：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbceiv2wdj30rx0iyjsf.jpg" alt="20200912190944961"></p>
<p>按下开发板上的复位键，程序开始运行，即可在串口助手中看到系统运行打印的日志：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbceteicsj30rx0iyjso.jpg" alt="20200912191505807"></p>
<h2 id="云端平台查看设备数据"><a href="#云端平台查看设备数据" class="headerlink" title="云端平台查看设备数据"></a>云端平台查看设备数据</h2><p>回到腾讯云物联网开发平台，可以看到设备状态变为【在线】：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbcf2ibhfj312g0icwfk.jpg" alt="20200912191641250"></p>
<p>点击【设备日志】一栏，可以看到设备上报的甲醛浓度值：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbcf9fcqtj31330idgn5.jpg" alt="20200912191715619"></p>
<p>点击【设备属性】一栏，点击【甲醛浓度值】后的【查看】，即可看到甲醛浓度值的历史数据曲线图：</p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1gjbcflgzcqj30ld0fd0t4.jpg" alt="20200912191807508"></p>
<h1 id="腾讯连连小程序操作步骤"><a href="#腾讯连连小程序操作步骤" class="headerlink" title="腾讯连连小程序操作步骤"></a>腾讯连连小程序操作步骤</h1><h2 id="添加家庭"><a href="#添加家庭" class="headerlink" title="添加家庭"></a>添加家庭</h2><p>手机端在【微信】搜索【腾讯连连】小程序，首次使用需要进入后点击【我的】-&gt;【家庭管理】，添加一个你喜欢的名称即可。</p>
<h2 id="添加调试设备"><a href="#添加调试设备" class="headerlink" title="添加调试设备"></a>添加调试设备</h2><p>返回【首页】，点击右上角“加号”图标：</p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1gjbcftz3wfj30as0kptah.jpg" alt="20200912192517415"></p>
<p>进入后点击右上角扫码图标：</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbcg0m7anj30l10dat9j.jpg" alt="20200912192742454"></p>
<p>在腾讯云物联网开发平台进入【设备调试】，点击对应设备后的【二维码】：</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1gjbcg814lej312a0gytai.jpg" alt="20200912192809377"></p>
<p>腾讯连连扫描此二维码即可成功添加设备，添加成功之后如图：</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbcgfb3gaj30gl0d23z9.jpg" alt="20200912192913964"></p>
<p>点击此设备即可实时查看数据，并下发控制指令：</p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1gjbcgnkhtkj30gv07cmxe.jpg" alt="20200912192848552"></p>
<h2 id="修改腾讯连连显示面板"><a href="#修改腾讯连连显示面板" class="headerlink" title="修改腾讯连连显示面板"></a>修改腾讯连连显示面板</h2><p>进入【交互开发】，点击【面板配置】一栏：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbch4mpw0j312l0l2q44.jpg" alt="20200831165713961"></p>
<p>在此页面中可以自己根据喜好配置小程序显示面板，如图：</p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1gjbchciyx9j311w0j1jsh.jpg" alt="20200912193005903"></p>
<p>保存之后，在腾讯连连小程序删除设备，重新扫描绑定设备即可生效。</p>
<h1 id="腾讯连连公众号报警操作步骤"><a href="#腾讯连连公众号报警操作步骤" class="headerlink" title="腾讯连连公众号报警操作步骤"></a>腾讯连连公众号报警操作步骤</h1><h2 id="创建数据流"><a href="#创建数据流" class="headerlink" title="创建数据流"></a>创建数据流</h2><p>点击左侧【数据开发】一栏，点击【新建数据流】：</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbchtblfuj30m40enq3g.jpg" alt="2020091219331529"></p>
<p>填写数据流名称：</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1gjbciggb6aj30ge09w0su.jpg" alt="20200912193256498"></p>
<h3 id="设计数据流"><a href="#设计数据流" class="headerlink" title="设计数据流"></a>设计数据流</h3><p>添加并设置【设备数据】节点：</p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1gjbcitng5gj31h20k4tc2.jpg" alt="20200912193549171"></p>
<p>添加并设置【过滤节点】：</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbcje6j92j31h10gen07.jpg" alt="2020091219380427"></p>
<p>添加并设置【推送节点】：</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbcjt5tksj31gw0fy41k.jpg" alt="20200912194159284"></p>
<h3 id="启动数据流"><a href="#启动数据流" class="headerlink" title="启动数据流"></a>启动数据流</h3><p>设计完成后，点击【保存按钮】，再点击【启用】：</p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbck4z27kj31gx0g3jud.jpg" alt="2020091219430620"></p>
<h3 id="关注腾讯连连公众号"><a href="#关注腾讯连连公众号" class="headerlink" title="关注腾讯连连公众号"></a>关注腾讯连连公众号</h3><p>在微信关注【腾讯连连】公众号：</p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1gjbckd18qyj30k80btjt3.jpg" alt="20200912194547820"></p>
<p>关注后，如果有任何告警消息，即可在公众号接收到。</p>
<blockquote>
<p>如果仅仅为了测试告警功能，可以先将告警值设较小的值，比如设为0.070，测试完成之后再恢复国家规定标准0.80。</p>
</blockquote>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1gjbckjc7l1j30ab0juabh.jpg" alt="20200912195158767"></p>
<p>至此，基于TencentOS-tiny的甲醛监测仪制作完成。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/02/iot/" data-id="ckw9lgzz900242ww5cc7y3umc" data-title="腾讯物联网-甲醛检测" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DIY/" rel="tag">DIY</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-gujian" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/12/07/gujian/" class="article-date">
  <time class="dt-published" datetime="2019-12-07T08:59:38.000Z" itemprop="datePublished">2019-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/12/07/gujian/">古剑奇谭三</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天，古剑奇谭三终于通关了。<br>听着巫之国的BGM，内心总有些空荡荡的，一如当年玩仙剑四。非常感谢烛龙，给我们带来了这么棒的国产ARPG游戏。</p>
<p>我的RPG游戏起点是仙剑一，当时我还是在上小学五年级。</p>
<img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1giw2utsszwj30go0aidhg.jpg" alt="gujian3" style="zoom:120%;" />

<p>在玩仙剑一之前，我只玩过蜘蛛纸牌一类的小游戏，4399上的一些小游戏都能让我沉迷许久。不过可惜的是，我家的电脑坏了，爸妈也没去修，玩电脑游戏也就仅限于电脑课上的一些小游戏了。直到有一次，爸妈都要出差，把我放在老爸的同事家住了两天，同事家的哥哥当时正好在玩仙剑一，我也因此第一次接触仙剑系列游戏。老实说我对当时的游戏画风其实已经没有多少印象了，现在找来图片发现画质真的很差哎，像素画质，可对于当时的我来说，这已经是无与伦比的游戏了。第一次玩RPG游戏，每一个部分都让我感到新奇——走迷宫、看故事、打boss等等，最让我沉迷的是用“飞龙探云手”这个技能去偷boss的宝物，每次能偷到一些名字很高大上的宝物我都特别开心，那种喜悦仅限于那个年纪的我，之后我再玩仙剑六的时候，虽然也有这种技能，但是当时的兴奋却早已不再。还有李逍遥的各种技能，当时也是能如数家珍地一一道来，尤其是万剑诀，虽然是很初级的技能，但是当游戏里许多把剑从天而降，击中boss时，感觉真的超级有仙侠之气。</p>
<p>再后来玩的好像是仙剑三外传问情篇，那是我在奶奶家过暑假，堂哥带回来了一台笔记本电脑，他当时就在玩这个。我和堂弟就每天一左一右地坐在他旁边，看他玩。仙剑三外传现在看来画质也是和小游戏一般，模型建的很粗糙，但是对于当时的我来说，游戏的沉浸感已经非常之高了。毕竟当时在奶奶家，每天其实有趣的事情并不多，每天就是看看电视，出去田里玩一玩，一个RPG游戏对当时的我来说，吸引力可想而知。当时的游戏内容已经不记得许多了，只记得男主叫南宫煌，最后也没看完全部剧情，等到再次有机会玩这个游戏的时候，已经开始嫌弃它的画质了。</p>
<img src="https://tva1.sinaimg.cn/large/006ESCTwgy1giw2vfrzkzj30dw0aft9r.jpg" alt="gujian4" style="zoom:120%;" />

<p>再之后便是大学了，偶然间回忆起仙剑游戏，看了网上风评最好的仙剑四，觉得实在不能错过这么棒的一部仙剑系列，于是我在b站把剧情视频看了一遍，确实很伤感，为菱纱难过了好久，还好我是看的视频不是玩的游戏，不然沉浸感更高，玩完游戏更难受。仙剑系列似乎都是这样，老是喜欢在一个团圆美好的夜晚之后，开启一个大虐的结局，赚取玩家的眼泪。</p>
<img src="https://tva2.sinaimg.cn/large/006ESCTwgy1giw2vrx2f4j30lc0g03zr.jpg" alt="gujian5" style="zoom: 90%;" />

<p>后来啊，仙剑六出了。</p>
<img src="https://tva4.sinaimg.cn/large/006ESCTwgy1giw2vzv6haj30dc078abc.jpg" alt="gujian2" style="zoom:150%;" />

<p>人生第一次买游戏的经历给了仙剑六，毕竟之前的RPG游戏历程都是仙剑给的，还是比较相信仙剑的口碑。老实说，玩了以后并没有像网上那样一边倒的差评，我个人感觉还是可以的，可能原因是我在拿仙剑六和仙剑的前几部比较，至少在建模上要好很多了，至于优化的问题，我当时都认为是我的电脑太菜了，虽然玩的时候帧率确实很低，但是我都把锅甩给我的辣鸡联想笔记本电脑了，不过现在玩了古剑三后，是彻底知道仙剑六的优化是真的差劲了。仙剑六的另一个缺点是废话太多，剧情过于拖沓，我当时就和室友开玩笑说，这个游戏我买来就是用来当做长篇动漫来看的，你看他3D游戏里还加了2D过场动画，这不就是2.5D动漫么。后来也不记得打到哪里了，中间一停就再也没玩过了。最大的原因是仙剑六的那个平台，弄得我换电脑得重新激活，很麻烦，最后也就不了了之了。</p>
<p>仙剑六之后，不知怎的，我在steam上买了古剑一二的合集，虽说古剑一和仙剑四差不多年份做的，但是当时觉得古剑一的画质好像要好一点点。古剑一是我玩的时间最多的steam游戏，一共玩了46小时。论进度，其实比仙剑六的进度玩的还多，犹记得当时在铁柱观打狼狗的那一场，一直打一直死，怎么都打不过去，当时晚上玩到十二点，就是气不过，非要打过去才肯睡觉，然后，emmmm，两三点想起第二天还有课，放弃过关先睡了……古剑一最后其实也没有玩完，不记得因为什么事情停下来了，一停就再难继续了。 古剑二买了没怎么玩，毕竟画质没有什么很大的提升。作为一个颜控，就是要超级逼真的画质才能提起我的兴趣。</p>
<p>这时，古剑三开售了。</p>
<img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1giw2ugqtepj30sg0g0q4r.jpg" alt="gujian1" style="zoom:80%;" />

<p>当时我就直接预订了，画质真的非常棒，尤其是国产RPG游戏，能做到这个程度的美工，已经实属不易了。古剑三是我第一个完整通关了的游戏，而且虽然我中途也因为其他的一些事停了两个月没有玩，但是最后还是接着玩并最后通关了。</p>
<p>详细说说古剑三吧。古剑三其实很不一样，历代仙剑其实都有一段情缘作为主线，无论是仙剑一的李逍遥、赵灵儿和林月如，还是仙剑四的云天河和韩菱纱，或是仙剑六的越今朝和越祈，用爱情赚取眼泪总是容易而又有效的，古剑三其实没有多少爱情在其中，云无月和北洛的爱情其实点到为止，</p>
<img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1giw2w7k7ujj30lc0c0t9t.jpg" alt="gujian6" style="zoom:100%;" />

<p>而且其实更主要是云无月和缙云的爱情，爱情不再是主题，古剑三靠什么来赢得口碑，其实我也说不清，因为玩游戏过程中要断断续续地打怪，还要去家园种菜，剧情其实不太连贯了，或许我以后再看一遍剧情视频会更了解，但是现在就只说说我的感受。我更沉浸于古剑三的故事中，这是一种将神话故事写实地表现在你眼前的感受。我以前一直很喜欢黄帝时期的神话，小学的时候读过一本小说，已经完全不记得书名了，只记得主角叫做少典，也是那个时期的人物，讲了当时他们原始部落的神话，从那以后，我对这个时期的故事就比其他历史时期的故事更感兴趣。古剑三恰好就是讲这个时期的故事，古剑三里对于西陵和黄帝生活的部落的模型建模非常棒，就像是小说里曾经只能靠自己幻想出来的场景复现了一般，自己操控着北洛在其中穿行，看着那个时候的人在做一些原始部落里的活动，特别有沉浸感。我是一个怀旧的人，我喜欢听过去的故事，因为这些故事里，往往一段文字就是一个人的一生，那种一瞬间就经历人生数十年的感觉，让我沉迷。</p>
<p>其实聊古剑三还有很多角度，古剑三在很多地方都非常优秀，比如他的家园系统、皮影戏那一段游戏、精致的美工等等，都让这个游戏的可玩性得到很大的提升，只是刚通关的我还停留在那个故事里。其实我觉得古剑三并不能算是一个仙侠游戏，我觉得可能是“写实神幻侠客游戏”，一开场的天鹿城其实我是很陌生的，感觉就像是北欧风格神话游戏一样，但是后来看到熟悉的客栈等中国风元素又适应回来了。侠客仍然作为国产RPG游戏的魂，正如警匪之于香港电影一样，必不可少。其实我有时也会想，未来国产RPG游戏的出路在哪，写一个更凄美的爱情剧本，还是更精致的模型？我期待游戏制作人给我们带来更多的惊喜。</p>
<p>沉浸感，我不止一次地提到了这个词。对我来说，这个词是我评价一个RPG游戏好坏的最终指标。更精致的模型，更好的操控系统，更丰富的游戏玩法都能增加游戏的沉浸感。还有一点也不得不提，那就是音乐。我一直觉得，仙剑系列古剑系列能有这么长久以来的辉煌，骆集益周志华两位音乐制作人居功至伟，他们做的背景音乐极大地提升了游戏的沉浸感，甚至出了游戏，一听到这个背景音乐，游戏剧情又会翻涌而来，思绪万千，情绪涌上心头。蝶恋就是最好的例子。</p>
<p>从仙剑一到古剑三，国产RPG游戏伴随了我的青春，我不太喜欢LOL或是DOTA那些竞技类的游戏，双剑系列的游戏才是让我沉浸其中无法忘怀的。</p>
<img src="https://tva4.sinaimg.cn/large/006ESCTwgy1giw44zwhv1j30sg0g04jr.jpg" alt="gujian7"  style="zoom:100%;">
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/07/gujian/" data-id="ckw9lgzx4000e2ww58z725hxw" data-title="古剑奇谭三" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag">游戏</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Taiwan2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/17/Taiwan2/" class="article-date">
  <time class="dt-published" datetime="2018-07-17T10:27:39.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/17/Taiwan2/">Taiwan（2）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="2018-07-16第2天"><a href="#2018-07-16第2天" class="headerlink" title="2018-07-16第2天"></a>2018-07-16第2天</h3><p>早餐这个真的蛮贵的，这是一个香肠的刈包，里面就是一点咸菜和香肠，加上一杯豆浆要55新台币，11人民币了，好贵啊，可能我们去错了餐厅，早上在小吃部吃的，这里除了这个就只有汉堡鸡排了，最有趣的是，我一开始也不知道“刈”字怎么读，还查了一下读音，然后，同学来问我这字怎么念的时候，我突然顺口而出“观刈麦的刈”，都没有经过思考hhh，大概是在别人问我的时候，我的智商就会突然上升吧。</p>
<p><img src="https://tva2.sinaimg.cn/large/006ESCTwgy1giw4zm8gh4j30qo0zk40d.jpg" alt="photo_2018_07_17_813712b390b0cc9341621ccc19aced21"></p>
<p>吃完早饭就去行政楼开会了，淑珍姐说了一些事项，然后各自的导师就派学长来领人了，接我的是庄智凯，他也是大三的。然后我们就去了台达馆，学校里的楼都是哪家公司捐钱就用的公司名来命名，比如还有旺宏馆。上海交大就是谁捐了钱用谁的名字，都是人名而非企业名。到那后导师在开group meeting，我也就在里面旁听了，上午是研究生的都是图像相关的，记得的几个有：在全景图片里找太阳（光源）的，根据图像找到公路的路口，根据全景图片构建3维的模型用于房子样板间的预览，条形码里添加企业logo同时保持条形码功能等等，真的好久啊，老师还蛮严肃的，感觉这个实验室的导师更贴合“老板”的称呼，他的态度基本就是我付你工资，你就要做出成果，你做出两  个project，我就付你double的salary，你平时不能以有课为由拖延项目进度，毕竟我是付你工资的。大约就这样。组会的时候比较有趣的是他们就是经常会中英文结合，就像上面我打的那样，不限于专业词汇，但是好像只是组会上会这样，我觉得还ok了，尤其是论文都是英文，中英结合会更方便表达自己的意思，之前知乎上还为此吵过，我是觉得，人家接触了这么多的英语环境，回国后不自觉地夹用英文完全ok啊，你非说人家装逼，这就是你的无知了。中午实验室订了披萨和鸡翅，实验室的人都在玩跑跑卡丁车，他们好像蛮喜欢这个游戏的，是PC版，不是手游。然后吃完他们确实是有分类的，主要就是厨余垃圾分开，寝室留下也有三个垃圾桶，不同分类的，然而晚上室友告诉我其实实际上他们也都不分类的hhh，然后下午就是本科生的组会了，比之研究生的，水平自然就要差很多，（当然我也很菜，都是菜鸡本科生）主要的区别是，研究生报告的时候基本都是说些思路上的问题，比如要怎么处理这种类别的图像思路这样的，而本科生就是报告自己遇到的bug，比如我这个unity project导出为UWP的时候运行不了啊，可能是不兼容啊，我查了什么什么资料。</p>
<p>晚饭吃的是鲁肉饭，hhh正宗台湾卤肉饭，在学校吃过很多回，这里味道也没什么差别，45新台币一碗价格和交大差不多。 </p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1giw509ed1ij30qo0zkjuv.jpg" alt="photo_2018_07_17_b9e7b49bde825ca65b1ca517c8bd9f4d"></p>
<p> 晚上在交谊厅看电视，也就是我们学校的宿舍楼下的党团活动室，只不过我们那变成了“党团自习室”了，而这里是娱乐聊天的地方，有电视旁边柜子里还有漫画（见下图），其中有《棋魂》，电视有一百来个台，有两个台感觉是大陆资助了hhh一个是中视，播新闻的时候上面一直显示“两岸一家亲”，新闻也多是批评蔡英文政府夸大陆的，另一个是东森，电视剧播的是大陆的，什么《琅琊榜》《楚乔传》啊，这里还有CNN的台，然后同学也来了，一起讨论了环台游的计划，暂定12天环台吧，还在规划路线，有俩个台湾小伙伴就靠谱多了。哦对了，想起了还有机车没说hhh，这里很多机车（烧油的两轮），外形接近电动自行车那种，声音很大，上海是不让骑的，这里所有骑机车的时候都是戴头盔的，大陆就很少有人戴。之后回寝室了，洗完衣服还有个脱水机可以用，感觉这里住宿条件还行，有脱水机、小冰箱、饮水机free还可用冰开水、洗澡也是free、洗衣2元人民币（交大4元）这几点吊打交大宿舍，但是这里的就是东西都比较旧，房子也很久，这点交大新校区吊打这里。 </p>
<p><img src="https://tva3.sinaimg.cn/large/006ESCTwgy1giw50nqwvyj30qo0k0taz.jpg" alt="photo_2018_07_17_f629201210fcc11298f06660d74f00db"></p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1giw50xkugwj30qo0k0whp.jpg" alt="photo_2018_07_17_ab86a2fd4f6d009e5d9c5f7dad99a624"></p>
<h3 id="2018-07-17第3天"><a href="#2018-07-17第3天" class="headerlink" title="2018-07-17第3天"></a>2018-07-17第3天</h3><p> 早上吃了台湾的方便面，居然没有叉子，查了一下台湾产的泡面都是没有叉子的。唉，于是去了711拿了一双一次性筷子。味道还行吧，有一点比较好的是，牛肉是真的牛肉，一块一块就跟在新余早上吃的牛肉粉里的牛肉那样，不像大陆泡面里的牛肉，就很假的样子，不知道他们是怎么做到这种牛肉保存的。听说台湾的“满汉全席”泡面很有名，改天买一盒试试。 </p>
<p><img src="https://tva4.sinaimg.cn/large/006ESCTwgy1giw52o1i4kj30qo0zkn4h.jpg" alt="photo_2018_07_18_d8390509ce60a6a93076b02b2b802ddb"></p>
<p> 这个是门外的饮水机，可以看到可以取冰水，很棒了，要是我们学校也有这种饮水机就好了，水是free的。 </p>
<p><img src="https://tva1.sinaimg.cn/large/006ESCTwgy1giw538hvjjj30qo0zkdk9.jpg" alt="photo_2018_07_18_76c66789996a98ad6a3f2c3970e97d94"></p>
<p>下午在实验室，上面这张图就是实验室的场景了，我坐在大姐和新手驾驶之间的位置上，这张图是从智凯的facebook里下载的，没好意思拍，和我在交大的实验室差不多，都是外围一圈，中间空的，下午没做啥，本来要做相机标定来着，但是等了一下午，贾隽最后也没能做好标定的图片发我，结果就是在实验室看了一下午的b站，查了下九份的旅行攻略。</p>
<p><img src="https://tvax4.sinaimg.cn/large/006ESCTwgy1giw53myxorj30qo0qotat.jpg" alt="photo_2018_07_18_8c0a3f4a52a31418d1f7303fa3ef43c1"></p>
<p> 下午，出来实验室后，一起约去新竹市区吃完饭和逛逛，先用学生证注册了ubike的功能，ubike就是台湾的共享单车，但是必须得在固定位置的，就和新余那种政府支持的共享单车一样，而不是像小黄车那样。ubike的好处是车比较棒，支持三挡变速，不好的地方就是要固定位置还车取车，而且还是蛮贵的，半小时内10新台币，相当于2元了。 </p>
<p><img src="https://tvax3.sinaimg.cn/large/006ESCTwgy1giw53zjbtij30qo0k0ag8.jpg" alt="photo_2018_07_18_c936a54cf29ab905e12bc02af29c9469"></p>
<p> hhh，到了市区，柯达在这里还没倒。 </p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1giw54r1i7oj30qo0zk42e.jpg" alt="photo_2018_07_18_d4001e96182ed871dfec905a0582cc8e"></p>
<p> 晚上是在一家叫做文昌鸡饭的店吃的，跟着他们去的，说是很好吃，吃了感觉就是白斩鸡的味道，很平常啊，旁边那碗是贡丸汤，其实就是普通的丸子啦，有点贵哎，就是路边小店的样子，也不是什么网红店，但是加起来要110新台币。 </p>
<p><img src="https://tvax2.sinaimg.cn/large/006ESCTwgy1giw568re97j30qo0k0acb.jpg" alt="photo_2018_07_18_a6e1b8681719bd35b09c5cedee16cd9d"></p>
<p> 吃完饭后去了一家叫做“阿忠冰店”的店吃冰，我点的是椰果凤梨冰，就是普通的刨冰了，50新台币有一定分量，适合和女朋友俩人吃一份，然而我没有女朋友，就很难受，没有吃完。 </p>
<p><img src="https://tvax1.sinaimg.cn/large/006ESCTwgy1giw56my6kzj30qo0k076t.jpg" alt="photo_2018_07_18_ef46a16aec36ccc3e0edb227c673922c"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/17/Taiwan2/" data-id="ckw9lgzwh00012ww5fbj57zdo" data-title="Taiwan（2）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" rel="tag">学术交流</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DIY/" rel="tag">DIY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" rel="tag">学术交流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9F%B3%E4%B9%90/" rel="tag">音乐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DIY/" style="font-size: 12px;">DIY</a> <a href="/tags/JAVA/" style="font-size: 18px;">JAVA</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">学习</a> <a href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" style="font-size: 12px;">学术交流</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12px;">数据库</a> <a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">游戏</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px;">算法</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%9F%B3%E4%B9%90/" style="font-size: 12px;">音乐</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 16px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/15/musicScore/">小提琴谱子</a>
          </li>
        
          <li>
            <a href="/2021/05/15/musicTheory/">基本乐理</a>
          </li>
        
          <li>
            <a href="/2021/05/09/qianyi/">网站迁移</a>
          </li>
        
          <li>
            <a href="/2021/05/05/mybatis/">MyBatis</a>
          </li>
        
          <li>
            <a href="/2021/04/25/maven/">Maven</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>