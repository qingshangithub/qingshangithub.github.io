<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/02/leetcode/" class="article-date">
  <time class="dt-published" datetime="2021-02-02T14:21:00.000Z" itemprop="datePublished">2021-02-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/02/leetcode/">leetcode刷题笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2 两数相加"></a>2 两数相加</h1><p>题目：</p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>先创建一个头结点re值为0，这样返回的时候返回re.next就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cursor = root;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> l1Val = l1 != <span class="keyword">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> l2Val = l2 != <span class="keyword">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sumVal = l1Val + l2Val + carry;</span><br><span class="line">            carry = sumVal / <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            ListNode sumNode = <span class="keyword">new</span> ListNode(sumVal % <span class="number">10</span>);</span><br><span class="line">            cursor.next = sumNode;</span><br><span class="line">            cursor = sumNode;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h1><p>题目：</p>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>示例：</p>
<p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>思路：</p>
<p>用双指针实现滑动窗口</p>
<p><strong>HashMap</strong>记录字符上一次出现的位置（也可以用一个256大小的数组保存ASCII，考虑泛化性用HashMap）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; vi=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(vi.get(s.charAt(end))==<span class="keyword">null</span>||vi.get(s.charAt(end))&lt;start)&#123;</span><br><span class="line">                <span class="comment">//当前字符以前没有出现过，或者出现的位置在窗口外（小于start）</span></span><br><span class="line">                vi.put(s.charAt(end),end);</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当前字符窗口里出现过</span></span><br><span class="line">                maxlen=Math.max(end-start,maxlen);</span><br><span class="line">                start=vi.get(s.charAt(end))+<span class="number">1</span>;</span><br><span class="line">                vi.put(s.charAt(end),end);</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxlen=Math.max(end-start,maxlen);</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个栗子：<code>ddabcefcff</code>,假设当前start=1,指向d，i=7,指向c，由于c上一次出现的位置是4，比start大，说明目前考虑的子串<code>dabcefc</code>中c重复了，那么该子串不重复长度为i-start=6，新的start位置是c后面一位（如果取c之前的位，则还是会含有重复的c），即5号位，显然从5到当前i=7都不会有重复的，可以继续往下遍历。</p>
<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5 最长回文子串"></a>5 最长回文子串</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>
<p>思路：</p>
<p>遍历s的每个字符，以该字符为中心往两边扩散，找到最长的回文长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftf=<span class="number">0</span>,rightf=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;&quot;</span>||s==<span class="keyword">null</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        leftf=<span class="number">0</span>;</span><br><span class="line">        rightf=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            maxlen=lenhui(i,s,maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(leftf,rightf+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenhui</span><span class="params">(<span class="keyword">int</span> idx,String s,<span class="keyword">int</span> maxlen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=idx-<span class="number">1</span>,right=idx+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> idxlen=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无论奇偶，回文子串都满足左右相等和中间若干个同一数字</span></span><br><span class="line">        <span class="comment">//先找出中间相同字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;s.charAt(left)==s.charAt(idx))&#123;</span><br><span class="line">            idxlen++;</span><br><span class="line">            left--;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length()&amp;&amp;s.charAt(right)==s.charAt(idx))&#123;</span><br><span class="line">            idxlen++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再找出左右相同的字符对个数</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(right)==s.charAt(left))&#123;</span><br><span class="line">            idxlen+=<span class="number">2</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idxlen&gt;maxlen)&#123;</span><br><span class="line">            leftf=left+<span class="number">1</span>;</span><br><span class="line">            rightf=right-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> idxlen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11 盛最多水的容器"></a>11 盛最多水的容器</h1><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>思路：</p>
<p>双指针，每次移动高度低的那个指针。</p>
<p>两个指针分别为left和right，假设left高度更低</p>
<p>如果移动right</p>
<ul>
<li>新水池的宽度肯定减小</li>
<li>高度为left的高度和right-1的高度中更小的那个，所以新的水池高度会不变或减小</li>
</ul>
<p>最终水池容量肯定会变小，所以只能移动left</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=height.length-<span class="number">1</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">            max=Math.max(max,calc(left,right,height));</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> [] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=Math.min(height[left],height[right]);</span><br><span class="line">        <span class="keyword">return</span> h*(right-left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15 三数之和"></a>15 三数之和</h1><p>思路：</p>
<p>排序+双指针</p>
<p>暴力是$O(N^{3})$，使用双指针把找三个数转换成找两个数之和（nums[i]和-nums[i]）从而实现$O(N^{2})$</p>
<p>先排序，然后两层循环</p>
<ul>
<li>外层循环<code>i</code>遍历所有数，并认为该数是三数中最小的数</li>
<li>内层循环在<code>i</code>右边的数中找到两个数的和为<code>-nums[i]</code>，使用双指针，和偏小则右移left，和偏大则左移right</li>
<li>一个关键点是避免重复，参见代码中的两处注释处</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; re=<span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=nums.length-<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> now=nums[i];</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]+nums[right]==-now)&#123;</span><br><span class="line">                    List&lt;Integer&gt; tmp=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[left]);</span><br><span class="line">                    tmp.add(nums[right]);</span><br><span class="line">                    re.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==(-now-nums[right]))left++;<span class="comment">//避免重复</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]+nums[right]&lt;-now)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i+<span class="number">1</span>&lt;nums.length&amp;&amp;nums[i+<span class="number">1</span>]==now)i++;<span class="comment">//避免重复</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17 电话号码的字母组合"></a>17 电话号码的字母组合</h1><p>题目：</p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/17_telephone_keypad.png" style="zoom:50%;" />

<p>示例 1：</p>
<p>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
<p>思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String[] map=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; re=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.length()==<span class="number">0</span>||digits==<span class="keyword">null</span>)<span class="keyword">return</span> re;</span><br><span class="line">        re.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++)&#123;</span><br><span class="line">            re=letter(digits,i,re);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">letter</span><span class="params">(String digits,<span class="keyword">int</span> idx,List&lt;String&gt; re)</span></span>&#123;</span><br><span class="line">        String now=map[digits.charAt(idx)-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        List&lt;String&gt; renew=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;now.length();i++)&#123;</span><br><span class="line">            String tmp=now.substring(i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;re.size();j++)&#123;</span><br><span class="line">                renew.add(re.get(j)+tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> renew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-删除链表倒数第N个结点"><a href="#19-删除链表倒数第N个结点" class="headerlink" title="19 删除链表倒数第N个结点"></a>19 删除链表倒数第N个结点</h1><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p>思路：快慢指针，在头结点前添加哑结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode fast=head,slow=head;</span><br><span class="line">        ListNode hh=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        hh.next=head;</span><br><span class="line">        ListNode finalhh=hh;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            hh=hh.next;</span><br><span class="line">        &#125;</span><br><span class="line">        hh.next=slow.next;</span><br><span class="line">        slow.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> finalhh.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>
<p>思路：</p>
<p>回溯法</p>
<p>左括号剩余的个数&lt;=右括号剩余的个数，当等于时，下一个必须是左括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; re=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[]last =<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>*n];</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftnum=n,rightnum=n;</span><br><span class="line">        re=paren(last,idx,leftnum,rightnum,re);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">paren</span><span class="params">(<span class="keyword">char</span>[]last,<span class="keyword">int</span> idx,<span class="keyword">int</span> leftnum,<span class="keyword">int</span> rightnum,List&lt;String&gt; re)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftnum==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(rightnum!=<span class="number">0</span>)&#123;</span><br><span class="line">                last[idx++]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                rightnum--;</span><br><span class="line">            &#125;</span><br><span class="line">            re.add(<span class="keyword">new</span> String(last));</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftnum==rightnum)&#123;</span><br><span class="line">            last[idx]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            re=paren(last,idx+<span class="number">1</span>,leftnum-<span class="number">1</span>,rightnum,re);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last[idx]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            re=paren(last,idx+<span class="number">1</span>,leftnum-<span class="number">1</span>,rightnum,re);</span><br><span class="line">            last[idx]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            re=paren(last,idx+<span class="number">1</span>,leftnum,rightnum-<span class="number">1</span>,re);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25 K 个一组翻转链表"></a>25 K 个一组翻转链表</h1><p>题目：</p>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>思路：</p>
<ul>
<li>递归调用子函数，每次从idx开始反转k个节点。</li>
<li>使用一个伪头节点，方便代码书写</li>
<li>流程如下：a-&gt;b-&gt;c-&gt;d</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/IMG_0900.jpg" style="zoom:50%;" />

<ul>
<li>步骤a完成后的状态如下</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/IMG_0901.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||k==<span class="number">1</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode tp=head;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            tp=tp.next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        tp=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//伪头结点</span></span><br><span class="line">        tp.next=head;</span><br><span class="line">        reverseKGroupTp(tp, k,<span class="number">0</span>,n);<span class="comment">//tp是当前要反转的k个节点的前一个节点</span></span><br><span class="line">        <span class="keyword">return</span> tp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseKGroupTp</span><span class="params">(ListNode tp, <span class="keyword">int</span> k,<span class="keyword">int</span> idx,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n-idx&lt;k)<span class="keyword">return</span>;</span><br><span class="line">        ListNode head=tp.next;</span><br><span class="line">        ListNode tp1=tp.next;</span><br><span class="line">        ListNode tp2=tp1.next;</span><br><span class="line">        ListNode tp3=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">2</span>;i++)&#123;<span class="comment">//前k-2个节点先反转，步骤a</span></span><br><span class="line">            tp3=tp2.next;</span><br><span class="line">            tp2.next=tp1;</span><br><span class="line">            tp1=tp2;</span><br><span class="line">            tp2=tp3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步骤a完成，到第二张图的状态</span></span><br><span class="line">        </span><br><span class="line">        tp.next=tp2;<span class="comment">//步骤b，这里一般情况虽然tp2就是tp3，但是在k=2的时候tp3是null，tp2才是真正的第k个节点，所以不能用tp3</span></span><br><span class="line">        head.next=tp2.next;<span class="comment">//步骤c</span></span><br><span class="line">        tp2.next=tp1;<span class="comment">//步骤d</span></span><br><span class="line">        reverseKGroupTp(head, k,idx+k,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归</strong></p>
<p>思路：</p>
<p>最内层循环，假设pre到curr是已经反转好的节点，那么要做的就是取出next节点，再插入到pre和pre.next之间</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/IMG_0902.jpg" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>), prev = dummy, curr = head, next;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummy.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length / k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;<span class="comment">//取出节点next，插入到pre和pre.next之间</span></span><br><span class="line">                next = curr.next;<span class="comment">//a</span></span><br><span class="line">                curr.next = next.next;<span class="comment">//b</span></span><br><span class="line">                next.next = prev.next;<span class="comment">//c</span></span><br><span class="line">                prev.next = next;<span class="comment">//d</span></span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31 下一个排列"></a>31 下一个排列</h1><p>题目：</p>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p>思路：</p>
<p>比如202349876，他的下一个是202364789，步骤如下：</p>
<ul>
<li>从后往前找到第一个不符合倒序的数4（4&gt;9）</li>
<li>4后面的数字中从后往前找到第一个比4大的数6</li>
<li>交换4和6得到202369874</li>
<li>将9874倒序得到202364789</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx1=nums.length-<span class="number">1</span>,idx2=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(idx1&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[idx1]&lt;=nums[idx1-<span class="number">1</span>])&#123;<span class="comment">//第一步</span></span><br><span class="line">                idx1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                idx1--;</span><br><span class="line">                <span class="keyword">while</span>(nums[idx2]&lt;=nums[idx1])idx2--;<span class="comment">//第二步</span></span><br><span class="line">                swap(nums,idx1,idx2);<span class="comment">//第三步</span></span><br><span class="line">                sort(nums,idx1+<span class="number">1</span>);<span class="comment">//第四步</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=num[i];</span><br><span class="line">		num[i]=num[j];</span><br><span class="line">		num[j]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=idx,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33 搜索旋转排序数组"></a>33 搜索旋转排序数组</h1><p>题目：</p>
<p>升序排列的整数数组 nums 在预先未知的某个点上进行了旋转（例如， [0,1,2,4,5,6,7] 经旋转后可能变为 [4,5,6,7,0,1,2] ）。请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>思路：</p>
<ul>
<li>二分查找找出割裂的位置</li>
<li>然后就可以得到旋转后数组和旋转前数组的索引映射关系</li>
<li>在旋转前的数组上使用二分查找</li>
<li>取值和target比较的时候映射回旋转后的数组索引位置即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>,mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>]==target)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left!=right-<span class="number">1</span>)&#123;<span class="comment">//二分查找找出割裂的位置</span></span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[left])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bias=<span class="number">0</span>;<span class="comment">//得到旋转后数组和旋转前数组的索引映射关系</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left]&lt;nums[right])&#123;</span><br><span class="line">            <span class="comment">//如果旋转点索引是0，会导致旋转和没旋转一样</span></span><br><span class="line">            <span class="comment">//这时right==nums.length-1，left==nums.length-2，bias要设置为0</span></span><br><span class="line">            bias=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            bias=nums.length-left-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midnew=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//在旋转前的数组上使用二分查找</span></span><br><span class="line">            midnew=(left+right)/<span class="number">2</span>;</span><br><span class="line">            mid=(midnew+nums.length-bias)%nums.length;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;<span class="comment">//取值和target比较的时候映射回旋转后的数组索引位置</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;<span class="comment">//取值和target比较的时候映射回旋转后的数组索引位置</span></span><br><span class="line">                right=midnew-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left=midnew+<span class="number">1</span>;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="34-排序树组中查找元素的第一个和最后一个位置"><a href="#34-排序树组中查找元素的第一个和最后一个位置" class="headerlink" title="34 排序树组中查找元素的第一个和最后一个位置"></a>34 排序树组中查找元素的第一个和最后一个位置</h1><p>题目：</p>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>思路：</p>
<p>二分查找找左右边界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftIdx = binarySearch(nums, target, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightIdx = binarySearch(nums, target, <span class="keyword">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">boolean</span> lower)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39 组合总和"></a>39 组合总和</h1><p>题目：</p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<p>说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </p>
<p>思路：</p>
<p>dfs回溯法：做选择-&gt;递归-&gt;撤销选择</p>
<p>路径存储使用双端队列Deque（也可以用Stack，效率更低一点）</p>
<p>去重：利用排序，做选择的时候只选择比上一次选择大于或等于的选择。</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1598091943-GPoHAJ-file_1598091940246.png" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; re=<span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates.length==<span class="number">0</span>)<span class="keyword">return</span> re;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,re,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,List&lt;List&lt;Integer&gt;&gt; re,Deque&lt;Integer&gt; path,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            re.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                path.offerLast(candidates[i]);</span><br><span class="line">                dfs(candidates,target-candidates[i],re,path,i);</span><br><span class="line">                path.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h1><p>题目：</p>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<p>思路：</p>
<p>回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; re=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">int</span> remain=nums.length;</span><br><span class="line">        <span class="keyword">int</span> [] visited=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        back(nums,visited,re,path,remain);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> [] nums,<span class="keyword">int</span> [] visited,List&lt;List&lt;Integer&gt;&gt; re,Deque&lt;Integer&gt; path,<span class="keyword">int</span> remain)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain==<span class="number">0</span>)&#123;</span><br><span class="line">            re.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;visited.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.offerLast(nums[i]);</span><br><span class="line">            visited[i]=<span class="number">1</span>;</span><br><span class="line">            remain--;</span><br><span class="line">            back(nums,visited,re,path,remain);</span><br><span class="line">            path.pollLast();</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">            remain++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h1><p>题目：</p>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/mat1.jpg"></p>
<p>思路：</p>
<p>先上下翻转，再沿左上-右下对角线翻转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[row-i-<span class="number">1</span>][j];</span><br><span class="line">                matrix[row-i-<span class="number">1</span>][j]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49 字母异位词分组"></a>49 字母异位词分组</h1><p>题目：</p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<p>思路：</p>
<p>给字符串排序，排好序的作为Key，用一个HashMap保存Key和在re中的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; head=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; re=<span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String tmp:strs)&#123;</span><br><span class="line">            String stmp=sort(tmp);</span><br><span class="line">            <span class="keyword">int</span> tmpidx=head.getOrDefault(stmp,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmpidx==-<span class="number">1</span>)&#123;</span><br><span class="line">                List&lt;String&gt; newlist=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                newlist.add(tmp);</span><br><span class="line">                re.add(newlist);</span><br><span class="line">                head.put(stmp,idx);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                re.get(tmpidx).add(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">sort</span><span class="params">(String tmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch=tmp.toCharArray();</span><br><span class="line">        Arrays.sort(ch);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h1><p>题目：</p>
<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。</p>
<p>示例 1：</p>
<p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例 2：</p>
<p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p>
<p>思路：</p>
<p>思路一：从后往前动态规划，记录每个格子是否可以到达最后一个格子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(size==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> [] visited=<span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> idx=size-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums[idx];i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(idx+i==size-<span class="number">1</span>)&#123;</span><br><span class="line">                    visited[idx]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(idx+i&lt;size-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visited[idx+i]==<span class="number">1</span>)&#123;</span><br><span class="line">                        visited[idx]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            idx--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited[<span class="number">0</span>]==<span class="number">1</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太耗时了</p>
<p>思路二：贪心，用一个变量记录最远能到的距离，再遍历下去，如果到了最远距离的格子，这个变量仍然没有更新到更远的距离，就返回false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size=nums.length;</span><br><span class="line">        <span class="keyword">int</span> maxidx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxidx&gt;=size-<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(idx==maxidx&amp;&amp;nums[idx]==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            maxidx=Math.max(maxidx,nums[idx]+idx);</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h1><p>题目：</p>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>
<p>示例 1：</p>
<p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals = [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
<p>思路：</p>
<p>先排序，重写Arrays.sort()的comparator，可以简写。</p>
<p>注意list转array</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">0</span>)<span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;(a[<span class="number">0</span>]-b[<span class="number">0</span>]));<span class="comment">//注意这里的重写</span></span><br><span class="line">        List&lt;<span class="keyword">int</span> []&gt; re=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(re.size()==<span class="number">0</span>||(re.get(idx)[<span class="number">1</span>]&lt;intervals[i][<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">int</span>[] tmp=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                tmp[<span class="number">0</span>]=intervals[i][<span class="number">0</span>];</span><br><span class="line">                tmp[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">                re.add(tmp);</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                re.get(idx)[<span class="number">1</span>]=Math.max(re.get(idx)[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[re.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h1><p>题目：</p>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>动态规划</p>
<p>注意：所有操作只对word1做</p>
<p><code>dp[i][j]</code> 代表 <code>word1</code> 到 <code>i </code>位置转换成 <code>word2</code> 到 <code>j </code>位置需要最少步数。所以：</p>
<ul>
<li><p>当 <code>word1[i] == word2[j]</code>，<code>dp[i][j] = dp[i-1][j-1]</code>；</p>
</li>
<li><p>当 <code>word1[i] != word2[j]</code>，<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code></p>
</li>
</ul>
<p>其中，<code>dp[i-1][j-1] </code>表示替换操作，<code>dp[i-1][j]</code> 表示删除操作，<code>dp[i][j-1]</code> 表示插入操作。</p>
<p>注意，针对第一行，第一列要单独考虑，我们引入 ‘’ 下图所示：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03252.png"></p>
<p>第一行，是 word1 为空变成 word2 最少步数，就是插入操作</p>
<p>第一列，是 word2 为空，需要的最少步数，就是删除操作</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03251.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];<span class="comment">//这里选择+1是为了避免word1或word2为空，创建数组会报错</span></span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146 LRU缓存机制"></a>146 LRU缓存机制</h1><p>题目：</p>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
<p>思路：</p>
<p>HashMap+双向链表</p>
<p>HashMap的key是key值，value是节点，节点存储了key值和value值。节点彼此之间双向连接。如下图</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02215.png"></p>
<p>越靠近头部的是最近使用的节点，越靠近尾部的是最久没使用的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    Node pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key=key;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        cache=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        head=<span class="keyword">new</span> Node();</span><br><span class="line">        tail=<span class="keyword">new</span> Node();</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.next=head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node getNode=cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(getNode==<span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        moveFirst(getNode);</span><br><span class="line">        <span class="keyword">return</span> getNode.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.get(key)==<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node tmp=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">            cache.put(key,tmp);</span><br><span class="line">            addFirst(tmp);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span>(size&gt;capacity)&#123;</span><br><span class="line">                Node rmnode=tail.pre;</span><br><span class="line">                removeNode(rmnode);</span><br><span class="line">                cache.remove(rmnode.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Node tmp=cache.get(key);</span><br><span class="line">            tmp.value=value;</span><br><span class="line">            moveFirst(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node tmp)</span></span>&#123;</span><br><span class="line">        tmp.next=head.next;</span><br><span class="line">        head.next.pre=tmp;</span><br><span class="line">        tmp.pre=head;</span><br><span class="line">        head.next=tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveFirst</span><span class="params">(Node tmp)</span></span>&#123;</span><br><span class="line">        removeNode(tmp);</span><br><span class="line">        addFirst(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node tmp)</span></span>&#123;</span><br><span class="line">        Node preNode=tmp.pre;</span><br><span class="line">        Node nextNode=tmp.next;</span><br><span class="line">        preNode.next=nextNode;</span><br><span class="line">        nextNode.pre=preNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以用LinkedHashMap，要重写removeEldestEntry函数，保证超过容量的时候移除最久未使用的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h1><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>交叉走链表，最终要么在连接点汇合，要么最后都是null而跳出循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode A = headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="keyword">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="keyword">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440 字典序的第K小数字"></a>440 字典序的第K小数字</h1><p>题目：</p>
<p>给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。</p>
<p>注意：1 ≤ k ≤ n ≤ 109。</p>
<p>示例 :</p>
<p>输入:<br>n: 13   k: 2</p>
<p>输出:<br>10</p>
<p>解释:<br>字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</p>
<p>思路：</p>
<ol>
<li>首先计算<strong>当前节点为根结点的树</strong>的节点总个数<code>step</code></li>
<li>如果<code>step&gt;k</code>,说明我们要找的那个数字节点就在这棵树里<ol>
<li>将根结点删除，根结点的子节点作为新的根结点</li>
<li>前缀更新，进入下一次while循环，相当于进入下一层递归</li>
</ol>
</li>
<li>如果<code>step&lt;k</code>,说明我们要找的那个数字节点不在这棵树里<ol>
<li>这棵树所有节点都删除</li>
<li>取相邻的节点作为新的根结点，得到下一棵要查询的树</li>
</ol>
</li>
</ol>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/440.jpg" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> step = <span class="number">0</span>, first = cur, last = cur + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//计算 当前节点为根结点的树 的节点总个数step</span></span><br><span class="line">            <span class="keyword">while</span> (first &lt;= n) &#123;</span><br><span class="line">                step += Math.min(last, (<span class="keyword">long</span>) (n + <span class="number">1</span>)) - first;</span><br><span class="line">                first *= <span class="number">10</span>;</span><br><span class="line">                last *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (step &gt; k) &#123;<span class="comment">//如果step&gt;k,说明我们要找的那个数字节点就在这棵树里</span></span><br><span class="line">                k--;<span class="comment">//将根结点删除，根结点的子节点作为新的根结点</span></span><br><span class="line">                cur *= <span class="number">10</span>;<span class="comment">//前缀更新</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (step &lt;= k) &#123;</span><br><span class="line">                k -= step;<span class="comment">//这棵树所有节点都删除</span></span><br><span class="line">                ++cur;<span class="comment">//取相邻的节点作为新的根结点，得到下一棵要查询的树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152 乘积最大子数组"></a>152 乘积最大子数组</h1><p>题目：给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>思路：2个dp数组分别保存以当前数字为 乘积最后一位 的乘积最大值和乘积最小值。这个值一定是<code>nums[i]*dpmax[i-1]</code>,<code>nums[i]*dpmin[i-1]</code>,<code>nums[i]</code>这三者中最大（小）的那个。最后求完后去dpmax数组的最大值即可。</p>
<p>主要就是考虑到正负,可能前面有一个负的数，再乘了当前一个负数，变成正的很大的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">int</span>[]dpmax=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[]dpmin=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dpmax[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dpmin[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dpmax[i]=Math.max(nums[i]*dpmax[i-<span class="number">1</span>],nums[i]*dpmin[i-<span class="number">1</span>]);</span><br><span class="line">        dpmax[i]=Math.max(dpmax[i],nums[i]);</span><br><span class="line">        </span><br><span class="line">        dpmin[i]=Math.min(nums[i]*dpmax[i-<span class="number">1</span>],nums[i]*dpmin[i-<span class="number">1</span>]);</span><br><span class="line">        dpmin[i]=Math.min(dpmin[i],nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(dpmax);</span><br><span class="line">    <span class="keyword">return</span> dpmax[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>动态规划：dp[i]是以当前数结尾的最长递增子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnow=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                maxnow=Math.max(maxnow,dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=maxnow;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200 岛屿数量"></a>200 岛屿数量</h1><p>dfs</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> cout=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    cout++;</span><br><span class="line">                    dfs(grid,i,j,m,n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=m||j&lt;<span class="number">0</span>||j&gt;=n||grid[i][j]==<span class="string">&#x27;0&#x27;</span>||grid[i][j]==<span class="string">&#x27;2&#x27;</span>)<span class="keyword">return</span>;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j,m,n);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j,m,n);</span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>,m,n);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/02/leetcode/" data-id="ckw9lh007002o2ww5fjoefl6h" data-title="leetcode刷题笔记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-dp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/dp/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T07:49:39.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/dp/">刷题算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul>
<li>确定状态：原问题和子问题中变化的变量。状态决定了问题什么时候算是解决了。</li>
<li>确定dp函数定义：<ul>
<li>一般就是问题</li>
<li>也可以是中间子问题，比如第二、三个例题</li>
</ul>
</li>
<li>确定选择并择优：对于当前状态，有哪些选择可以改变状态，向着问题的解决前进。</li>
<li>明确badcase</li>
<li>使用备忘录数组记录已经访问过的状态</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>题目：#1143</p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>思路：</p>
<ol>
<li><p>用两个指针，从指针位置到字符串末尾，是当前状态下的字符串。状态量其实就是字符串长度。</p>
</li>
<li><p>dp函数：返回当前长度下的两个字符串的最长公共子序列长度</p>
</li>
<li><p>选择并择优：如果当前两个指针的字符相等，则返回递归函数值+1；如果不等，有三种可能：</p>
<ul>
<li><p>指针1的字符在最长公共子序列中，指针2不在。则指针2往后移一位，递归调用dp函数</p>
</li>
<li><p>指针2的字符在最长公共子序列中，指针1不在。则指针1往后移一位，递归调用dp函数</p>
</li>
<li><p>指针1,2的字符都不在，其实包含在前两种情况内。</p>
</li>
<li><p>取返回值最大的那种选择。</p>
</li>
</ul>
</li>
<li><p>badcase是任意一个指针到字符串末尾后了，则一个字符串变为空，返回0</p>
</li>
<li><p>最后使用备忘录数组记录已经计算过的情况值。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] dptable=<span class="keyword">new</span> <span class="keyword">int</span>[text1.length()][text2.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] row:dptable)&#123;</span><br><span class="line">            Arrays.fill(row,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(text1,<span class="number">0</span>,text2,<span class="number">0</span>,dptable); <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(String s1,<span class="keyword">int</span> idx1,String s2,<span class="keyword">int</span> idx2,<span class="keyword">int</span>[][]dptable)</span></span>&#123; <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span>(idx1==s1.length()||idx2==s2.length())<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//4</span></span><br><span class="line">        <span class="keyword">if</span>(dptable[idx1][idx2]!=-<span class="number">1</span>)<span class="keyword">return</span> dptable[idx1][idx2]; <span class="comment">//5</span></span><br><span class="line">        <span class="keyword">if</span>(s1.charAt(idx1)==s2.charAt(idx2))&#123; <span class="comment">//3</span></span><br><span class="line">            dptable[idx1][idx2]=<span class="number">1</span>+dp(s1,idx1+<span class="number">1</span>,s2,idx2+<span class="number">1</span>,dptable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dptable[idx1][idx2]=Math.max(</span><br><span class="line">                dp(s1,idx1+<span class="number">1</span>,s2,idx2,dptable),</span><br><span class="line">                dp(s1,idx1,s2,idx2+<span class="number">1</span>,dptable)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dptable[idx1][idx2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 获取两个串字符</span></span><br><span class="line">                <span class="keyword">char</span> c1 = text1.charAt(i), c2 = text2.charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    <span class="comment">// 去找它们前面各退一格的值加1即可</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//要么是text1往前退一格，要么是text2往前退一格，两个的最大值</span></span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数组中等差递增子区间的个数"><a href="#数组中等差递增子区间的个数" class="headerlink" title="数组中等差递增子区间的个数"></a>数组中等差递增子区间的个数</h3><p>题目：#413</p>
<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。如果满足以下条件，则称子数组(P, Q)为等差数组：元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>这里的dp函数就是一个子问题: dp[i] 表示<strong>以 A[i] 为结尾</strong>的等差递增子区间的个数。最后求完以后只要取dp数组的最大值就可以解决原问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int numberOfArithmeticSlices(int[] nums) &#123;</span><br><span class="line">    int n=nums.length;</span><br><span class="line">    if(n&lt;3)return 0;</span><br><span class="line">    int[]dp=new int[n];</span><br><span class="line"></span><br><span class="line">    for(int i=2;i&lt;n;i++)&#123;</span><br><span class="line">        if(nums[i]-nums[i-1]==nums[i-1]-nums[i-2])&#123;</span><br><span class="line">            dp[i]=dp[i-1]+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int sum=0;</span><br><span class="line">    for(int v:dp)sum+=v;</span><br><span class="line">    return sum;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目：#300</p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>dp[i]是以当前数结尾的最长递增子序列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[]dp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxnow=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                maxnow=Math.max(maxnow,dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]=maxnow;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(dp);</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>主要解决字符串子串匹配问题</p>
<h2 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h2><p>维护一个窗口，不断滑动，然后更新答案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (right &lt; s.size()) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(s[right]);</span><br><span class="line">    right++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(s[left]);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般用HashMap实现窗口，用到<code>getOrDefault(key,defaultvalue)</code>函数来获取值，同时避免key不存在时得到null。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h3><p>题目：#76</p>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; need=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>,len=s.length()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fstart=<span class="number">0</span>,fend=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>,flag2=<span class="keyword">false</span>;</span><br><span class="line">        String re=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;<span class="comment">//need中记录t的每个字符出现次数</span></span><br><span class="line">            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;s.length())&#123;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!flag2map(need,window)&amp;&amp;end&lt;s.length())&#123;<span class="comment">//窗口右移，直到window包含所有t中字符</span></span><br><span class="line">                window.put(s.charAt(end),window.getOrDefault(s.charAt(end),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(flag2map(need,window))&#123;<span class="comment">//窗口左移，直到window中包含t中全部字符不成立</span></span><br><span class="line">                <span class="keyword">if</span>(need.containsKey(s.charAt(start)))&#123;</span><br><span class="line">                    window.put(s.charAt(start),window.get(s.charAt(start))-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">                flag=<span class="keyword">true</span>;<span class="comment">//说明出现了一个新的符合要求的子串</span></span><br><span class="line">                flag2=<span class="keyword">true</span>;<span class="comment">//如果进了这个循环，说明至少存在一个满足条件的子串</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag&amp;&amp;(end-start+<span class="number">1</span>&lt;len))&#123;</span><br><span class="line">                len=end-start+<span class="number">1</span>;</span><br><span class="line">                fstart=start-<span class="number">1</span>;</span><br><span class="line">                fend=end-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fend==fstart&amp;&amp;!flag2)&#123;</span><br><span class="line">            <span class="keyword">return</span> re;<span class="comment">//不存在满足要求的子串就返回&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(fstart,fend+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">flag2map</span><span class="params">(HashMap&lt;Character,Integer&gt; need,HashMap&lt;Character,Integer&gt; window)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Character tmp: need.keySet())&#123;</span><br><span class="line">            Integer win=window.get(tmp);</span><br><span class="line">            <span class="keyword">if</span>(win==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//不存在对应key也返回false</span></span><br><span class="line">            <span class="keyword">if</span>(need.get(tmp).intValue()&gt;win.intValue())<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//这里注意是大于号，window中字符出现次数小于need中对应次数就返回false</span></span><br><span class="line">            <span class="comment">//注意integer要转成int来比较大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h3><p>题目#567</p>
<p> 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例1:</p>
<p>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例2:</p>
<p>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p>
<p>思路:维护一个s1长度的窗口，不是排列就right+1，left+1，即向右平移窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; need=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录s1每个字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">            need.put(s1.charAt(i),need.getOrDefault(s1.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=s1.length()-<span class="number">1</span>;<span class="comment">//窗口大小就是s1长度</span></span><br><span class="line">        <span class="keyword">if</span>(right&gt;=s2.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=right;i++)&#123;<span class="comment">//记录窗口中每个字符出现次数</span></span><br><span class="line">            window.put(s2.charAt(i),window.getOrDefault(s2.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(need,window))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//平移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=s2.length())<span class="keyword">break</span>;</span><br><span class="line">            window.put(s2.charAt(right),window.getOrDefault(s2.charAt(right),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            window.put(s2.charAt(left-<span class="number">1</span>),window.getOrDefault(s2.charAt(left-<span class="number">1</span>),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(HashMap&lt;Character,Integer&gt; need,HashMap&lt;Character,Integer&gt; window)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Character tmp: need.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need.get(tmp).intValue()!=window.getOrDefault(tmp,-<span class="number">1</span>).intValue())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p>题目：#438</p>
<p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p>
<p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p>
<p>说明：</p>
<p>字母异位词指字母相同，但排列不同的字符串。<br>不考虑答案输出的顺序。<br>示例 1:</p>
<p>输入:<br>s: “cbaebabacd” p: “abc”</p>
<p>输出:<br>[0, 6]</p>
<p>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的字母异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的字母异位词。</p>
<p>思路和上面一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; need=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; re=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录s1每个字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length();i++)&#123;</span><br><span class="line">            need.put(p.charAt(i),need.getOrDefault(p.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=p.length()-<span class="number">1</span>;<span class="comment">//窗口大小就是s1长度</span></span><br><span class="line">        <span class="keyword">if</span>(right&gt;=s.length())<span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=right;i++)&#123;<span class="comment">//记录窗口中每个字符出现次数</span></span><br><span class="line">            window.put(s.charAt(i),window.getOrDefault(s.charAt(i),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(need,window))re.add(left);</span><br><span class="line">            <span class="comment">//平移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=s.length())<span class="keyword">break</span>;</span><br><span class="line">            window.put(s.charAt(right),window.getOrDefault(s.charAt(right),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            window.put(s.charAt(left-<span class="number">1</span>),window.getOrDefault(s.charAt(left-<span class="number">1</span>),<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(HashMap&lt;Character,Integer&gt; need,HashMap&lt;Character,Integer&gt; window)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Character tmp: need.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need.get(tmp).intValue()!=window.getOrDefault(tmp,-<span class="number">1</span>).intValue())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h3><p>题目：#3</p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; window=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;s.length()&amp;&amp;(window.getOrDefault(s.charAt(right),<span class="number">0</span>)==<span class="number">0</span>))&#123;<span class="comment">//右移扩大窗口直到出现重复字符或越界</span></span><br><span class="line">                window.put(s.charAt(right),<span class="number">1</span>);<span class="comment">//将字符加入窗口中</span></span><br><span class="line">                right++;           </span><br><span class="line">            &#125;</span><br><span class="line">            maxlen=Math.max(maxlen,right-left);<span class="comment">//更新最大长度</span></span><br><span class="line">            <span class="keyword">if</span>(right==s.length())<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span>(window.getOrDefault(s.charAt(right),<span class="number">0</span>)!=<span class="number">0</span>)&#123;<span class="comment">//右移缩小窗口直到窗口中无重复字符</span></span><br><span class="line">                window.put(s.charAt(left),<span class="number">0</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>快慢指针</p>
<ul>
<li>判断链表是否有环（有环两个指针最终会相遇）</li>
<li>找链表中点（快指针到链表末端，慢指针到中点）</li>
<li>寻找链表倒数第k个数（快指针先走k步，再和慢指针一起同速走）</li>
</ul>
<p>左右指针</p>
<ul>
<li>二分查找</li>
<li>有序数组中找两个数之和为目标值（左指针为0，右指针为末尾，两数和小于目标值，left++，大于，right–）</li>
<li>反转数组</li>
<li>滑动窗口</li>
</ul>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>本质是图中找最短路径</p>
<p>核心数据结构是队列</p>
<h2 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="打开转盘锁"><a href="#打开转盘锁" class="headerlink" title="打开转盘锁"></a>打开转盘锁</h3><p>题目#752</p>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p>
<p>思路：</p>
<ul>
<li>对于每次数字，都有8个相邻选择（4位，每位+1或-1），每次把这些选择入队</li>
<li>用一个set记录访问过的数字组合</li>
<li>String和char数组的转换：<code>s.toCharArray()</code> ,<code>new String(ch)</code></li>
<li>int和char转换：<code>(char)(num+&#39;0&#39;)</code>,<code>ch-&#39;0&#39;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; que=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String dead:deadends)&#123;</span><br><span class="line">            visited.add(dead);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(visited.contains(<span class="string">&quot;0000&quot;</span>))<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        que.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        String tmp;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            size=que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                tmp=que.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmp.equals(target))<span class="keyword">return</span> num;               </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    String tmp2=plusUp(tmp,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(tmp2))&#123;</span><br><span class="line">                        que.offer(tmp2);</span><br><span class="line">                        visited.add(tmp2);<span class="comment">//入队的时候加入visited会耗时更少，出队才加会超时</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    String tmp3=plusDown(tmp,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(tmp3))&#123;</span><br><span class="line">                        que.offer(tmp3);</span><br><span class="line">                        visited.add(tmp3);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">plusUp</span><span class="params">(String str,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> [] ch=str.toCharArray();</span><br><span class="line">        ch[i]=(<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span>+((ch[i]-<span class="string">&#x27;0&#x27;</span>)+<span class="number">1</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">plusDown</span><span class="params">(String str,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> [] ch=str.toCharArray();</span><br><span class="line">        ch[i]=(<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span>+((ch[i]-<span class="string">&#x27;0&#x27;</span>)+<span class="number">9</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>适合做排列组合问题，即遍历所有可行解。</p>
<h2 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>路径的数据结构</strong>：用<strong>Stack</strong>或者<strong>Deque</strong>，后者效率更高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; path=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">path.addLast(x);</span><br><span class="line">dfs();</span><br><span class="line">path.removeLast();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回类型是List，可以直接queue转List</span></span><br><span class="line">LinkedList&lt;Integer&gt; tmp=<span class="keyword">new</span> LinkedList&lt;&gt;(path);</span><br></pre></td></tr></table></figure>

<p><strong>选择列表</strong>：</p>
<p>特别注意确定选择列表到底是什么</p>
<p>例如：</p>
<ul>
<li>子集问题#78，选择列表是当前数是否选，二选一</li>
<li>组合总和问题#39，选择列表是所有可选的数，n选一</li>
</ul>
<p><strong>去重</strong>：</p>
<ul>
<li>不讲顺序（1,2,3和2,1,3认为是一样的）：使用begin标记选择列表的开始，每次从begin开始往后遍历</li>
<li>讲顺序，用数组</li>
</ul>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p><strong>题目</strong>：#78</p>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p><strong>思路</strong>：</p>
<p>不讲顺序，用begin，选择列表是当前数选或者不选</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; re=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(nums,re,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; re,Deque&lt;Integer&gt; path,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==nums.length)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;&gt;(path);</span><br><span class="line">            re.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前数不选</span></span><br><span class="line">        dfs(nums,re,path,begin+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//当前数选</span></span><br><span class="line">        path.addLast(nums[begin]);</span><br><span class="line">        dfs(nums,re,path,begin+<span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p><strong>题目</strong>：#39</p>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<p>说明：所有数字（包括 target）都是正整数。解集不能包含重复的组合。 </p>
<p><strong>思路</strong>：</p>
<p>不讲顺序，用begin,选择列表是candidates里的所有数，n选1</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1598091943-GPoHAJ-file_1598091940246.png" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; re=<span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(candidates.length==<span class="number">0</span>)<span class="keyword">return</span> re;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(candidates,target,re,path,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target,List&lt;List&lt;Integer&gt;&gt; re,Deque&lt;Integer&gt; path,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            re.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;candidates.length;i++)&#123;<span class="comment">//选择列表n选1</span></span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                path.offerLast(candidates[i]);</span><br><span class="line">                dfs(candidates,target-candidates[i],re,path,i);</span><br><span class="line">                path.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><p>题目：#79</p>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
<p>思路：</p>
<p>这个是讲顺序的，所以要用一个visited数组来记录访问过的数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=board.length;</span><br><span class="line">        <span class="keyword">int</span> col=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][]visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;row ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(starExist(board,word,i,j,<span class="number">0</span>,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">starExist</span><span class="params">(<span class="keyword">char</span>[][] board, String word,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> idx,<span class="keyword">boolean</span>[][]visited)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=board.length||j&lt;<span class="number">0</span>||j&gt;=board[<span class="number">0</span>].length)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(visited[i][j])<span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">        <span class="keyword">if</span> (board[i][j]==word.charAt(idx))&#123;</span><br><span class="line">            <span class="keyword">if</span>(idx==word.length()-<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            visited[i][j]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//注意这里如果是true就要直接返回，不然会多做无用的递归超时</span></span><br><span class="line">            <span class="keyword">if</span>(starExist(board,word,i-<span class="number">1</span>,j,idx+<span class="number">1</span>,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(starExist(board,word,i+<span class="number">1</span>,j,idx+<span class="number">1</span>,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(starExist(board,word,i,j-<span class="number">1</span>,idx+<span class="number">1</span>,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(starExist(board,word,i,j+<span class="number">1</span>,idx+<span class="number">1</span>,visited))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            visited[i][j]=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集是一种树型的数据结构，用于处理一些不交集的合并及查询问题。它可以支持两种操作</p>
<p>(1) 将两个不相交的集合合并</p>
<p>(2) 判断两个元素是否在一个集合中</p>
<p>两种操作的时间复杂度近乎O ( 1 ) </p>
<h2 id="框架-4"><a href="#框架-4" class="headerlink" title="框架"></a>框架</h2><p>用一个数组p来存储每个节点的父节点的编号，即 p [ x ] 表示编号为 x  的结点的父节点的编号为 p [ x ] </p>
<p>初始化：把每个点所在集合初始化为自己，即p [ x ] = x</p>
<p>查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line"> <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] p, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"> p[find(a)] = find(b); <span class="comment">//a的祖宗结点find(a) 作为 b的祖宗结点find(b)的子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><h3 id="无向图中连通分量的数目"><a href="#无向图中连通分量的数目" class="headerlink" title="无向图中连通分量的数目"></a>无向图中连通分量的数目</h3><p>题目：323</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] parent;<span class="comment">//这是记录关系的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> find(parent, parent[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> parent[], <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xset = find(parent, x);</span><br><span class="line">        <span class="keyword">int</span> yset = find(parent, y);</span><br><span class="line">        <span class="keyword">if</span> (xset != yset)</span><br><span class="line">            parent[xset] = yset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = edges.length;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(parent, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            union(parent, edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//查根的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (parent[i] == -<span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/dp/" data-id="ckw9lgzz800212ww5d6fggmn6" data-title="刷题算法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rbtree" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/20/rbtree/" class="article-date">
  <time class="dt-published" datetime="2021-01-20T09:17:39.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/20/rbtree/">红黑树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="RBTree的定义"><a href="#RBTree的定义" class="headerlink" title="RBTree的定义"></a>RBTree的定义</h1><ol>
<li>任何一个节点都有颜色，黑色或者红色。</li>
<li>根节点是黑色的。</li>
<li>父子节点之间不能出现两个连续的红节点。</li>
<li>任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。</li>
</ol>
<ul>
<li>如果一个节点存在黑子节点，那么该节点肯定有两个子节点</li>
</ul>
<ol start="5">
<li>空节点被认为是黑色的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>   T value;</span><br><span class="line">   <span class="keyword">public</span>   Node&lt;T&gt; parent;</span><br><span class="line">   <span class="keyword">public</span>   <span class="keyword">boolean</span> isRed;</span><br><span class="line">   <span class="keyword">public</span>   Node&lt;T&gt; left;</span><br><span class="line">   <span class="keyword">public</span>   Node&lt;T&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红黑树在插入和删除操作时会维持树的平衡，即保证树的高度在[logN,logN+1]，查找、删除和插入操作复杂度是O(logN)。</p>
<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。</p>
<p><strong>左旋</strong>：以某个节点作为支点(旋转节点)，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/012031.png"></p>
<p><strong>右旋</strong>：以某个节点作为支点(旋转节点)，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/012041.png"></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>值小于当前节点，查找左子树，值大于当前节点，查找右子树</p>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>先查找插入位置（和查找一样），<strong>插入红色节点</strong>，再自平衡</p>
<p><strong>核心思想是：解决两个连续红色节点问题。</strong></p>
<p>策略：左旋、右旋、变色</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01206.png" style="zoom:50%;" />

<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01205.png"></p>
<p>情境4：如果插入的父节点为红节点，那么该父节点不可能为根节点，所以<strong>插入节点总是存在祖父节点</strong>。这点很重要，因为后续的旋转操作肯定需要祖父节点的参与。</p>
<p>4.1：</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01207.png" style="zoom: 50%;" />

<p>如果PP的父节点是黑色，那么无需再做任何处理；但如果PP的父节点是红色，还需要把PP当作新的插入节点，继续做插入操作自平衡处理</p>
<p>如果PP是根节点，那么需要重新把PP设为黑色</p>
<p><strong>唯一一种会增加红黑树黑色节点层数的插入情景</strong></p>
<p>4.2.1</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01208.png" style="zoom:50%;" />

<p>4.2.2</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01209.png" style="zoom:50%;" />

<p>4.3.1</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/012010.png" style="zoom:50%;" />

<p>4.3.2</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/012011.png" style="zoom:50%;" />

<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除操作会删除对应的节点</p>
<ul>
<li><p>叶子节点就直接删除</p>
</li>
<li><p>非叶子节点，会用对应的中序遍历的后继节点来<strong>替换</strong>要删除节点的位置（删除节点的右子树中最左节点）</p>
<ul>
<li>替换节点是红色，直接替换，颜色改为和删除节点一致</li>
<li>替换节点是黑色，进行修复</li>
</ul>
</li>
</ul>
<p><strong>核心思想是：替代节点补位到删除位置后，怎么保证原来位置的树的黑色节点满足红黑树定义4（到叶子节点经过相同个数黑色节点）</strong></p>
  <img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01212.png" style="zoom:50%;" />

<p><strong>R是即将被替换到删除节点的位置的替代节点</strong></p>
<p>以下均以替换节点是父节点的左子节点为例，镜像树相应改变即可</p>
<ol>
<li><p>替换节点的兄弟节点是红色的节点。</p>
<p>由于无法从兄弟节点借到一个黑节点来填补替换的黑节点，需要将兄弟节点提升到父节点</p>
<p>兄弟节点变黑，父节点变红，再对父节点左旋，从而变成剩下三种case之一</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01213.png" style="zoom: 33%;" /></li>
<li><p>替换节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的</p>
<p>兄弟节点变红（可以保证树的局部的颜色符合定义）,父节点视为新的替换节点，继续向上回溯</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03071.jpg" style="zoom:50%;" /></li>
<li><p>替换节点的兄弟节点是黑色的节点，且兄弟节点的子节点<strong>左黑右红</strong></p>
<p>兄弟节点颜色变为父节点颜色，把<strong>父节点</strong>和<strong>兄弟节点的右子节点</strong>设为黑色，对父节点左旋</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01215.png"></p>
</li>
<li><p>替换节点的兄弟节点是黑色的节点，且兄弟节点的子节点<strong>左红右黑</strong></p>
<p>兄弟节点改为红色，左孩子改为黑色，再对兄弟节点右旋，回到case3</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01216.png"></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/rbtree/" data-id="ckw9lgzyw001s2ww584jtd50j" data-title="红黑树" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/20/map/" class="article-date">
  <time class="dt-published" datetime="2021-01-20T08:06:39.000Z" itemprop="datePublished">2021-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/20/map/">HashMap和ConcurrentHashMap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>根据键的hashCode值存储数据，非线程安全。</p>
<p>如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数组+链表+红黑树（JDK1.8增加了红黑树部分）</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01201.png" style="zoom:67%;" />

<p>Node对象：<code>Node&lt;K,V&gt;</code></p>
<p>哈希桶数组：<code>Node[] table</code></p>
<ul>
<li><p><code>Node[] table</code>的初始化长度length(默认值是<strong>16</strong>);</p>
</li>
<li><p>Load factor为负载因子(默认值是<strong>0.75</strong>);</p>
</li>
<li><p>threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。</p>
</li>
</ul>
<p>threshold = length * Load factor</p>
<h2 id="根据key获取哈希桶数组索引位"><a href="#根据key获取哈希桶数组索引位" class="headerlink" title="根据key获取哈希桶数组索引位"></a>根据key获取哈希桶数组索引位</h2><p>希望元素位置尽量分布均匀一些</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>取key的hashCode值</strong></p>
</li>
<li><p><strong>高位运算</strong></p>
</li>
<li><p>hashCode()的高16位异或低16位实现</p>
<ul>
<li>数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销</li>
</ul>
</li>
<li><p><strong>取模运算</strong></p>
</li>
<li><p>把hash值对数组长度取模运算，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，所以改用方法二来实现取模运算</p>
<ul>
<li>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方</li>
<li><code>h&amp; (length-1)</code>运算等价于对length取模，&amp;比%具有更高的效率</li>
</ul>
</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/012012.png" style="zoom: 50%;" />

<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01215.jpg"></p>
<ol>
<li>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</li>
<li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li>
<li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 <code>key、key 的 hashcode</code> 与写入的 key 是否相等，相等就赋值给 <code>e</code>,在第 8 步的时候会统一进行赋值及返回。</li>
<li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li>
<li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li>
<li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li>
<li>如果在遍历过程中找到 key 相同时直接退出遍历。</li>
<li>如果 <code>e != null</code> 就相当于存在相同的 key,那就需要将值覆盖。</li>
<li>最后判断是否需要进行扩容。</li>
</ol>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p><strong>JDK1.7</strong> 重新申请一个2倍大小的数组，然后把旧数据transfer到新的数组上去，重新计算hash，会倒置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123; </span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;  </span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key); <span class="comment">//重新计算hash值 </span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注意这三行，是倒置的关键</span></span><br><span class="line">            e.next = newTable[i]; </span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;<span class="comment">//继续下一个元素  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01217.png" style="zoom: 67%;" />

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianjindong0804/article/details/103085172">成环问题</a>：</p>
<p>两个线程同时要resize扩容时，第一个线程完成后会倒序（原来A-&gt;B，变为B-&gt;A），此时第二个线程执行<code>e.next = newTable[i]; </code> 时，就会把A（<code>e</code>）连到B（<code>newTable[i]</code>）上，即形成了A到B的循环。</p>
<p><strong>JDK1.8</strong> </p>
<p>由于table长度是2次幂，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01218.png" style="zoom: 80%;" />

<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01219.png" style="zoom:80%;" />

<p>即原来链表上的节点按照高位0和1分裂成两个链表，一个链表留在原来的位置，另一个链表移动到原来位置+2次幂位置。因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”</p>
<p>既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了</p>
<h2 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h2><p><strong>JDK1.7</strong>扩容时由于倒置，多线程会导致链表里产生环，当查找一个不存在的元素时就会死循环</p>
<p>​    当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。</p>
<p><strong>JDK1.8</strong> 没有倒置了，不会死循环，但仍然会丢失数据</p>
<p>​    比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h2><p>结构如下：segment相当于哈希桶数组Table，HashEntry相当于1.8的Node</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01214.jpg" style="zoom: 80%;" />

<p>HashEntry ：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01216.jpg" alt="01215"></p>
<p>核心数据如 value ，以及链表都是 <strong>volatile</strong> 修饰的，保证了获取时的可见性</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 <strong>ReentrantLock</strong>。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p><strong>put 方法</strong></p>
<p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);<span class="comment">//步骤2</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;  <span class="comment">//步骤3</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//步骤4</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();<span class="comment">//步骤5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>先尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value</li>
<li>不相等则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容</li>
<li>最后会解除在 2 中所获取当前 Segment 的锁</li>
</ol>
<p><code>scanAndLockForPut()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;<span class="comment">//步骤1</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;<span class="comment">//步骤2</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<p><strong>get 方法</strong></p>
<p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上,整个过程都不需要加锁</p>
<h2 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h2><p>1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题：查询遍历链表效率太低</p>
<p>结构：</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/012115.png" style="zoom:67%;" />

<ul>
<li><p>抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性</p>
</li>
<li><p>HashEntry 改为 Node</p>
</li>
</ul>
<p><strong>put 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());  </span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//步骤1</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)  <span class="comment">//步骤2  </span></span><br><span class="line">            tab = initTable();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123; <span class="comment">//步骤3</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,   </span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>))) </span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)  <span class="comment">//步骤4</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">//步骤5</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">                        binCount = <span class="number">1</span>;            </span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123; </span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, </span><br><span class="line">                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD) <span class="comment">//步骤6</span></span><br><span class="line">                    treeifyBin(tab, i);    </span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ol>
<p><strong>get 方法</strong></p>
<ul>
<li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li>
<li>如果是红黑树那就按照树的方式获取值。</li>
<li>就不满足那就按照链表的方式遍历获取值</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>1.7主要用<strong>分段锁技术</strong>，Segment继承于ReentrantLock。每个线程占用锁访问一个Segment时，其他Segment不受影响。</p>
</li>
<li><p>1.8采用CAS+synchronized保证并发安全性，红黑树优化查询效率。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/20/map/" data-id="ckw9lgzya001b2ww5eatnhyjj" data-title="HashMap和ConcurrentHashMap" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-gbf_2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/gbf_2/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:06:39.000Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/gbf_2/">synchronized</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Syschronized可以保证方法或者代码块在运行时同一时刻只有一个线程能进入临界区，同时保证共享变量对其他线程的可见性</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>synchronized关键字最主要的三种使用方式:</p>
<ul>
<li>普通方法，只对当前实例对象加锁</li>
<li>静态方法，对类的所有对象加锁</li>
<li>代码块<ul>
<li><code>this</code> ：对当前实例对象加锁</li>
<li><code>Classname.class</code>：对类的所有对象加锁</li>
</ul>
</li>
</ul>
<h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>定义接口方法时不能使用synchronized关键字</p>
</li>
<li><p>构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步</p>
</li>
<li><p>synchronized关键字不能继承</p>
<p>如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以</p>
<p>还可以在子类方法中调用父类中相应的方法，虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lass Parent &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="keyword">super</span>.method();   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字静态synchronized&quot;</span>);</span><br><span class="line">        SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">		SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread2, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syncThread1和syncThread2是SyncThread的两个对象，但在thread1和thread2并发执行时却保持了线程同步。这是因为run中调用了静态方法method，而静态方法是属于类的，所以syncThread1和syncThread2相当于用了同一把锁</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用关键字synchronized&quot;</span>);</span><br><span class="line">        SyncThread syncThread = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程名:&quot;</span>+Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是同一个<code>syncThread</code>对象，所以加锁实现了同步</p>
<h3 id="Classname-class"><a href="#Classname-class" class="headerlink" title="Classname.class"></a>Classname.class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">kt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用ClassName&quot;</span>);</span><br><span class="line">        SyncThread syncThread1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">		SyncThread syncThread2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(syncThread1, <span class="string">&quot;SyncThread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(syncThread2, <span class="string">&quot;SyncThread2&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ClassName.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(SyncThread.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + (count++));</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syncThread1和syncThread2是SyncThread的两个对象,但因为<code>synchronized</code>作用于类，类的所有对象都适用，所以能够同步</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 </li>
<li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 </li>
<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li>
</ul>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>Java对象头和monitor是实现synchronized的基础</p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的</p>
<p><code>monitorenter</code>指令插入到同步代码块的开始位置，<code>monitorexit</code>指令插入到同步代码块的结束位置。任何对象都有一个<code>monitor</code>与之相关联，当一个<code>monitor</code>被持有之后，他将处于锁定状态。线程执行到<code>monitorenter</code>指令时，将会尝试获取对象所对应的<code>monitor</code>所有权，即尝试获取对象的锁,<code>monitorexit</code>释放<code>monitor</code></p>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>依靠的是方法修饰符上的<code>ACC_SYNCHRONIZED</code>实现</p>
<p>同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit</p>
<p>归根究底，还是monitor对象的争夺</p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>Monitor是一种用来实现同步的工具，每个java对象都有一个Monitor与之对应</p>
<p>如果一个java对象被某个线程锁住</p>
<ul>
<li><p>该java对象的对象头的Mark Word字段中LockWord指向monitor的起始地址</p>
</li>
<li><p>Monitor的Owner字段会存放拥有相关联对象锁的线程id</p>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01201.jpg"></p>
<h1 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h1><p>synchronized锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/gbf_2/" data-id="ckw9lgzx1000a2ww5fyl046os" data-title="synchronized" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-os" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/17/os/" class="article-date">
  <time class="dt-published" datetime="2021-01-17T08:13:39.000Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/17/os/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="四大基本特征"><a href="#四大基本特征" class="headerlink" title="四大基本特征"></a>四大基本特征</h2><ul>
<li>并发：一段时间内多个程序同时运行（并行是一个时刻多个指令同时运行）</li>
<li>共享：资源共享</li>
<li>虚拟：虚拟地址，为物理硬件提供逻辑接口来降低使用难度</li>
<li>异步：进程走走停停，上下文切换</li>
</ul>
<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ul>
<li>进程管理</li>
<li>内存管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ul>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>操作系统的两种运行级别</p>
<ul>
<li>用户态：<ul>
<li>R3特权级，特权最低</li>
<li>进程所能访问的内存空间和对象受到限制</li>
<li>占有的处理器可被抢占</li>
</ul>
</li>
<li>内核态：<ul>
<li>R0特权级，特权最高；</li>
<li>能访问所有的内存空间和对象</li>
<li>占有的处理器不允许被抢占</li>
</ul>
</li>
</ul>
<h3 id="用户态到内核态的切换（三种中断）"><a href="#用户态到内核态的切换（三种中断）" class="headerlink" title="用户态到内核态的切换（三种中断）"></a>用户态到内核态的切换（三种中断）</h3><p>其实就是三种中断</p>
<ul>
<li><p><strong>外中断</strong></p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序</p>
</li>
<li><p><strong>异常</strong></p>
<p>当 CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</p>
</li>
<li><p><strong>系统调用</strong></p>
<p>这是用户态进程主动要求切换到内核态的一种方式<strong>，</strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。比如前例中fork()实际上就是执行了一个创建新进程的系统调用。常见的系统调用还有 <code>read, write, open, create, close, readv, writev, fork, wait, exit, execve, clone</code> 等等</p>
</li>
</ul>
<h2 id="宏内核和微内核"><a href="#宏内核和微内核" class="headerlink" title="宏内核和微内核"></a>宏内核和微内核</h2><p>宏内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>微内核是将一部分操作系统功能移出内核，从而降低内核的复杂性。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和内核态之间进行切换，所以会有一定的性能损失。</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程与线程的区别和联系"><a href="#进程与线程的区别和联系" class="headerlink" title="进程与线程的区别和联系"></a>进程与线程的区别和联系</h2><p>进程：资源分配的基本单位，由<strong>线程+内存+文件/网络句柄</strong>构成</p>
<p>线程：独立调度的基本单位，由 <strong>栈+PC(程序计数器)+TLS(线程本地存储)</strong> 组成</p>
<p>比如QQ和浏览器是两个进程，浏览器内的http请求是一个线程、渲染是一个线程。</p>
<p><strong>联系：</strong></p>
<p>进程是线程的容器，一个进程中可以并发多个线程，不同的线程共享进程的资源（堆），同一进程的线程各自维护自己的栈。</p>
<p><strong>区别：</strong></p>
<ul>
<li>资源：操作系统会给每个进程分配资源，但线程不会，只能共享进程的资源</li>
<li>开销：由于要分配回收资源，创建撤销进程的开销远大于创建撤销线程的开销</li>
<li>通信：线程通信更简单，直接读写同一进程中的数据；进程通信需要通过IPC（进程间通信）</li>
</ul>
<h2 id="进程状态切换"><a href="#进程状态切换" class="headerlink" title="进程状态切换"></a>进程状态切换</h2><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01171.png"></p>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>没有太多的用户操作，目标是保证吞吐量和周转时间（从提交到终止的时间）</p>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>first-come first-serverd（FCFS）</p>
<p>非抢占式的调度算法，按照请求的顺序进行调度</p>
<ul>
<li><p>优点：任何进程不会饥饿</p>
</li>
<li><p>缺点：不利于短作业。</p>
<p>短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
</ul>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>shortest job first（SJF）</p>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度</p>
<ul>
<li>优点：对短作业友好</li>
<li>缺点：长作业可能会饥饿（解决方案，设定阈值，年龄超过阈值使用先来先服务）</li>
</ul>
<h4 id="最短剩余时间优先（抢）"><a href="#最短剩余时间优先（抢）" class="headerlink" title="最短剩余时间优先（抢）"></a>最短剩余时间优先（抢）</h4><p>shortest remaining time next（SRTN）</p>
<p>抢占式调度算法，按剩余运行时间顺序调度。</p>
<p>当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p>有大量的用户交互操作，目标是快速响应</p>
<h4 id="时间片轮转（抢）"><a href="#时间片轮转（抢）" class="headerlink" title="时间片轮转（抢）"></a>时间片轮转（抢）</h4><p>所有就绪进程按先来先服务原则排成一个队列，给队首一个时间片执行，执行结束放到队尾，再给新的队首一个时间片执行。</p>
<p>效率取决于<strong>时间片长度</strong>的设置，太短切换浪费过多时间，太长实时性得不到保证</p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>为每个进程分配一个优先级，按优先级进行调度。</p>
<p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h4 id="多级反馈队列（抢）"><a href="#多级反馈队列（抢）" class="headerlink" title="多级反馈队列（抢）"></a>多级反馈队列（抢）</h4><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01173.png"></p>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>对临界资源进行访问的那段代码称为临界区</p>
<p>同一时刻内同一段<strong>代码</strong>可能会有多个<strong>进程</strong>在执行，同一时刻只允许一个进程位于临界区内。</p>
<p>伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="comment">//进入区</span></span><br><span class="line">	<span class="comment">//临界区</span></span><br><span class="line">	<span class="comment">//退出区</span></span><br><span class="line">	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>

<p>临界区实现方式：</p>
<ul>
<li>非抢占内核：没有竞争</li>
<li>抢占内核：<ul>
<li>软件实现：使用两个变量记录是否有进程位于临界区以及哪个进程位于临界区</li>
<li>硬件实现：锁。进程在进入临界区前检测并申请锁，离开后释放锁。</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是用来协调进程对共享资源的访问</p>
<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
<p>信号量是一个特殊的整型变量，程序对其访问都是<strong>原子操作</strong>，且只允许对它进行等待(<code>P(sv)</code>) 和发送(<code>V(sv)</code>)信息操作。</p>
<ul>
<li><strong>P(sv)等待：</strong>如果 <code>sv</code> 的值大于零，就给它减 <code>1</code> ；如果它的值为零，就<strong>挂起</strong>该进程的执行</li>
<li><strong>V(sv)发送：</strong>如果有其他进程因等待 <code>sv</code> 而被挂起，就让它恢复运行，如果没有进程因等待 <code>sv</code> 而挂起，就给它加 <code>1</code> 。</li>
</ul>
<p>举个例子，就是两个进程共享信号量 <code>sv</code> ，一旦其中一个进程执行了 <code>P(sv)</code> 操作，它将得到信号量，并可以进入临界区，使 <code>sv</code> 减1。而第二个进程将被阻止进入临界区，因为当它试图执行 <code>P(sv)</code> 时，<code>sv</code> 为 <code>0</code> ，它会被挂起以等待第一个进程离开临界区域并执行 <code>V(sv)</code> 释放信号量，这时第二个进程就可以恢复执行。</p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>管程模型里，只能有一个进程或线程在执行。java用sychronize+wait notify来实现，即互斥锁+条件变量。</p>
<p>信号量是和资源绑定的，资源最多可以给多少个进程用，s就设置为多少，减到0了就阻塞了。管程只让一个进程运行。信号量和管程可以互相实现。</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>两种管道、两种信号、socket、消息队列、共享内存</p>
<h3 id="管道（无名）"><a href="#管道（无名）" class="headerlink" title="管道（无名）"></a>管道（无名）</h3><p>当一个进程创建了一个管道，并调用 <code>fork</code> 创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。 </p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01181.png"></p>
<p>无名管道创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedis[<span class="number">2</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>当一个管道建立时，它会创建两个文件描述符(<strong>fd</strong>)：</p>
<ul>
<li><code>filedis[0]</code> 用于读管道。</li>
<li><code>filedis[1]</code> 用于写管道。</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>半双工</strong>，数据只能单向流动</li>
<li>只能在父子进程或者兄弟进程中使用</li>
<li>数据被进程从管道读出后，在管道中该数据就不存在了</li>
<li>进程去<strong>读取空管道</strong>的时候，进程会阻塞</li>
<li>进程去<strong>写入满管道</strong>的时候，进程会阻塞</li>
<li>管道容量为 <strong>64KB</strong>(缓存区有限)</li>
<li>必须在系统调用<code>fork( )</code>前调用<code>pipe( )</code>，否则子进程将不会继承文件描述符</li>
</ul>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>有名管道，和无名管道基本相同，去除了管道只能在父子进程中使用的限制，<strong>不相关的进程也能交换数据</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, mode_tmode)</span></span></span><br></pre></td></tr></table></figure>

<p>一旦创建了一个FIFO，就可用open打开它，一般的文件访问函数（close、read、write等）都可用于FIFO。FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01182.png" style="zoom: 67%;" />

<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：缓冲区有限</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是消息的链表，存放在内核中并由消息队列标识符标识</p>
<p>建立一个队列，先放入队列的消息被最先取出。和管道不同的是，消息队列<strong>允许多个进程放入消息，也允许多个进程取出消息</strong>。每个消息可以带有一个整数识别符( <code>message_type</code> )。你可以通过识别符对消息分类 (极端的情况是将每个消息设置一个不同的识别符)。某个进程从队列中取出消息的时候，可以按照<strong>先进先出</strong>的顺序取出，也可以<strong>只取出符合某个识别符的消息</strong>(有多个这样的消息时，同样按照先进先出的顺序取出)。</p>
<p>克服了<strong>信号传递信息少</strong>、<strong>管道只能承载无格式字节流以及缓冲区大小受限</strong>等缺点</p>
<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存就是<strong>映射一段能被其他进程所访问的内存</strong>，这段共享内存<strong>由一个进程创建，但多个进程都可以访问</strong>。</p>
<p>共享内存是⭐<strong>最快</strong>⭐的 <code>IPC(interprocess communication)</code> 方式，它是<strong>针对其他进程间通信方式运行效率低而专门设计</strong>的。它往往与其他通信机制，如<strong>信号量配合使用</strong>，来实现进程间的同步和通信。</p>
<ul>
<li><p>优点：无须复制，快捷，信息量大</p>
</li>
<li><p>缺点</p>
<ul>
<li><p>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题(映射到<strong>文件映射段</strong>)</p>
</li>
<li><p>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</p>
</li>
</ul>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>通知接收进程某个事件已经发生</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>可用于不同机器间的进程通信</p>
<ul>
<li>优点：<ol>
<li>传输数据为<strong>字节级</strong>，传输数据<strong>可自定义</strong>，数据量小效率高</li>
<li>传输数据<strong>时间短</strong>，<strong>性能高</strong></li>
<li>适合于客户端和服务器端之间信息<strong>实时交互</strong></li>
<li>可以<strong>加密</strong>，<strong>数据安全性强</strong></li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ol>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（ reader-writer lock ）、自旋锁（ spin lock ）、条件变量（ condition variable ）</li>
<li>信号量机制( Semaphore )</li>
<li>信号机制( Signal )：类似进程间的信号处理</li>
</ol>
<p>线程使用共享内存，所以数据是互通的。线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>是一种比线程更加轻量级的存在，主要就是为了减少线程切换的资源消耗。</p>
<p><strong>一个线程里可以有多个协程</strong>，它不是被操作系统内核所管理的，而是完全由程序所控制，也就是在<strong>用户态</strong>执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。</p>
<p>一个线程的多个协程虽然可以切换，但运行是<strong>串行</strong>的。当一个协程运行时，其它协程必须挂起。</p>
<p>同一个线程中通过保存代码执行段状态，进行代码段的分次执行，以及多个代码段的交织执行。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ul>
<li><strong>进程</strong>的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括页全局目录、内核栈、硬件上下文，切换内容保存在内存中。进程切换过程是由“用户态到内核态到用户态”的方式，切换效率低。</li>
<li><strong>线程</strong>的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容包括内核栈和硬件上下文。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， 切换效率中等。</li>
<li><strong>协程</strong>的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程的切换内容是硬件上下文，切换内存保存在用户自己的变量（用户栈或堆）中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高.</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>一组互相竞争资源的线程因互相等待，导致<strong>永久阻塞</strong>的现象。说白了就是：两个线程互相持有对方所需的资源，互不释放且互相等待</p>
<h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>产生死锁必须同时满足以下四个条件</p>
<ul>
<li><strong>互斥</strong>：进程申请的资源在一段时间内只能被一个进程使用</li>
<li><strong>占有和等待</strong>：已经得到了某个资源的进程可以再请求新的资源，但对自己已获得的资源保持不放。</li>
<li><strong>不可抢占</strong>：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li><strong>环路等待</strong>：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h2 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h2><p>主要有以下四种方法：</p>
<ul>
<li>鸵鸟策略</li>
<li>死锁检测与死锁恢复</li>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
<h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>
<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
<p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h3 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<p>检测：有向图有环</p>
<p>恢复：</p>
<ul>
<li>利用抢占恢复</li>
<li>利用回滚恢复</li>
<li>通过杀死进程恢复</li>
</ul>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>在程序运行之前预防发生死锁。</p>
<p>破坏四个必要条件</p>
<ul>
<li><p>破坏互斥条件</p>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
</li>
<li><p>破坏占有和等待条件</p>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源</p>
</li>
<li><p>破坏不可抢占条件</p>
</li>
<li><p>破坏环路等待</p>
<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>在程序运行时避免发生死锁</p>
<p><strong>银行家算法</strong></p>
<p>假设释放一个进程，然后把这个进程已分配的资源回收到剩余资源中，然后再找下一个能在剩余可用资源中被释放的进程。以此类推，如果都能被释放，系统处于安全状态，不会死锁。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01183.png" alt="img"></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<p>如果一个状态不是安全的，需要拒绝进入这个状态。</p>
<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<p>解决办法：线程谦让时，尝试等待一个随机的时间就可以了</p>
<h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>低优先级的线程资源一直被高优先级抢占</p>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>IO操作分两步：</p>
<ol>
<li><strong>等待数据：</strong>用户进程向内核发起 <code>IO</code> 请求，等待内核数据准备</li>
<li><strong>数据拷贝：</strong>将数据从<strong>内核</strong>拷贝到<strong>进程缓存区</strong>中</li>
</ol>
<p>五种模型记忆方式：</p>
<ul>
<li>数据没准备好，用户进程就一直等（阻塞IO）</li>
<li>用户进程不想一直等，就隔段时间来检查一次，即轮询（非阻塞IO）</li>
<li>用户进程不想管这事，交给中间人select，数据好了select会通知对应的用户进程（IO多路复用）</li>
<li>不想有中间人，直接内核来通知（信号驱动式IO）</li>
</ul>
<p>以上四种都是同步IO，根据<strong>等待数据</strong>分类，在拷贝数据时都是阻塞的。</p>
<ul>
<li>拷贝数据不阻塞（异步IO）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdn.net/20161028200140849"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01291.jpg" alt="img"></a></p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>
<p>特点：</p>
<ol>
<li><strong>进程阻塞挂起不消耗CPU资源，及时响应每个操作</strong>；</li>
<li>实现难度低、开发应用较容易；</li>
<li>适用并发量小的网络应用开发；</li>
<li><strong>不适用并发量大的应用</strong>：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</li>
</ol>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程</p>
<p>典型应用：<strong>socket</strong>是非阻塞的方式（设置为NONBLOCK）</p>
<p><strong>阻塞IO模型是一个阻塞IO调用，而非阻塞IO模型是多个非阻塞IO调用+一个阻塞IO调用，因为多个IO检查会立即返回错误，不会阻塞进程。</strong></p>
<p>特点：</p>
<ol>
<li><strong>进程轮询（重复）调用，消耗CPU的资源</strong>；</li>
<li>实现难度低、开发应用相对阻塞IO模式较难；</li>
<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>
</ol>
<hr>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>多个的进程的IO可以注册到一个复用器(<code>select</code>)上，然后用一个进程调用该 <code>select</code> ， <code>select</code> 会监听所有注册进来的IO；如果 <code>select</code> 监听的IO在内核缓冲区都没有可读数据，<code>select</code> 调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，<code>select</code> 调用就会返回；而后 <code>select</code> 调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。可以看到，<strong>多个进程注册IO后，只有另一个select调用进程被阻塞。</strong></p>
<p><strong>典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;</strong></p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>专一进程解决多个进程IO的阻塞问题，性能好</strong>；<strong>Reactor模式;</strong></li>
<li>实现、开发应用难度较大；</li>
<li><strong>适用高并发服务应用开发：一个进程（线程）响应多个请求</strong>；</li>
</ol>
<h3 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h3><p>当进程发起一个IO操作，会向内核注册一个<strong>信号处理函数</strong>，然后进程<strong>返回不阻塞</strong>；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据.</p>
<p><strong>特点：回调机制，</strong>实现、开发应用难度大；</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。<strong>如果IO操作成功则进程直接获取到数据</strong>。</p>
<p><strong>特点：</strong></p>
<ol>
<li><strong>不阻塞，数据一步到位</strong>；<strong>Proactor模式</strong>；</li>
<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>
<li>实现、开发应用难度大；</li>
<li>非常适合高性能高并发应用；</li>
</ol>
<h2 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>在计算机领域常说的 <code>I/O</code> 包括磁盘 <code>I/O</code> 和网络 <code>I/O</code> ，我们所说的 <code>I/O</code> 复用主要是指网络 <code>I/O</code> ，在 <code>Linux</code> 中一切皆文件，因此网络 <code>I/O</code> 也经常用文件描述符 <code>FD</code> 来表示。</p>
<p>多个描述符的IO操作都能在一个线程内并发交替地顺序完成，这就叫IO多路复用。</p>
<p>复用指的是复用同一个进程/线程。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>简单来说就是：select去看IO是否就绪（读、写、异常三种文件描述符），好了就启动用户线程。</p>
<p>描述符集合底层用数组实现。</p>
<p>下面是详细介绍，重点是那个select函数。</p>
<p><a target="_blank" rel="noopener" href="https://images0.cnblogs.com/blog/305504/201308/17201205-8ac47f1f1fcd4773bd4edd947c0bb1f4.png"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01292.jpg" alt="img"></a></p>
<p><code>select</code> 使用一个宏定义函数按照 <code>bitmap</code> 原理填充 <code>fd</code> ，默认大小是 <code>1024</code> 个，因此对于 <code>fd</code> 的数值大于 <code>1024</code> 都可能出现问题。</p>
<p><code>select</code> 函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒。</p>
<p><strong>运行机制：</strong></p>
<p><code>select</code>会将全量<code>fd_set</code>从用户空间拷贝到内核空间，并注册回调函数， 在内核态空间来判断每个请求是否准备好数据 。<code>select</code>在没有查询到有文件描述符就绪的情况下，将一直阻塞（I/O多路服用中提过：select是一个阻塞函数）。如果有一个或者多个描述符就绪，那么select将就绪的文件描述符置位，然后select返回。返回后，由程序遍历查看哪个请求有数据。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，fd越多开销则越大；</li>
<li>每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li>
<li>select支持的文件描述符数量有限，默认是1024。</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,<span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值：就绪描述符的数目，超时返回 <code>0</code> ，出错返回 <code>-1</code> 。</p>
<p>函数参数介绍如下：</p>
<ol>
<li>第一个参数 <code>maxfdp1</code> 指定待测试的描述字个数，它的值是待测试的最大描述字加 <code>1</code> （因此把该参数命名为<code>maxfdp1</code> ），描述字 <code>0、1、2...maxfdp1 - 1</code> 均将被测试。因为文件描述符是从 <code>0</code> 开始的。</li>
<li>中间的三个参数 <code>readset</code> 、<code>writeset</code> 和 <code>exceptset</code> 指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针。<code>struct fd_set</code> 可以理解为一个集合，这个集合中存放的是<strong>文件描述符FD</strong>，可通过以下四个宏进行设置：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;          <span class="comment">//清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符加入集合之中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//将一个给定的文件描述符从集合中删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 检查集合中指定的文件描述符是否可以读写</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>timeval *timeout</code> 告知内核等待所指定描述字中的任何一个就绪可花多少时间。其 <code>timeval</code> 结构用于指定这段时间的秒数和微秒数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">//seconds</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">//microseconds</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个参数有三种可能：</p>
<p>（1）永远等待下去：仅在有一个描述字准备好 <code>I/O</code> 时才返回。为此，把该参数设置为空指针 <code>NULL</code> 。</p>
<p>（2）等待一段固定时间：在有一个描述字准备好 <code>I/O</code> 时返回，但是不超过由该参数所指向的 <code>timeval</code> 结构中指定的秒数和微秒数。</p>
<p>（3）根本不等待：检查描述字后立即返回，这称为<strong>轮询</strong>。为此，该参数必须指向一个 <code>timeval</code> 结构，而且其中的定时器值必须为 <code>0</code> 。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><code>poll</code> 与 <code>select</code></p>
<ul>
<li>相似点：管理多个描述符都是进行<strong>轮询</strong>，根据描述符的状态进行处理。</li>
<li>不同点： <ul>
<li><code>poll</code> 使用<strong>链表</strong>实现，没有最大文件描述符数量的限制；</li>
<li><code>select</code>使用<strong>数组</strong>实现，最多1024个文件描述符。</li>
</ul>
</li>
</ul>
<p><strong>共同的缺点：</strong></p>
<p>包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，包括未就绪的文件描述符，它的开销随着文件描述符数量的增加而线性增大。</p>
<p>下面是详细介绍</p>
<p>函数格式如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">( struct pollfd * fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>pollfd</code> 结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;         	  <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events;         <span class="comment">/* 等待的事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents;        <span class="comment">/* 实际发生了的事件 */</span></span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>

<p>每一个 <code>pollfd</code> 结构体指定了一个<strong>被监视的文件描述符</strong>，可以传递多个结构体，指示 <code>poll()</code> 监视多个文件描述符。每个结构体的 <code>events</code> 域是监视该文件描述符的事件掩码，由用户来设置这个域。<code>revents</code> 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。<code>events</code> 域中请求的任何事件都可能在 <code>revents</code> 域中返回。合法的事件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POLLIN 　　　　　　　　有数据可读。</span><br><span class="line">POLLRDNORM 　　　　  有普通数据可读。</span><br><span class="line">POLLRDBAND　　　　　 有优先数据可读。</span><br><span class="line">POLLPRI　　　　　　　　 有紧迫数据可读。</span><br><span class="line">POLLOUT　　　　　　      写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM　　　　　  写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND　　　　　   写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL 　　　　消息可用。</span><br></pre></td></tr></table></figure>

<p>此外，<code>revents</code> 域中还可能返回下列事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POLLER　　   指定的文件描述符发生错误。</span><br><span class="line">POLLHUP　　 指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL　　指定的文件描述符非法。</span><br></pre></td></tr></table></figure>

<p><code>timeout</code> 参数指定等待的毫秒数，无论 <code>I/O</code> 是否准备好，<code>poll</code> 都会返回。<code>timeout</code> 指定为负数值表示无限超时，使 <code>poll()</code> 一直挂起直到一个指定事件发生；<code>timeout</code> 为 <code>0</code> 指示 <code>poll</code> 调用立即返回并列出准备好I/O的文件描述符，但并不等待其它的事件。这种情况下，<code>poll()</code> 就像它的名字那样，一旦选举出来，立即返回。</p>
<p><strong>返回值和错误代码</strong><br>成功时，<code>poll()</code> 返回结构体中 <code>revents</code> 域不为 <code>0</code> 的文件描述符个数；如果在超时前没有任何事件发生，<code>poll()</code> 返回 <code>0</code> ；失败时，<code>poll()</code> 返回 <code>-1</code> ，并设置 <code>errno</code> 为下列值之一。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><code>epoll</code> <strong>使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中</strong>，这样在用户空间和内核空间的 <code>copy</code> 只需一次。</p>
<ul>
<li><code>poll_ctl()</code>用于向内核<strong>注册</strong>新的描述符或者<strong>改变</strong>描述符的状态</li>
<li>已注册的描述符存储在内核的<strong>红黑树</strong>上</li>
<li>IO就绪的描述符会加入到<strong>链表</strong>中</li>
<li>用户进程调用<code>epoll_wait()</code>可以得到就绪的IO描述符</li>
</ul>
<p>如图展示了红黑树、双链表、epitem之间的关系：</p>
<p><a target="_blank" rel="noopener" href="https://mmbiz.qpic.cn/mmbiz_png/wAkAIFs11qaBgY0G6Buiautiak0JXcjXKMj1rxibhibqZx2wKJiaFvWic5iaqcOzoicHQVQ07GHIveN1Sb0ZV2tEQLic5nw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01293.jpg" alt="图片" style="zoom:67%;" /></a></p>
<p>工作模式：</p>
<ul>
<li>LT模式（默认）：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序<strong>可以不立即处理</strong>该事件。下次调用epoll_wait时，<strong>会再次响应</strong>应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序<strong>必须立即处理</strong>该事件。如果不处理，下次调用epoll_wait时，<strong>不会再次响应</strong>应用程序并通知此事件。</li>
</ul>
<p>LT更安全，ET更高效；</p>
<p>LT可以使用阻塞或者非阻塞IO，ET必须用非阻塞IO防止其他任务饿死。</p>
<p>ET模式指的是当数据从无到有时，才通知该fd。数据读不完，也不会再次通知，所以read时一定要采用循环的方式一直读到read函数返回-1为止。此时采用阻塞的read，那么就阻塞了整个线程。</p>
<p>常见问题：</p>
<ul>
<li><p>使用epoll是否需要将socket设置为nonblocking?</p>
<p>取决于你使用的触发方式， 如果你使用水平触发(Level-triggered) 那么此时的 <code>epoll</code> 相当于高级的 <code>select</code> ， 你的论述是对的， 是不需要一定将 <code>socket</code> 设置为非阻塞的; 然而， 当你使用边缘触发(Edge-triggered) 那么此时从业务的完整性考虑， 是建议将 <code>socket</code> 设置为 <code>nonbocking</code> 模式， 并且在读写触发 <code>EAGAIN</code> 之后再进行<code>epoll_wait</code> 。</p>
</li>
<li><p>epoll的优点</p>
<ol>
<li><strong>没有最大并发连接的限制</strong>。能打开的 <code>FD</code> 的上限远大于 <code>1024</code>（ <code>1G</code> 的内存上能监听约10万个端口）</li>
<li><strong>效率提升，不是轮询而是回调</strong>。不会随着 <code>FD</code> 数目的增加效率下降。只有活跃可用的 <code>FD</code> 才会调用 <code>callback</code> 函数。即 <code>Epoll</code> 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，<code>Epoll</code> 的效率就会远远高于 <code>select</code> 和 <code>poll</code> 。</li>
</ol>
</li>
<li><p>LT和ET的读写问题</p>
<ol>
<li>LT<ul>
<li>read<ul>
<li><code>LT</code> 对于 <code>read</code> 操作比较简单，有 <code>read</code> 事件就读，读多读少都没有问题。</li>
</ul>
</li>
<li>write<ul>
<li>但是 <code>write</code> 就不那么容易了，一般来说<strong>socket在空闲状态时发送缓冲区一定是不满的</strong>，假如 <code>fd</code> 一直在监控中，那么会一直通知写事件，不胜其烦。</li>
<li>所以必须<strong>保证没有数据要发送的时候，要把 <code>fd</code> 的 <code>写</code> 事件监控从 <code>epoll</code> 列表中删除</strong>，<strong>需要的时候再加入回去，如此反复</strong>。</li>
<li>对应 <code>write</code> 的过度提醒，需要使用者随用随加，否则将一直被提醒可写事件。</li>
</ul>
</li>
</ul>
</li>
<li>ET<ul>
<li>read<ul>
<li><code>fd</code> 可读则返回可读事件，若开发者没有把所有数据读取完毕，<code>epoll</code> 不会再次通知 <code>read</code> 事件。</li>
<li>也就是说如果没有全部读取所有数据，那么导致 <code>epoll</code> 不会再通知该 <code>socket</code> 的 <code>read</code> 事件，事实上一直读完很容易做到。</li>
</ul>
</li>
<li>write<ul>
<li><strong>若发送缓冲区未满，epoll通知write事件，直到开发者填满发送缓冲区，epoll才会在下次发送缓冲区由满变成未满时通知write事件。</strong></li>
</ul>
</li>
<li><code>ET</code> 模式下<strong>只有socket的状态发生变化</strong>时才会通知，也就是<strong>读取缓冲区由无数据到有数据时通知read事件</strong>，<strong>发送缓冲区由满变成未满通知write事件</strong>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>下面是详细介绍</p>
<p><code>epoll</code> 使用 <code>事件</code> 的就绪通知方式，通过 <code>epoll_ctl</code> 注册 <code>fd</code> ，一旦该 <code>fd</code> 就绪，内核就会采用类似 <code>callback</code> 的回调机制来激活该 <code>fd</code> ，<code>epoll_wait</code> 便可以收到通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用户数据载体</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">   void    *ptr;</span><br><span class="line">   int      fd;</span><br><span class="line">   uint32_t u32;</span><br><span class="line">   uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line">//fd装载入内核的载体</span><br><span class="line"> struct epoll_event &#123;</span><br><span class="line">     uint32_t     events;    /* Epoll events */</span><br><span class="line">     epoll_data_t data;      /* User data variable */</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>epoll 函数</strong></p>
<p><code>epoll</code> 操作过程需要三个接口，分别如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>int epoll_create(int size);</strong><br>在内核区创建一个 <code>epoll</code> 相关的一些列结构，并且将一个句柄 <code>fd</code> 返回给用户态，后续的操作都是基于此 <code>fd</code> 的，<code>size</code> 用来告诉内核这个监听的数目一共有多大，类似于 <code>STL</code> 的 <code>vector</code> 动态数组，如果 <code>size</code> 不合适会涉及复制扩容，不过貌似 <code>4.1.2</code> 内核之后 <code>size</code> 已经没有太大用途了；这个参数不同于 <code>select()</code> 中的第一个参数，<code>select</code> 给出的是最大监听的 <code>fd+1</code> 的值。需要注意的是，当创建好 <code>epoll</code> 句柄后，它就是会占用一个 <code>fd</code> 值，在 <code>linux</code> 下如果查看 <code>/proc/</code> 进程 <code>id/fd/</code> ，是能够看到这个 <code>fd</code> 的，所以在使用完 <code>epoll</code> 后，必须调用 <code>close()</code> 关闭，否则可能导致 <code>fd</code> 被耗尽。</p>
</li>
<li><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</strong></p>
<p><code>epoll</code> 的事件注册函数， <code>select()</code> 是在监听事件时告诉内核要监听什么类型的事件，而是在这里 <code>epoll</code> 是先注册要监听的事件类型。第一个参数是 <code>epoll_create()</code> 的返回值，第二个参数 <strong>epoll_event</strong> 是用户态和内核态交互的结构，定义了用户态关心的事件类型和触发时数据的载体 <code>epoll_data</code> ；</p>
<ul>
<li><strong>EPOLL_CTL_ADD</strong>：注册新的 <code>fd</code> 到 <code>epfd</code> 中；</li>
<li><strong>EPOLL_CTL_MOD</strong>：修改已经注册的 <code>fd</code> 的监听事件；</li>
<li><strong>EPOLL_CTL_DEL</strong>：从 <code>epfd</code> 中删除一个 <code>fd</code> ；<br>第三个参数是需要监听的 <code>fd</code> ，第四个参数是告诉内核需要监听什么事，<strong>epoll_event是用户态需监控fd的代言人，后续用户程序对fd的操作都是基于此结构的</strong>，<code>struct epoll_event</code> 结构如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">  __uint32_t events;  /* Epoll events */</span><br><span class="line">  epoll_data_t data;  /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>events</code> 可以是以下几个宏的集合：</p>
<ul>
<li><strong>EPOLLIN</strong> ：表示对应的文件描述符可以读（包括对端 <code>SOCKET</code> 正常关闭）</li>
<li><strong>EPOLLOUT</strong>：表示对应的文件描述符可以写</li>
<li><strong>EPOLLPRI</strong>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li><strong>EPOLLERR</strong>：表示对应的文件描述符发生错误</li>
<li><strong>EPOLLHUP</strong>：表示对应的文件描述符被挂断</li>
<li><strong>EPOLLET</strong>： 将 <code>EPOLL</code> 设为边缘触发(<strong>Edge Triggered</strong>)模式，这是相对于水平触发(<strong>Level Triggered</strong>)来说的</li>
<li><strong>EPOLLONESHOT</strong>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 <code>socket</code> 的话，需要再次把这个 <code>socket</code> 加入到 <code>EPOLL</code> 队列里。</li>
</ul>
</li>
<li><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p>
<p>是阻塞等待内核返回的可读写事件，<code>epfd</code> 还是 <code>epoll_create</code> 的返回值，<code>events</code> 是个结构体数组指针存储 <code>epoll_event</code> ，也就是将内核返回的待处理 <code>epoll_event</code> 结构都存储下来，<code>maxevents</code> 告诉内核本次返回的最大 <code>fd</code> 数量，这个和 <code>events</code> 指向的数组是相关的；</p>
</li>
</ul>
<p>底层实现看<a target="_blank" rel="noopener" href="https://www.chenqi1997.top/2020/12/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/#%E4%BA%94%E7%A7%8Dio%E6%A8%A1%E5%9E%8B">这里</a></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><p>分为<strong>连续</strong>（块式）和<strong>非连续</strong>（页式、段氏等）</p>
<ol>
<li><strong>块式管理</strong> ：给每个进程分配整块内存</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是<strong>段是有实际意义的</strong>，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
<li><strong>段页式管理机制</strong> ：结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。</li>
</ol>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>程序是由若干个逻辑分段组成的，如可由<strong>代码分段、数据分段、栈段、堆段</strong>组成。</p>
<p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p>
<ul>
<li><strong>段选择因子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02211.jpg"></p>
<p>缺点：</p>
<ul>
<li>内存碎片</li>
<li>内存交换效率低</li>
</ul>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个<strong>连续并且尺寸固定的内存空间</strong>，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <strong>4KB</strong>。<strong>虚拟地址与物理地址</strong>之间通过<strong>页表</strong>来映射，如下图：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02212.jpg"></p>
<p>页表实际上存储在 CPU 的<strong>内存管理单元</strong> （<strong>MMU</strong>） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p>
<p>分页弥补分段缺陷：</p>
<ul>
<li><p>内存碎片问题：由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</p>
</li>
<li><p>交换效率问题：如果内存空间不够，操作系统会把其他正在运行的进程中的 <code>LRU</code> 等<strong>页面置换算法</strong>计算出的的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p>
</li>
</ul>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>特点如下：</p>
<ul>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧(<strong>缺页异常page fault</strong>)</li>
</ul>
<p>页表不分级的话，页表太多占用空间，所以改进使用多级页表。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02213.png"></p>
<p>多级页表实际上是增加了<strong>索引</strong>，有了索引就可以定位到具体的项。</p>
<p>缺点是增加了寻址的时间（时间换空间）</p>
<h4 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h4><p>程序是有<strong>局部性</strong>的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。我们就可以利用这一特性，<strong>把最常访问的几个页表项存储到访问速度更快的硬件</strong>，在 CPU 芯片中，<strong>加入了一个专门存放程序最常访问的页表项的 Cache</strong>，这个 Cache 就是 TLB。MMU可以先在TLB中查找页表，如果没有命中再去找页表里找。</p>
<p>当<strong>TLB</strong>不命中时，<strong>MMU</strong>必须从<strong>L1缓存</strong>中取出对应的*页表条目<strong>PTE</strong>，新取出的<strong>PTE</strong>存放在<strong>TLB</strong>中，可能会覆盖一个已经存在的<strong>PTE</strong>条目。</p>
<h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>传统页表的缺点是：<strong>逻辑地址空间增长速度快于物理地址空间</strong>，所以反向页表，也就是index是物理地址，value是逻辑地址，它的大小会小于传统页表。</p>
<p>以页帧号为 <code>index</code>，页号地址为 <code>value</code>，<strong>每次访问从前到后遍历页表</strong>，<strong>将 <code>value</code> 和逻辑地址比对</strong>，这样做的原因就是大大节省了内存的开销，全局只需要一张页表。再通过hash加速判断</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02214.jpg"></p>
<h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><ul>
<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制(代码段、数据段、栈段、堆段等等)；</li>
<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li>
</ul>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。</p>
<p>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>主要就是分内存和外存。</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了<strong>请求调页</strong>功能和<strong>页面置换</strong>功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了<strong>请求调段</strong>功能、<strong>分段置换</strong>功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>在请求分页系统中，可以通过查询<strong>页表中的状态位</strong>来确定所要访问的页面是否存在于内存中。<strong>每当所要访问的页面不在内存时，会产生一次缺页中断</strong>，此时操作系统会根据<strong>页表中的外存地址在外存中找到所缺的一页</strong>，将其调入内存。</p>
<p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p>
<ol>
<li>保护CPU现场</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序进行处理</li>
<li>恢复CPU现场，继续执行</li>
</ol>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file_name #更改文件权限，421 rwx</span><br><span class="line">df -h #查看磁盘目录使用情况</span><br><span class="line"></span><br><span class="line">top #实时查看每个进程CPU、内存利用率</span><br><span class="line">top -H #排序查看</span><br><span class="line">top -p 139 #查看进程号139的CPU内存占有率</span><br><span class="line"></span><br><span class="line"> ps -aux #瞬间查看，不实时，进程查看命令</span><br><span class="line"> grep #文本搜索 例如ps -aux|grep yfw</span><br><span class="line"> </span><br><span class="line"> netstat -an #查看网络是否连通,监听TCP和UDP连接</span><br><span class="line"> </span><br><span class="line"> ifconfig #查看ip地址网卡信息及接口信息</span><br><span class="line"> </span><br><span class="line"> du #显示目录或文件的大小</span><br><span class="line"> du -h --max-depth=1 #查看当前文件夹下文件和目录大小</span><br><span class="line"> </span><br><span class="line"> cat /proc/version #查看系统版本</span><br><span class="line"> cat /proc/cpuinfo #查看cpu信息</span><br><span class="line"> free #查看内存</span><br><span class="line"> fdisk -l #查看磁盘</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta"> #</span><span class="bash">修改环境变量</span></span><br><span class="line"> /etc/profile #所有用户生效</span><br><span class="line"> ~/.bashrc #当前用户生效</span><br></pre></td></tr></table></figure>

<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a><a target="_blank" rel="noopener" href="https://github.com/huaxz1986/APUE_notes/blob/master/chapter/3_file_IO.md">文件IO</a></h2><p><strong>文件描述符fd</strong> ：一个非负整数，范围是<code>0~OPEN_MAX-1</code>。内核用它来标识进程正在访问的文件。当进程创建时，默认为它打开了3个文件描述符，它们都链接向终端：</p>
<ul>
<li>0： 标准输入</li>
<li>1： 标准输出</li>
<li>2： 标准错误输出</li>
</ul>
<p>通常我们应该使用<code>STDIN_FILENO</code>，<code>STDOUT_FILENO</code>和 <code>STDERR_FILENO</code>来替代这三个幻数，从而提高可读性。</p>
<p><strong>打开文件</strong>：<code>open</code>和<code>openat</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path,<span class="keyword">int</span> oflag,...<span class="comment">/*mode_t mode*/</span>)</span></span>;<span class="comment">//只能绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">int</span> oflag,...<span class="comment">/*mode_t mode */</span>)</span></span>;<span class="comment">//fd可以指定相对路径为目录</span></span><br></pre></td></tr></table></figure>

<p><strong>创建文件</strong>：<code>creat</code>函数</p>
<p>成功返回fd，失败返回-1</p>
<p><strong>关闭文件</strong>：<code>close</code>函数</p>
<p>关闭文件释放所有锁，进程终止时自动关闭所有它打开的文件</p>
<p><strong>读取文件</strong>：<code>read</code>函数</p>
<p>从文件的当前偏移量开始读。</p>
<p>实际读到的字节数少于期望读到的字节数：</p>
<ul>
<li>普通文件：在读到期望字节数之前到达了文件尾端</li>
<li>终端设备：通常一次最多读取一行（行缓存）</li>
<li>网络：缓存机制</li>
<li>FIFO和管道：管道包含的字节少于所需的数量</li>
<li>被中断</li>
</ul>
<p><strong>写入文件</strong>：<code>write</code>函数</p>
<p><strong>原子定位读和原子定位写</strong>：<code>pread/pwrite</code>函数</p>
<p>调用<code>pread</code>相当于先调用<code>lseek</code>再调用<code>read</code>.但是调用<code>pread</code>时，无法中断其定位和读操作，并且不更新当前文件偏移量；</p>
<p>调用<code>pwrite</code>相当于先调用<code>lseek</code>再调用<code>write</code>.但是调用<code>pwrite</code>时，无法中断其定位和写操作，并且不更新当前文件偏移量</p>
<p><strong>延迟写刷盘</strong>：<code>sync, fsync, fdatasync</code>函数</p>
<p>磁盘IO先写到缓冲区，再刷盘，称作延迟写。这三个函数能显式刷盘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;         <span class="comment">//刷盘，不等待刷盘结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;       <span class="comment">//只对fd指定的单个文件刷盘，等待刷盘结束才返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;   <span class="comment">//同fsync，但是只影响文件的数据部分，不更新文件属性</span></span><br></pre></td></tr></table></figure>

<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p><strong>获取文件信息结构</strong>：4个<code>stat</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">restrict</span> pathname, struct stat*<span class="keyword">restrict</span> buf)</span></span>;<span class="comment">//当前文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat* buf)</span></span>;<span class="comment">//指定fd文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname,struct stat *<span class="keyword">restrict</span> buf)</span></span>;<span class="comment">//软链接信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">char</span>*<span class="keyword">restrict</span> pathname,struct stat*<span class="keyword">restrict</span> buf,<span class="keyword">int</span> flag)</span></span>;<span class="comment">//相对路径文件信息</span></span><br></pre></td></tr></table></figure>

<p><strong>文件类型</strong>：</p>
<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>系统的所有设备<ul>
<li>块特殊文件</li>
<li>字符特殊文件</li>
</ul>
</li>
<li>FIFO</li>
<li>socket</li>
<li>软链接</li>
</ul>
<p><strong>文件系统</strong></p>
<ul>
<li>分区：每个分区包含一个文件系统</li>
<li>柱面<ul>
<li>inode图：指示哪些 i 节点已经被使用，哪些未被使用</li>
<li>块位图：用于指示哪些数据块已经被使用，哪些未被使用</li>
<li>inode:许多个</li>
<li>数据区<ul>
<li>数据块</li>
<li>目录块</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03031.png"></p>
<p><strong>硬链接和软链接</strong></p>
<p>文件都有<strong>文件名与数据</strong>，这在 Linux 上被分成两个部分：<strong>用户数据</strong> (user data) 与<strong>元数据</strong> (metadata)。</p>
<ul>
<li><strong>用户数据</strong>，即文件数据块(data block)，记录文件真实内容的地方；</li>
<li><strong>元数据</strong>：记录文件的附加属性，如文件大小、创建时间、所有者等信息。<ul>
<li> <strong>inode 号</strong>：元数据的一部分，不包含文件名，是文件的唯一标识。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</li>
</ul>
</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02251.png"></p>
<p>为解决文件的共享使用，Linux 系统引入了两种链接：<strong>硬链接</strong>与<strong>软链接</strong></p>
<ul>
<li>硬链接：一个 inode 号对应多个文件名    <code>ln f1 f2</code></li>
<li>软链接：数据块中存放的内容是另一文件的路径名的指向    <code>ln -s f1 f3</code></li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02252.png"></p>
<p>每个inode可以有多个链接，删除节点时，先看是否链接计数为0，是的话在看是否没有任何一个进程在使用这个inode，是的话才删除。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a><a target="_blank" rel="noopener" href="https://github.com/huaxz1986/APUE_notes/blob/master/chapter/8_progress_control.md">进程控制</a></h2><p>进程ID：每个进程有一个pid，不同进程的pid不同，进程结束后pid可以复用。0是系统进程。1是init进程，参与系统初始化，是用户态的进程，永不终止。</p>
<p><strong>创建进程</strong>：<code>fork</code>函数</p>
<ul>
<li><code>fork</code>调用成功，子进程返回0，父进程返回子进程id（因为没有获取子进程id的函数，只能在创建时返回）</li>
<li>子进程是父进程的拷贝，共享正文段，数据空间、堆、栈不共享</li>
<li>父子进程有相同的文件描述符fd和文件偏移量，如果创建完后一起写文件的话，输出会相互混合，所以需要各自关闭它们不需要使用的文件描述符，从而避免干扰对方的文件操作</li>
<li><code>fork</code>失败的原因：进程数超过了系统的限制</li>
<li>创建子进程的目的：<ul>
<li>为了执行父进程的其他代码段</li>
<li>为了执行其他程序（<code>vfork</code>函数）</li>
</ul>
</li>
</ul>
<p><strong>进程终止</strong></p>
<ul>
<li>正常终止</li>
<li>异常终止</li>
</ul>
<p>在任意一种情况下，终止进程的父进程都能够用<code>wait</code>或者<code>waitpid</code>函数取得终止状态。然后父进程能够检测终止状态。如果发现子进程是正常终止，则可以从终止状态中提取出退出状态</p>
<p>孤儿进程：如果父进程在子进程之前终止，那么内核会将该子进程的父进程改变为<code>init</code>进程，称作由<code>init</code>进程收养。其原理为：</p>
<ul>
<li>在一个进程终止时，内核逐个检查所有活动进程，以判断这些活动进程是否是正要终止的进程的子进程</li>
<li>如果是，则该活动进程的父进程<code>ID</code>就改为 1</li>
</ul>
<p>僵尸进程：子进程已经终止，但是父进程没有调用<code>wait</code>函数或者<code>waitpid</code>函数读取终止进程的残留信息</p>
<ul>
<li>如何避免僵尸进程<ul>
<li>使用signal函数显式地忽略sigchld信号</li>
<li>使用wait函数</li>
<li>fork两次，父进程fork子进程后继续执行，子进程fork一个孙进程后退出，此时孙进程被init进程接管，避免僵尸进程</li>
</ul>
</li>
</ul>
<p><strong>初始化执行新的程序</strong>:<code>exec</code>函数</p>
<p>当进程调用一种<code>exec</code>函数时，该进程执行的程序完全替换成新程序，而新程序则从<code>main</code>函数开始执行</p>
<ul>
<li>调用<code>exec</code>前后，进程<code>ID</code>并未改变。因为<code>exec</code>并不创建新进程</li>
<li><code>exec</code>只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</li>
</ul>
<p>7个exec族函数只有<code>execve</code>是内核的系统调用。另外 6 个只是库函数。它们最终都要调用该系统调用。</p>
<p>一般配合fork使用。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在多线程并发执行的过程中，代码能够正确地得到结果，就称为线程安全。</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误</p>
<h2 id="信号安全"><a href="#信号安全" class="headerlink" title="信号安全"></a>信号安全</h2><p>在信号处理函数中可以安全调用的函数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/17/os/" data-id="ckw9lh00s002z2ww56s3cd1oa" data-title="操作系统" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-sql2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/16/sql2/" class="article-date">
  <time class="dt-published" datetime="2021-01-16T06:34:39.000Z" itemprop="datePublished">2021-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/16/sql2/">数据库面试点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="各种索引概念的区别"><a href="#各种索引概念的区别" class="headerlink" title="各种索引概念的区别"></a>各种索引概念的区别</h2><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引和非聚簇索引是从物理存储方面进行划分的。 根本区别是：<strong>表记录</strong>的排列顺序和与<strong>索引</strong>的排列顺序是否一致。</p>
<p>聚集索引表记录的排列顺序与索引的排列顺序一致，索引中包含数据。<strong>优点</strong>是查询速度快，因为一旦具有第一个索引值的纪录被找到，具有连续索引值的记录也一定物理的紧跟其后。<strong>缺点</strong>是对表进行修改速度较慢，这是为了保持表中的记录的物理顺序与索引的顺序一致，而把记录插入到数据页的相应位置，必须在数据页中进行数据重排， 降低了执行速度。</p>
<p>非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致。聚集索引和非聚集索引都采用了B+树的结构，但非聚集索引的叶子层并不与实际的存储空间直接挂钩。</p>
<h3 id="主键索引和辅助键索引"><a href="#主键索引和辅助键索引" class="headerlink" title="主键索引和辅助键索引"></a>主键索引和辅助键索引</h3><p>主键索引对主键构建的索引，是在我们创建表激活后由系统自动创建的。辅助键索引是对非主键的列构建的索引，由我们自己创建。</p>
<h3 id="一级索引和二级索引"><a href="#一级索引和二级索引" class="headerlink" title="一级索引和二级索引"></a>一级索引和二级索引</h3><p>一级索引其实就是聚簇索引（聚簇索引必定是由主键构成的），可以直接拿到值。因为其他索引都得重新走一遍聚簇索引才能拿到值。</p>
<p>二级索引是和一级索引相比较的概念，是辅助键索引有时候的称呼（存在聚簇索引就可以称呼辅助键索引为二级索引），称呼为二级索引是因为在走完辅助键索引之后，还得再走一遍聚簇索引才能取到值，所以辅助键索引地位较低。</p>
<h3 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h3><p>单列索引就是对单独一个列建立的索引。联合索引是对多个字段同时建立的索引。</p>
<h3 id="一般-normal-索引和唯一性-unique-索引"><a href="#一般-normal-索引和唯一性-unique-索引" class="headerlink" title="一般(normal)索引和唯一性(unique)索引"></a>一般(normal)索引和唯一性(unique)索引</h3><p>一般索引就是普通索引，这没什么好讲的，而唯一性索引则是在普通索引的基础上加上了索引列的唯一性的约束（允许有空值），如果是联合索引，那么索引列的组合必须唯一。比如说，一般索引举个例子，人名，国家允许多个相同人名的人出现；唯一性索引，举个例子，身份证，不允许重复，或者说你们班级里有两个同名的人，一男一女，那么（名字 + 性别）也能作为唯一性索引，反正就是必须唯一。</p>
<p><strong>B+ 树索引、哈希（hash）索引、全文（full-text）索引、空间数据（R-tree）索引</strong> 这是从索引的逻辑结构进行划分的。</p>
<ul>
<li><p>B+ 树索引：将列进行树化，变成一颗 B+ 树。InnoDB 中的聚簇索引就是 B+ 树。 主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
</li>
<li><p>哈希索引（hash index）：基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，并在哈希表中保存指向每个数据行的指针。</p>
<ul>
<li>查找速度快，时间复杂度O(1)</li>
<li>无法用于排序与分组</li>
<li>只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01162.png"></p>
</li>
<li><p>全文索引：用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，先将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。</p>
</li>
<li><p>R-tree 索引：MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。</p>
</li>
</ul>
<h2 id="聚簇索引和非聚簇索引用在什么地方？"><a href="#聚簇索引和非聚簇索引用在什么地方？" class="headerlink" title="聚簇索引和非聚簇索引用在什么地方？"></a>聚簇索引和非聚簇索引用在什么地方？</h2><p>一般我们提到聚簇索引和非聚簇索引，都是在 InnoDB 和 MyISAM 的比较中。 InnoDB 使用聚簇索引构建了主键的 B+ 树，其他辅助索引叶子节点找到的都是主键的值，然后通过主键去寻找聚簇索引的叶子节点，拿到具体的行数据。而 MyISAM 则都是非聚簇索引，即使是二级索引叶子节点存储的也是地址，跟利用主键构造的索引是一样的。</p>
<p>如下图所示，可以看到在 InnoDB 中，所有辅助键索引在查找完成之后得到的都是主键的值，还需要再次通过主键索引去查找具体的行数据（即覆盖索引，一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取，减少了 IO 操作）；而在 MyISAM 中，辅助键索引能直接找到具体的行数据的地址，这就避免了再一次的主键索引，因此光是从这方面来说，MyISAM 的查询效率应该是比 InnoDB 要高的，但是加上 IO 操作的时间就不好说了。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/0116.png"></p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>对于两个或两个以上列的索引称为联合索引。</p>
<p>索引的底层是一颗 <code>B+</code> 树，那么联合索引当然还是一棵 <code>B+</code> 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 <code>B+</code> 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个(a,b)的联合索引，那么它的索引树是这样的：</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1281680-20190117145740508-758737271.png" style="zoom: 67%;" />

<p>可以看到a的值是有顺序的：1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以 <code>b = 2</code> 这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<p>同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以<strong>最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引</strong>。例如 <code>a = 1</code> and <code>b = 2</code> a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而 <code>a&gt;1</code> and <code>b=2</code> ，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。</p>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。</p>
<p>比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p>
<p>and =和顺序无关，都会命中索引：</p>
<p>Mysql8.0之后的版本有改动，比如建立了索引（a,b,c），那么b = and c = and a = 也会使用联合索引，顺序不是abc时mysql索引优化器会自动优化。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>一个索引中包含所有需要查询字段的值</p>
<p>优点是不用回表</p>
<h2 id="如何优化索引"><a href="#如何优化索引" class="headerlink" title="如何优化索引"></a>如何优化索引</h2><ul>
<li>尽量选择惟一性索引；</li>
<li>为经常需要排序、分组和联合操作的字段建立索引；</li>
<li>为常作为查询条件的字段建立索引；</li>
<li>限制索引的数目，索引越多，更新和插入的效率越低；</li>
<li>尽量使用数据量少的索引；</li>
<li>组合索引中的尽量把能过滤掉更多数据的字段放在前面，把最经常使用的字段放在前面（最左原则）；</li>
<li>尽量使用前缀来索引，针对长文本，TEXT等类型；</li>
<li>删除不再使用或者很少使用的索引；</li>
<li>数据是动态变化中的，索引的使用也需要根据数据的变化而变化。</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><ul>
<li>非叶子节点不存储 <code>data</code> ，只存储索引(冗余)，可以放更多的索引</li>
<li>叶子节点包含所有的索引字段</li>
<li>叶子节点用指针链接，提高区间访问的性能。</li>
</ul>
<p>同为 <code>h</code> 层的 <code>B</code> 树和 <code>B+</code> 树，<code>B+</code> 树可以存储更多的结点元素（因为B+树非叶节点不存储数据），更加 ”矮胖“。这也是 <code>B+</code> 树最大的优势所在，极大地改善了 <code>B</code> 树的查找效率。对于同样多的记录，<code>B+</code> 树的高度会更矮，并且 $ P_{next} $ 指针的出现可以帮助 <code>B+</code> 树快速访问磁盘记录且效率非常高。总之，就是 <code>B+</code> 树比 <code>B</code> 树更加好，<code>B+</code> 树的磁盘 <code>I/O</code> 会更少，<strong>相比于 <code>B</code> 树的中序遍历，<code>B+</code> 树只需要像遍历单链表一样扫描一遍叶子结点。</strong></p>
<h3 id="单个元素查询"><a href="#单个元素查询" class="headerlink" title="单个元素查询"></a>单个元素查询</h3><p><strong><code>B+</code> 树中查找任何一个元素都要从根结点一直走到叶子结点 。</strong>所以<code>B+</code>树的查询很稳定，每一个元素都有相同的磁盘 <code>I/O</code> 操作次数（即树的高度）。</p>
<p><code>B+</code> 树的非叶子结点均不存储 <code>Data</code> (即$D_i$，官方将其称为卫星数据) ，所以与 <code>B</code> 树相比，同样大小的磁盘页， <code>B+</code> 树的非叶子结点可以存储更多的索引（关键字），这也就意味着在数据量相同的情况下，<code>B+</code> 树的结构比 <code>B</code> 树更加 “矮胖”，查询时磁盘 <code>I/O</code> 次数会更少。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01164.jpg" alt="图片"></p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>在 <code>B+</code> 树中插入关键字时，需要注意以下几点：</p>
<ul>
<li><strong>插入的操作全部都在叶子结点上进行</strong>，且不能破坏关键字自小而大的顺序；</li>
<li>由于 <code>B+</code> 树中<strong>各结点中存储的关键字的个数有明确的范围</strong>，做插入操作可能会出现结点中关键字个数超过阶数的情况，此时需要将该结点进行 “分裂”；</li>
</ul>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01165.jpg" alt="图片" style="zoom:80%;" />

<p>我们依旧以之前介绍查找操作时使用的图对插入操作进行说明，需要注意的是，<code>B+</code> 树的阶数 <code>M = 3</code> ，且 <code>⌈M/2⌉ = 2（取上限）</code> 、<code>⌊M/2⌋ = 1（取下限）</code> ：</p>
<p><strong><code>B+</code> 树中做插入关键字的操作，有以下 4 种情况：</strong></p>
<ol>
<li><p><strong>若被插入关键字所在的结点，其含有关键字数目小于阶数 <code>M</code> ，则直接插入；</strong></p>
<p>比如插入关键字 <code>12</code> ，插入关键字所在的结点的 <code>[10，15]</code> 包含两个关键字，小于 <code>M</code> ，则直接插入关键字 <code>12</code> 。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01166.gif" alt="图片"></p>
</li>
<li><p><strong>若被插入关键字所在的结点，其含有关键字数目等于阶数 <code>M</code> ，则需要将该结点分裂为两个结点.</strong></p>
<p>一个结点包含 <code>⌊M/2⌋(1)</code> ，另一个结点包含 <code>⌈M/2⌉(2)</code> 。同时，<strong>将<code>⌈M/2⌉</code>的关键字上移至其双亲结点</strong>。假设其双亲结点中包含的关键字个数小于 M，则插入操作完成。</p>
<p>比如插入关键字 <code>95</code> ，插入关键字所在结点 <code>[85、91、97]</code> 包含 3 个关键字，等于阶数 <code>M</code> ，则将 <code>[85、91、97]</code> 分裂为两个结点 <code>[85、91]</code> 和结点 <code>[97]</code> , 关键字 <code>95</code> 插入到结点 <code>[95、97]</code> 中，并将关键字 <code>91</code> 上移至其双亲结点中，发现其双亲结点 <code>[72、97]</code> 中包含的关键字的个数 2 小于阶数 <code>M</code> ，插入操作完成。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01167.gif" alt="图片"></p>
</li>
<li><p><strong>在情况 2 中，如果上移操作导致其双亲结点中关键字个数大于 M，则应继续分裂其双亲结点。</strong></p>
<p>插入关键字 <code>40</code> ，按照第 2 种情况将结点分裂，并将关键字 <code>37</code> 上移到父结点，发现父结点 <code>[15、37、44、59]</code> 包含的关键字的个数大于 <code>M</code> ，所以将结点 <code>[15、37、44、59]</code> 分裂为两个结点 <code>[15、37]</code> 和结点 <code>[44、59]</code> ，并将关键字 <code>37</code> 上移到父结点中 <code>[37、59、97]</code> . 父结点包含关键字个数没有超过 <code>M</code> ，插入结束。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01168.gif" alt="图片"></p>
</li>
<li><p><strong>若插入的关键字比当前结点中的最大值还大，破坏了B+树中从根结点到当前结点的所有索引值，此时需要及时修正后，再做其他操作。</strong></p>
<p>插入关键字 <code>100</code>，由于其值比最大值 <code>97</code> 还大，插入之后，从根结点到该结点经过的所有结点中的所有值都要由 <code>97</code> 改为 <code>100</code>。改完之后再做分裂操作。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01169.gif" alt="图片"></p>
</li>
</ol>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在 <code>B+</code> 树中做删除关键字的操作，采取如下的步骤：</p>
<ol>
<li>删除该关键字，如果不破坏 <code>B+</code> 树本身的性质，直接完成删除操作（情况 1）；</li>
<li>如果删除操作导致其该结点中最大（或最小）值改变，则应相应改动其父结点中的索引值（情况 2）；</li>
<li>在删除关键字后，如果导致其结点中关键字个数不足，有两种方法：一种是向兄弟结点去借，另外一种是同兄弟结点合并（情况 3、4 和 5）。（注意这两种方式有时需要更改其父结点中的索引值。）</li>
</ol>
<p>详细见 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMTI2Ng==&mid=2247485029&idx=1&sn=8ca8c6e4f0db55cb61d297881773e51f&chksm=e9d0c828dea7413e0f64d04337758c9b4713d6f51e33efc2d560561f06e8748f02497da71b06&scene=126&sessionid=1609566026#rd">B+树详解</a></p>
<h3 id="存储能力"><a href="#存储能力" class="headerlink" title="存储能力"></a>存储能力</h3><p>对于 <code>B+</code> 树而言，树的高度一般不超过 <code>4</code> 层，就 <code>MySQL</code> 的 <code>InnoDB</code> 存储引擎而言，一个结点默认的存储空间为 <strong>16Kb</strong> ( 可以通过这个命令查看 <code>SHOW GLOBAL STATUS like &#39;Innodb_page_size&#39;;</code> )， <code>MySQL</code> 的 <code>InnoDB</code> 存储引擎的索引一般用 <code>bigint</code> 存储，占用 <strong>8个byte</strong>，一个索引又会关联一个指向孩子结点的指针，这个指针占用 <strong>6个byte</strong>，也就是说结点中的一个关键字大概要用 <strong>14 byte</strong> 的空间，而一个结点的默认大小为 <strong>16kb</strong> ，那么一个结点可以存储关键的个数最多为 <strong>16384/14=1170</strong> , 就相当于阶数 ，那么对于一颗高度为 <code>3</code> 的 <code>B+</code>树而言保守估计可以存储 <strong>1170*1170*16=21902400</strong> 个关键字，也就是两千多万条记录，其中的 <code>16</code> 为假定每一个叶子结点包含的关键字的个数（由于包含 Data 指针，所以叶子结点可以容纳的关键字的个数会少一些），3层的 <code>B+</code> 树就可以存储两千多万的数据。</p>
<hr>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="什么是锁？MySQL-中提供了几类锁？"><a href="#什么是锁？MySQL-中提供了几类锁？" class="headerlink" title="什么是锁？MySQL 中提供了几类锁？"></a>什么是锁？MySQL 中提供了几类锁？</h2><p>锁是多用户竞争的一种临界资源，是实现数据库并发控制的重要手段，可以保证数据库在多人同时操作时能够正常运行。MySQL 提供了全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。</p>
<h2 id="锁的划分"><a href="#锁的划分" class="headerlink" title="锁的划分"></a>锁的划分</h2><ul>
<li>按照锁的粒度划分：行锁、表锁、页级索、全局锁</li>
<li>按照锁的使用方式划分：共享锁、互斥锁（悲观锁的一种实现）</li>
<li>还有两种思想上的锁：悲观锁、乐观锁</li>
<li>在读写锁的基础上引入的意向锁，实现锁的细粒度化</li>
<li>InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock<ul>
<li>Record Lock：在索引记录上加锁</li>
<li>Gap Lock：间隙锁</li>
<li>Next-key Lock：Record Lock+Gap Lock</li>
</ul>
</li>
</ul>
<p>(1) 行锁、表锁、全局锁：行锁是对行数据进行加锁，表锁是对整张表进行加锁，页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，一次锁定相邻的一组记录，而全局锁是对整个数据库进行加锁，典型的使用场景就是全库逻辑备份。</p>
<p>(2) 共享锁、互斥锁:互斥锁（Exclusive），简写为 X 锁，又称写锁。共享锁（Shared），简写为 S 锁，又称读锁。</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>(3) 悲观锁、乐观锁</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>概述</th>
<th>使用场景</th>
<th>样例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>悲观锁</strong></td>
<td>悲观锁对数据被外界修改持保守态度（悲观），因此在整个数据处理过程中，将数据出于锁定状态，而别的任务处于被阻塞的状态；</td>
<td>写多读少，保证写操作时的数据安全</td>
<td>1、JVM中的synchronized和Lock；2、分布式环境基于数据库行锁、页锁、表锁、共享锁（读锁）、排它锁（写锁）；3、基于zookeeper、Redis 的分布式锁</td>
</tr>
<tr>
<td><strong>乐观锁</strong></td>
<td>乐观锁认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，程序自动去重试（实现通常用“版本号”,也可以用CAS）</td>
<td>读多写少，提高系统吞吐</td>
<td>1、JDK并发包中的原子类；2、数据库乐观锁、缓存乐观锁</td>
</tr>
</tbody></table>
<p>(4) 意向锁 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 下图是意向锁之间的兼容关系</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>IX</td>
<td>/</td>
<td></td>
<td>/</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>/</td>
<td>/</td>
<td></td>
<td></td>
</tr>
<tr>
<td>IS</td>
<td>/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<p>(5) Record Lock、Gap Lock、Next-key Lock 首先，我们要明确这三者都是 InnoDB 中<strong>行级锁</strong>的范围，并且这三种锁作用的基础和对象都是<strong>索引</strong>。</p>
<ul>
<li>行锁（Record Lock），在单条索引记录上加锁，record lock 锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的；</li>
<li>间隙锁（Gap Lock），在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题；</li>
<li>Next-Key Lock，是行锁和间隙锁的组合使用，默认情况下，InnoDB工作在可重复读隔离级别下，并且会以 Next-Key Lock 的方式对数据行进行加锁，这样可以有效防止幻读的发生。当 InnoDB 扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</li>
<li>当以当前读模式<code>select * from t5 where id=7 for update;</code>获取 <code>id=7</code> 的数据时,产生了 <code>Next-Key Lock</code> ，锁住了 <code>4-10</code> 范围和 <code>id=7</code> 单个 <code>record</code> ，从而阻塞了 <code>SESSION_B</code> 在这个范围内插入数据，而在除此之外的范围内是可以插入数据的。<strong>尽量使用唯一索引,因为唯一索引会把Next-Key Lock降级为Record Lock</strong></li>
</ul>
<h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的过程称为死锁。</p>
<ul>
<li>MyISAM 不会出现死锁，因为 MyISAM 总是一次获得所需要的全部锁，要么全部满足，要么全等待；</li>
<li>InnoDB 除了单 SQL 事务，锁是逐步获得的，因此可能出现死锁。一般 InnoDB 能自动检测死锁，并使一个较简单的事务回退并释放锁，另一个事务获得锁，继续完成事务。</li>
</ul>
<h2 id="如何处理死锁"><a href="#如何处理死锁" class="headerlink" title="如何处理死锁"></a>如何处理死锁</h2><p>对待死锁常见的两种策略：</p>
<ul>
<li>通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时；</li>
<li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</li>
</ul>
<h2 id="如何判断死锁"><a href="#如何判断死锁" class="headerlink" title="如何判断死锁"></a>如何判断死锁</h2><p>(1) 超时法：如果某个事物的等待时间超过指定时限，则判定为出现死锁</p>
<p>(2) 等待图法：等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁</p>
<h2 id="如何查看死锁"><a href="#如何查看死锁" class="headerlink" title="如何查看死锁"></a>如何查看死锁</h2><ul>
<li>使用命令 show engine innodb status 查看最近的一次死锁。</li>
<li>InnoDB Lock Monitor 打开锁监控，每 15s 输出一次日志。使用完毕后建议关闭，否则会影响数据库性能。</li>
</ul>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>(1) 按同一顺序访问对象 如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。</p>
<p>(2) 避免事务中的用户交互 避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。</p>
<p>(3) 保持事务简短并在一个批处理中 在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。 保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。</p>
<p>(4) 使用低隔离级别 确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。</p>
<p>(5) 使用绑定连接 使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞</p>
<p>(6) SELECT语句加With(NoLock)提示 默认情况下SELECT语句会对查询到的资源加 S 锁(共享锁)，S锁与X锁(排他锁)不兼容；但加上 With(NoLock) 后，SELECT不对查询到的资源加锁(或者加 Sch-S 锁，Sch-S 锁可以与任何锁兼容)；从而可以是这两条 SQL 可以并发地访问同一资源。当然，此方法适合解决读与写并发死锁的情况，但加 With(NoLock) 可能会导致脏读。</p>
<h2 id="优化锁方面的建议"><a href="#优化锁方面的建议" class="headerlink" title="优化锁方面的建议"></a>优化锁方面的建议</h2><ul>
<li>尽量使用较低的隔离级别。</li>
<li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会。</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小。</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁。</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会。</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响。</li>
<li>不要申请超过实际需要的锁级别。</li>
<li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能；MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ul>
<hr>
<h1 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是<strong>一系列的数据库操作，是数据库应用的基本单位</strong>。MySQL 事务主要用于处理操作量大，复杂度高的数据。</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>在 MySQL 中只有 InnDB 引擎支持事务，它的四个特性如下：</p>
<ul>
<li>原子性（Atomic）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位；</li>
<li>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态，事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到；</li>
<li>隔离性（Isolation）：事物之间的并发是隔离的。在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务，同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账；</li>
<li>持久性（Durability）：事务提交后，其结果永久保存在数据库中。</li>
</ul>
<h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><ul>
<li>脏读（select）：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 </li>
<li>不可重复读（update）：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。 </li>
<li>幻读（insert/delete）：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ul>
<p><strong>幻读和不可重复读的区别？</strong></p>
<ul>
<li>不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）。</li>
<li>幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</li>
<li>解决不可重复读：锁行；解决幻读：锁表</li>
</ul>
<h2 id="MySQL-中有几种事务隔离级别"><a href="#MySQL-中有几种事务隔离级别" class="headerlink" title="MySQL 中有几种事务隔离级别"></a>MySQL 中有几种事务隔离级别</h2><p>四种隔离级别主要解决的是脏读、幻读和不可重复读的问题。</p>
<h3 id="读未提交-Read-uncommitted"><a href="#读未提交-Read-uncommitted" class="headerlink" title="读未提交(Read uncommitted)"></a>读未提交(Read uncommitted)</h3><p><code>select</code> 语句不加锁。可能读取到不一致的数据，即<strong>脏读</strong>。</p>
<p>并发最高，一致性最差的隔离级别。</p>
<h3 id="读已提交-Read-committed"><a href="#读已提交-Read-committed" class="headerlink" title="读已提交(Read committed)"></a>读已提交(Read committed)</h3><p>可避免<strong>脏读</strong>的发生，但是会有<strong>幻读</strong>和<strong>不可重复读</strong>的问题。在互联网大数据量，高并发量的场景下，几乎 <strong>不会使用</strong> 上述两种隔离级别。</p>
<p>各种系统中最常用的一种隔离级别，也是SQL Server和Oracle的默认隔离级别。</p>
<p>默认查询不加锁，除非显示加锁，如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<p>使用快照机制来实现读提交：数据有多个版本， 当事务并发执行时， 某一事务读取的数据来自其中一个版本（快照）。</p>
<p>这种既能保证一致性又不加锁的读也被称为快照读 （<strong>Snapshot Read</strong>）。假设没有“快照读”，那么当一个更新的事务没有提交时，另一个对更新数据进行查询的事务会因为无法查询而被阻塞（因为上了X锁，即写锁，所以不能得到S锁，即读锁），这种情况下，并发能力就相当的差。而“快照读”就可以完成高并发的查询，不过，读提交只能避免脏读，并不能避免不可重复读和幻读。</p>
<h3 id="可重复读-Repeatable-read"><a href="#可重复读-Repeatable-read" class="headerlink" title="可重复读(Repeatable read)"></a>可重复读(Repeatable read)</h3><p>当事务启动时，就不允许进行修改操作(<code>Update</code>) 。</p>
<p><strong><code>MySql</code> 默认隔离级别</strong>。可避免 脏读 、不可重复读的发生。不可重复读对应的是修改，即 <code>UPDATE</code> 操作。但是可能还会有幻读问题。因为幻读问题对应的是插入 <code>INSERT</code> 操作，而不是 <code>UPDATE</code> 操作。</p>
<p>在这个级别下，普通的查询同样是使用的<strong>快照读</strong>，但是，和读提交不同的是，当事务启动时，就不允许进行修改操作(<code>Update</code>) 了，而“不可重复读”恰恰是因为两次读取之间进行了数据的修改，因此，“可重复读”能够有效的避免“不可重复读”。</p>
<h3 id="串行化-Serializable"><a href="#串行化-Serializable" class="headerlink" title="串行化(Serializable)"></a>串行化(Serializable)</h3><p>可避免 <strong>脏读、不可重复读、幻读</strong> 的发生。 <code>Serializable</code> 是一致性最好的，性能最差的。这种级别下，事务串行化顺序执行，也就是一个一个排队执行。执行效率奇差，性能开销也最大，所以基本没人会用。</p>
<p>以 <strong>锁表</strong> 的方式使得其他的线程只能在锁外等待。</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读提交（read-commited）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>mysql 默认的事务隔离级别为 repeatable-read</p>
<h2 id="什么是快照读、当前读"><a href="#什么是快照读、当前读" class="headerlink" title="什么是快照读、当前读"></a>什么是快照读、当前读</h2><ul>
<li><p><strong>快照读</strong>, 读取专门的快照 (对于 <code>RC</code> ，快照( <code>ReadView</code> )会在每个语句中创建。对于 <code>RR</code> ，快照是在事务启动时第一次select时创建)</p>
<p>普通的SELECT就是快照读</p>
</li>
<li><p><strong>当前读</strong>, 读取最新版本的记录, 没有快照。 在 <code>InnoDB</code> 中，当前读取根本不会创建任何快照。当前读会在搜索的时候加锁</p>
<p>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE是当前读</p>
</li>
</ul>
<h2 id="为什么RR可以解决不可重复读，RC不行"><a href="#为什么RR可以解决不可重复读，RC不行" class="headerlink" title="为什么RR可以解决不可重复读，RC不行"></a>为什么RR可以解决不可重复读，RC不行</h2><ul>
<li>RR事务开启后，第一次select创建快照和ReadView,之后一直复用这个ReadView，不会再更新数据，所以重复读都是同样的数据</li>
<li>RC事务开启后，每次select都创建快照和ReadView，可以看到别的事务提交的更新。所以会出现不可重复读问题</li>
</ul>
<h2 id="MySql如何解决幻读问题"><a href="#MySql如何解决幻读问题" class="headerlink" title="MySql如何解决幻读问题"></a>MySql如何解决幻读问题</h2><p>两点需要说明：</p>
<ol>
<li>在可重复读隔离级别下，普通查询是<strong>快照读</strong>，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。</li>
<li>幻读专指新插入的行，读到原本存在行的更新结果不算幻读。因为<strong>当前读的作用就是能读到所有已经提交记录的最新值</strong>。如果事务中都使用快照读，那么就不会产生幻读现象，但是<strong>快照读和当前读混用就会产生幻读</strong>。</li>
</ol>
<p><strong>幻读产生的原因</strong></p>
<p>行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。</p>
<p><strong>如何解决幻读？</strong></p>
<ol>
<li><p>在<strong>快照读</strong>情况下，<code>mysql</code> 通过<strong>mvcc</strong>来避免幻读</p>
<p>事务第一次读的时候创建一致性视图，之后的读都复用这个视图。</p>
</li>
<li><p>在<strong>当前读</strong>情况下，<code>mysql</code> 通过<strong>next-key lock</strong>来避免幻读</p>
</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30342639/article/details/107552255">MVCC</a></h3><p>MVCC 是多版本并发控制（Multi-Version Concurrency Control）的简称，是用来解决事务中排他锁的使用导致读操作等待的。</p>
<p>在四种隔离级别中，不可重复读和可重复读是使用了 MVCC 的，而串行化是使用了表级锁，读未提交好像什么都没实现。</p>
<p>通过Undo日志中的<strong>版本链</strong>和<strong>ReadView一致性视图</strong>来实现。在MySQL中，会默认为我们的表后面添加两个隐藏字段：</p>
<ul>
<li><strong>DB_TRX_ID</strong>：事务ID，记录的是当前事务在做INSERT或UPDATE语句操作时的事务ID</li>
<li><strong>DB_ROLL_PTR</strong>：回滚指针，通过它可以将不同的版本串联起来，形成版本链。相当于链表的next指针</li>
</ul>
<p><strong>一致性视图</strong>（ReadView）：<strong>所有未提交事务的ID数组</strong>和<strong>已经创建的最大事务ID</strong>组成。比如：[100,200],300。事务100和200是当前未提交的事务，而事务300是当前创建的最大事务（已经提交了）。</p>
<ul>
<li>读已提交：每执行一次SELECT语句就会重新生成一份ReadView</li>
<li>可重复读：第一次SELECT语句执行的时候生成一份，后续的SELECT语句会沿用之前生成的ReadView</li>
</ul>
<p><strong>版本链</strong>：所有版本的数据都只会存一份，然后通过回滚指针连接起来</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03011.png"></p>
<p>举个例子</p>
<p>当前account表中已经有了一条初始数据（id=1,name=monkey）：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03012.png"></p>
<p>注意：select语句没有事务id，因为事务ID是执行一条更新操作（增删改）的语句后才会生成，并不是开启事务的时候就会生成。</p>
<p>假定在可重复读模式下运行。</p>
<ul>
<li><p>时刻1：五个事务分别开启了事务（如上所说，这个时候还没有生成事务ID）。</p>
</li>
<li><p>时刻2：第一个事务执行了一条UPDATE语句，生成了事务ID为100。</p>
</li>
<li><p>时刻3：第二个事务执行了一条UPDATE语句，生成了事务ID为200。</p>
</li>
<li><p>时刻4：第三个事务执行了一条UPDATE语句，将account表中id为1的name改为了monkey301。同时生成了事务ID为300。</p>
</li>
<li><p>时刻5：事务300执行commit操作。</p>
</li>
<li><p>时刻6：第四个事务执行了一条SELECT语句</p>
<p>此时第四个事务生成了一个Readview(并且该事务之后一直沿用这个视图)，一致性视图是[100,200],300.</p>
<p>版本链如下：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03013.png"></p>
<p>拿版本链中的第一个版本的事务ID为300进行比对，发现300在ReadView中不在未提交数组[100,200],所以立即读取数据，返回monkey301</p>
</li>
<li><p>时刻7：事务100执行了一条UPDATE语句，将account表中id为1的name改为了monkey101。</p>
</li>
<li><p>时刻8：事务100又执行了一条UPDATE语句，将account表中id为1的name改为了monkey102。</p>
</li>
<li><p>时刻9：第四个事务执行了一条SELECT语句，想要查询一下当前id为1的数据。</p>
<p>此时如前所述，一致性视图沿用时刻6创建的视图：[100,200],300,版本链如下</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03014.png"></p>
<p>拿版本链中的第一个版本的事务ID为100比对，发现在未提交数组[100,200]中，拿下一个版本，还是100，再拿下一个版本，是300，,300不在未提交数组里，返回数据monkey301.</p>
</li>
<li><p>时刻10：事务100commit提交事务了。同时事务200执行了一条UPDATE语句，将account表中id为1的name改为了monkey201。</p>
</li>
<li><p>时刻11：事务200又执行了一条UPDATE语句，将account表中id为1的name改为了monkey202。</p>
</li>
<li><p>时刻12：第四个事务执行了一条SELECT语句，想要查询一下当前id为1的数据。</p>
<p>继续复用时刻6的视图，版本链如下</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03015.png"></p>
<p>和之前一样的分析，最后返回monkey301.</p>
<p>同时，第五个事务执行了一条SELECT语句，想要查询一下当前id为1的数据。</p>
<p>因为是该事务内的第一条SELECT语句，第五个事务会创建一个ReadView,[200],300。</p>
<p>拿版本链中的第一个版本的事务ID为200比对，发现在未提交数组[200]中，拿下一个版本，还是200，再拿下一个版本，是100，不在未提交数组中，返回数据monkey102.</p>
</li>
<li><p>时刻13：事务200执行了commit操作，整段分析过程结束。</p>
</li>
</ul>
<p>如果是DELETE语句的话，也会在版本链上将最新的数据插入一份，然后将事务ID赋值为当前进行删除操作的事务ID。但是同时会在该条记录的信息头（record header）里面的deleted_flag标记位置为true，以此来表示当前记录已经被删除。所以如果经过版本比对后发现找到的版本上的deleted_flag标记位为true的话，那么也不会返回，而是继续寻找下一个。</p>
<p>如果当前事务执行rollback回滚的话，会把版本链中属于该事务的所有版本都删除掉。</p>
<h3 id="Next-key-lock"><a href="#Next-key-lock" class="headerlink" title="Next-key lock"></a>Next-key lock</h3><p>Gap Lock+Record Lock</p>
<p>解决幻读问题，在进行行查询的时候，对选中的索引记录加上行锁(Record Lock)，再对索引记录两边的间隙加上间隙锁(Gap Lock) 。注意，只出现在辅助索引上，对于主键和唯一索引，没有间隙锁。</p>
<p>例子：</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03016.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b <span class="operator">=</span> <span class="number">6</span> <span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>

<p>此时对b=6加上next-key lock。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03017.png"></p>
<p>判断一个新的查询是否会被阻塞，先看索引b，再看主键id。</p>
<ul>
<li>b&lt;4,不阻塞</li>
<li>b=4<ul>
<li>id&lt;3，不阻塞</li>
<li>id&gt;3，阻塞</li>
</ul>
</li>
<li>4&lt;b&lt;8，阻塞</li>
<li>b=8<ul>
<li>id&lt;7，阻塞</li>
<li>id&gt;7，不阻塞</li>
</ul>
</li>
</ul>
<h2 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h2><p><strong>锁定读</strong> 在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE。 <code>SELECT ... LOCK IN SHARE MODE</code>给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交。<code>SELECT ... FOR UPDATE</code>给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的。</p>
<p><strong>一致性非锁定读</strong> 　consistent read （一致性读），InnoDB 用多版本来提供查询数据库在某个时间点的快照。</p>
<p>如果隔离级别是 REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；</p>
<p>如果是 READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本</p>
<p>Consistent read（一致性读）是 READ COMMITTED 和 REPEATABLE READ 隔离级别下普通 SELECT 语句默认的模式。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h2><p>将修改行为（无论是否提交）先写到redo日志里，然后更新内存，再定期将数据刷到磁盘上。</p>
<p>InnoDB 记录了对数据文件的物理更改，并保证总是<strong>日志先行</strong>，也就是所谓的 WAL(Write-Ahead Logging)，即在持久化数据文件前，保证之前的 redo 日志已经写到磁盘。</p>
<p>重做日志有一个缓存区<strong>Innodb_log_buffer</strong>，先写入缓存区，当以下三种情况发生，才从缓存区写入磁盘</p>
<ul>
<li><code>Master Thread</code> 每秒一次执行刷新 <code>Innodb_log_buffer</code> 到 <code>redo log</code> 文件。</li>
<li>每个事务提交时会将重做日志刷新到 <code>redo log</code> 文件。</li>
<li>当重做日志缓存可用空间少于一半时，重做日志缓存被刷新到 <code>redo log</code> 文件。</li>
</ul>
<p>保障原子性和持久性</p>
<h2 id="回滚日志（undo-log）"><a href="#回滚日志（undo-log）" class="headerlink" title="回滚日志（undo log）"></a>回滚日志（undo log）</h2><p>记录了每一条操作的相反操作，表示逻辑上如何操作来恢复至事务之前的状态。</p>
<p>提供回滚和多版本并发控制下的读(MVCC)/非锁定读。</p>
<ul>
<li><p>insert undo log</p>
<p>代表事务在 <code>insert</code> 新记录时产生的 <code>undo log</code>, <strong>只在事务回滚时需要</strong>，并且在事务提交后可以被立即丢弃</p>
</li>
<li><p>update undo log</p>
<p>事务在进行 <code>update</code> 或 <code>delete</code> 时产生的 <code>undo log</code>; 不仅在事务回滚时需要，在<strong>快照读</strong>时也需要；所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被<code>purge</code>线程统一清除</p>
</li>
</ul>
<p>在 MySQL 5.7 之前，<code>undo log</code> 存储在共享表空间中，因此有可能大大增加表空间的占用，5.7 之后可以通过配置选择存储在独立的表空间中。</p>
<h2 id="二进制日志（binlog）"><a href="#二进制日志（binlog）" class="headerlink" title="二进制日志（binlog）"></a>二进制日志（binlog）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>binlog是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以”事务”的形式保存在磁盘中；</p>
<p>作用主要有：</p>
<ul>
<li>复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的</li>
<li>数据恢复：通过mysqlbinlog工具恢复数据</li>
<li>增量备份</li>
</ul>
<h3 id="binlog管理"><a href="#binlog管理" class="headerlink" title="binlog管理"></a>binlog管理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;<span class="comment">--查看其位置信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="type">binary</span> logs;<span class="comment">--查看binlog文件列表</span></span><br><span class="line"><span class="keyword">show</span> master status;<span class="comment">--显示正在写入的二进制文件，及当前position</span></span><br><span class="line">reset master; <span class="comment">--清空binlog日志文件</span></span><br></pre></td></tr></table></figure>

<h3 id="binlog内容"><a href="#binlog内容" class="headerlink" title="binlog内容"></a>binlog内容</h3><p>简单认为就是执行过的事务中的sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--两种查看binlog的方法</span></span><br><span class="line">mysqlbinlog: <span class="operator">/</span>usr<span class="operator">/</span>bin<span class="operator">/</span>mysqlbinlog  mysql<span class="operator">-</span>bin<span class="number">.000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> BINLOG EVENTS</span><br><span class="line">            [<span class="keyword">IN</span> <span class="string">&#x27;log_name&#x27;</span>] <span class="comment">--要查询的binlog文件名</span></span><br><span class="line">            [<span class="keyword">FROM</span> pos]  </span><br><span class="line">            [LIMIT [<span class="keyword">offset</span>,] row_count]</span><br></pre></td></tr></table></figure>

<h3 id="binlog格式"><a href="#binlog格式" class="headerlink" title="binlog格式"></a>binlog格式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;<span class="comment">--查看binglog格式</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> binlog_format<span class="operator">=</span><span class="string">&#x27;ROW/STATEMENT/MIXED&#x27;</span>;<span class="comment">--修改binglog格式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ROW：仅保存记录每一行数据被修改细节，不记录 sql 语句上下文相关信息(新版本binlog默认为ROW level)<ul>
<li>优点：记录下每行数据的修改细节，不需要记录上下文相关信息，任何情况都可以被复制，且能加快从库重放日志的效率，保证从库数据的一致性</li>
<li>缺点：产生大量的日志内容，干扰内容较多；</li>
</ul>
</li>
<li>STATEMENT：每一条会修改数据的 sql 都会记录在 binlog 中<ul>
<li>优点：只需要记录执行语句的细节和上下文环境，避免了记录每一行的变化，减少日志量，节约IO，提高性能；还可以用于实时的还原；同时主从版本可以不一样，从服务器版本可以比主服务器版本高</li>
<li>缺点：必须记录上下文信息，以保证所有语句能在slave得到和在master端执行时候相同的结果；另外，主从复制时，存在部分函数（如sleep）及存储过程在slave上会出现与master结果不一致的情况。</li>
</ul>
</li>
<li>MIXED：以上两种 level 的结合。</li>
</ul>
<p>一般使用row level就行。</p>
<h3 id="binlog产生-释放"><a href="#binlog产生-释放" class="headerlink" title="binlog产生/释放"></a>binlog产生/释放</h3><p>事务提交时，一次性写入该事务的所有sql语句到binlog中。</p>
<p>对于非活动的日志文件，在生成时间超过<strong>expire_logs_days</strong>配置的天数之后，会被自动删除</p>
<h3 id="binlog与redo-log区别"><a href="#binlog与redo-log区别" class="headerlink" title="binlog与redo log区别"></a>binlog与redo log区别</h3><ul>
<li>产生时间不同：<ul>
<li>redo log事务开启后逐步写入（1秒写一次，buffer超一半写一次）</li>
<li>binlog事务提交时一次性写</li>
</ul>
</li>
<li>作用不同：<ul>
<li>redo log是保证事务层面的持久性，InnoDB引擎提供</li>
<li>bin log是保证数据库层面的持久性，server层提供</li>
</ul>
</li>
<li>内容不同：<ul>
<li>redo log是物理日志，记录了数据的真实修改</li>
<li>binlog是逻辑日志，记录了sql语句</li>
</ul>
</li>
<li>数据恢复效率：redo log更快</li>
</ul>
<p>为了保证主从复制时候的主从一致，MySQL使用两阶段提交过程，即 redo log 和 binlog的一致性，两个日志都提交成功（刷入磁盘），事务才算真正的完成。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33504555">主从复制</a></h3><ol>
<li>Master将数据改变记录到二进制日志(binary log)中</li>
<li>Slave的IO进程连接上Master，并请求从指定日志文件的指定位置之后的日志内容</li>
<li>Master接收到来自Slave的IO进程的请求后，负责复制的IO进程根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置</li>
<li>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到<strong>master-info</strong>文件中，以便在下一次读取的时候能够清楚的告诉Master从某个bin-log的哪个位置开始往后的日志内容</li>
<li>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行</li>
</ol>
<h3 id="InnoDB完成一次更新操作的步骤"><a href="#InnoDB完成一次更新操作的步骤" class="headerlink" title="InnoDB完成一次更新操作的步骤"></a>InnoDB完成一次更新操作的步骤</h3><ol>
<li>开启事务</li>
<li>查询待更新的记录到内存，并加 <code>X</code> 锁</li>
<li>记录 undo log 到内存 buffer</li>
<li>记录 redo log 到内存 buffer</li>
<li>更改内存中的数据记录</li>
<li>提交事务</li>
<li>redo log 刷盘</li>
<li>记录 bin log</li>
<li>事务结束</li>
</ol>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/03021.png" style="zoom:67%;" />

<h2 id="错误日志（errorlog）"><a href="#错误日志（errorlog）" class="headerlink" title="错误日志（errorlog）"></a>错误日志（errorlog）</h2><p>错误日志记录着 mysqld 启动和停止，以及服务器在运行过程中发生的错误的相关信息。</p>
<p>在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</p>
<p>指定日志路径两种方法:</p>
<p>编辑my.cnf 写入 <code>log-error=[path]</code><br>通过命令参数错误日志 <code>mysqld_safe –user=mysql –log-error=[path] &amp;</code></p>
<h2 id="慢查询日志（slow-query-log）"><a href="#慢查询日志（slow-query-log）" class="headerlink" title="慢查询日志（slow query log）"></a>慢查询日志（slow query log）</h2><p>慢日志记录<strong>执行时间过长</strong>和<strong>没有使用索引的查询语句</strong>，报错 <code>select</code> 、<code>update</code> 、<code>delete</code> 以及 <code>insert</code> 语句，慢日志只会记录执行成功的语句。</p>
<p>几个配置参数：</p>
<ul>
<li><strong>slow_query_log</strong> 慢查询开启状态</li>
<li><strong>slow_query_log_file</strong> 慢查询日志存放的位置（这个目录需要 MySQL 的运行帐号的可写权限，一般设置为 MySQL 的数据存放目录）</li>
<li><strong>long_query_time</strong> 查询超过多少秒才记录</li>
<li><strong>log_queries_not_using_indexes</strong>：未使用索引的查询也被记录到慢查询日志中（可选项）</li>
</ul>
<h2 id="一般查询日志（general-log）"><a href="#一般查询日志（general-log）" class="headerlink" title="一般查询日志（general log）"></a>一般查询日志（general log）</h2><p>记录了服务器接收到的每一个查询或是命令。Mysql默认是把General log关闭的。</p>
<h2 id="中继日志（relay-log）"><a href="#中继日志（relay-log）" class="headerlink" title="中继日志（relay log）"></a>中继日志（relay log）</h2><p>拷贝binlog内容，并应用到从服务器，从而使从服务器和主服务器的数据保持一致。</p>
<p>参数：</p>
<ul>
<li>sync_relay_log<ul>
<li>当设置为1时，slave的I/O线程每次接收到master发送过来的binlog日志都要写入系统缓冲区，然后刷入relay log中继日志里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量I/O；</li>
<li>当设置为0时，并不是马上就刷入中继日志里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘I/O操作。这个值默认是0，可动态修改；</li>
</ul>
</li>
</ul>
<h1 id="缓冲池-buffer-pool"><a href="#缓冲池-buffer-pool" class="headerlink" title="缓冲池(buffer pool)"></a>缓冲池(buffer pool)</h1><h2 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h2><p>磁盘按页读取，一次至少读一页数据（InnoDB一般是16K），根据局部性原理，提前读取相关页到缓存里。</p>
<h2 id="缓冲池的实现（改进LRU）"><a href="#缓冲池的实现（改进LRU）" class="headerlink" title="缓冲池的实现（改进LRU）"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/shenjian58/article/details/93268633">缓冲池的实现（改进LRU）</a></h2><p>传统LRU在数据库里的两个问题</p>
<ul>
<li>预读失效<ul>
<li>预读失效指预读的页最终没有被SQL读取</li>
<li>解决方法：LRU划分新生代和老生代<ul>
<li>新生代尾接着老生代的头</li>
<li>预读的页只加入老生代头部</li>
<li>预读页被真正读取才加入到新生代头部</li>
</ul>
</li>
</ul>
</li>
<li>缓冲池污染<ul>
<li>如果SQL语句要批量扫描大量数据，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降</li>
<li>解决方法：设置老生代停留时间窗口，只有在老生代停留时间大于阈值的页才会被加入到新生代</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_buffer_pool_size%&#x27;</span>;<span class="comment">--缓冲池大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_old_blocks_pct%&#x27;</span>;<span class="comment">--老生代占比</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_old_blocks_time%&#x27;</span>;<span class="comment">--老生代停留时间</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_29023445/article/details/113598828">更多</a></p>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/55947158">查询缓存</a></h2><p>缓存sql 文本及缓存结果，用<strong>KV</strong>形式保存在服务器内存中。</p>
<p>如果运行相同的sql，服务器直接从缓存中去获取结果，不需要在再去解析、优化、执行sql。</p>
<p>表修改了，缓存清空。适合读多写少。</p>
<p>mysql8.0之后失效了。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="数据库三范式（3NF）"><a href="#数据库三范式（3NF）" class="headerlink" title="数据库三范式（3NF）"></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24696366/answer/29189700">数据库三范式（3NF）</a></h2><ul>
<li><p>第一范式</p>
<p>所有字段值都是不可分解的原子值</p>
</li>
<li><p>第二范式</p>
<p>每列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）</p>
<p>例如联合主键（学号，课名）</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/02281.png" style="zoom:50%;" />

<p>这里姓名、系名和系主任都只和学号有关，与课名无关，不符合第二范式。</p>
</li>
<li><p>第三范式</p>
<p>每列都和主键列直接相关,而不是间接相关</p>
<p>非主键字段不能相互依赖，每列都与主键有直接关系，不存在传递依赖。主键在一个表里只能存在一个！因为建立主键后，DBMS会默认把建立主键的列建立聚簇索引。但是一个表是允许把几个列一起设为主键的。</p>
<p>例如一个表（学号，姓名，学院，院长），学号是主键，但是院长只和学院有关，这就不符合第二范式，会导致数据库大量冗余。</p>
</li>
</ul>
<h2 id="MyISAM与InnoDB-的区别"><a href="#MyISAM与InnoDB-的区别" class="headerlink" title="MyISAM与InnoDB 的区别"></a>MyISAM与InnoDB 的区别</h2><ol>
<li><strong>InnoDB支持事务，MyISAM不支持</strong>，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</li>
<li><strong>InnoDB支持外键，而MyISAM不支持</strong>。对一个包含外键的InnoDB表转为MYISAM会失败； 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</li>
<li><strong>InnoDB是聚集索引，而MyISAM是非聚集索引</strong>。</li>
<li><strong>InnoDB不保存表的具体行数，而MyISAM用一个变量保存了整个表的行数</strong>。前者执行select count(*) from table时需要全表扫描。后者执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</li>
<li><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></li>
<li><strong>InnoDB表必须有唯一索引（如主键），而Myisam可以没有</strong></li>
</ol>
<h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><p>手写顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ...</span><br><span class="line"><span class="keyword">from</span> ... <span class="keyword">join</span> ... <span class="keyword">on</span> ...</span><br><span class="line"><span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">having</span> ...</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ...</span><br><span class="line">limit ...</span><br></pre></td></tr></table></figure>

<p>机读顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">on</span> ...</span><br><span class="line">... <span class="keyword">join</span> ...</span><br><span class="line"><span class="keyword">where</span> ...</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> ...</span><br><span class="line"><span class="keyword">having</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">distinct</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> ...</span><br><span class="line">limit ...</span><br></pre></td></tr></table></figure>

<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137368446">分库分表</a></h2><h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><ul>
<li>IO<ul>
<li>磁盘IO瓶颈：热点数据太多，缓存放不下    -&gt; <strong>分库</strong>和<strong>垂直分表</strong>（缓存只放热点字段）</li>
<li>网络IO瓶颈：请求数据太多，带宽不够        -&gt;<strong>分库</strong></li>
</ul>
</li>
<li>CPU<ul>
<li>单表数据量太大，查询时扫描的行太多         -&gt;水平分表</li>
</ul>
</li>
</ul>
<p><strong>水平的数据结构都不变，垂直的会改变数据结构</strong></p>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>以字段为依据，按照策略（hash、范围等）将一个库分到多个库，每个库的结构都一样，数据不一样。</p>
<p>场景：没有明显业务来垂直分库，分表不足以解决并发问题</p>
<p>分析：缓解IO和CPU压力</p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>将一个表分为多个表，每个表的结构一样</p>
<p>场景：单表数据太多，CPU压力大</p>
<p>分析：单表数据量减少了，缓解了CPU压力</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>以表为依据，将不同的表分到不同的库，每个库结构不一样，数据不一样</p>
<p>场景：按照业务拆分库</p>
<p>分析：缓解IO和CPU压力，每个库可以作为单独服务来服务化</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>以字段为依据，按照字段活跃性，将表拆分为多个表（主表和扩展表），表结构不一样，每个表至少有一列交集，关联数据。</p>
<p>场景：表的行（记录）不多，但是单行数据（字段）多，缓存的行就少了，IO就多了</p>
<p>分析：解决IO瓶颈</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/16/sql2/" data-id="ckw9lh00u00302ww5cln9esg2" data-title="数据库面试点" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-sql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/09/sql/" class="article-date">
  <time class="dt-published" datetime="2021-01-09T10:26:39.000Z" itemprop="datePublished">2021-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/09/sql/">数据库语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/20180718003208394.png"></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p>
<p>SQL 支持以下三种注释：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># #  注释</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable; <span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释1</span></span><br><span class="line"><span class="comment">   注释2 */</span></span><br></pre></td></tr></table></figure>

<p>数据库创建与使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line">USE test;</span><br></pre></td></tr></table></figure>

<h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line">  #  <span class="type">int</span> 类型，不为空，自增</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  #  <span class="type">int</span> 类型，不可为空，默认值为 <span class="number">1</span>，不为空</span><br><span class="line">  col1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  #  变长字符串类型，最长为 <span class="number">45</span> 个字符，可以为空</span><br><span class="line">  col2 <span class="type">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NULL</span>,</span><br><span class="line">  #  日期类型，可为空</span><br><span class="line">  col3 <span class="type">DATE</span> <span class="keyword">NULL</span>,</span><br><span class="line">  #  设置主键为 id</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`));</span><br></pre></td></tr></table></figure>

<h1 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h1><p>添加列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">ADD</span> col <span class="type">CHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--添加到第一列</span></span><br><span class="line"><span class="keyword">ADD</span> i <span class="type">INT</span> <span class="keyword">FIRST</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--添加到c列之后</span></span><br><span class="line"><span class="keyword">ADD</span> i <span class="type">INT</span> AFTER c;</span><br></pre></td></tr></table></figure>

<p>删除列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure>

<p>修改表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--c修改为CHAR(10)类型</span></span><br><span class="line">MODIFY c <span class="type">CHAR</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--修改i字段名为j，类型改为BIGINT</span></span><br><span class="line">CHANGE i j <span class="type">BIGINT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--修改字段默认值</span></span><br><span class="line"><span class="keyword">ALTER</span> i <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--删除字段默认值</span></span><br><span class="line"><span class="keyword">ALTER</span> i <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="comment">--修改表名</span></span><br><span class="line">RENAME <span class="keyword">TO</span> alter_tbl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="comment">--修改列的位置</span></span><br><span class="line">MODIFY name1 type1 <span class="keyword">first</span><span class="operator">|</span>after name2;</span><br></pre></td></tr></table></figure>



<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>普通插入</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable(col1, col2)</span><br><span class="line"><span class="keyword">VALUES</span>(val1, val2);</span><br></pre></td></tr></table></figure>

<p>插入检索出来的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mytable1(col1, col2)</span><br><span class="line"><span class="keyword">SELECT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable2;</span><br></pre></td></tr></table></figure>

<p>将一个表的内容插入到一个新表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> newtable <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mytable</span><br><span class="line"><span class="keyword">SET</span> col <span class="operator">=</span> val</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> mytable;</span><br></pre></td></tr></table></figure>

<p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1, col2</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p>
<p>返回前 5 行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">0</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>返回第 3 ~ 5 行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line">LIMIT <span class="number">2</span>, <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><ul>
<li>join使用小结果驱动大结果，在对内循环建立索引后，NestedLoop的循环次数就只和外循环有关了。</li>
<li>in后面跟小表，exists后面跟大表。</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li><strong>ASC</strong> ：升序（默认）</li>
<li><strong>DESC</strong> ：降序</li>
</ul>
<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>下表显示了 WHERE 子句可用的操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&gt; !=</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;= !&gt;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;= !&lt;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">BETWEEN</td>
<td align="center">在两个值之间</td>
</tr>
<tr>
<td align="center">IS NULL</td>
<td align="center">为 NULL 值</td>
</tr>
</tbody></table>
<p>应该注意到，NULL 与 0、空字符串都不同。</p>
<p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>
<p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<p><strong>NOT</strong> 操作符用于否定一个条件。</p>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li>
<li><strong>_</strong> 匹配 ==1 个任意字符；</li>
<li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li>
<li>查询内容包含通配符时，把特殊字符用 **[ ]**括起便可正常查询</li>
</ul>
<p>使用 Like 来进行通配符匹配。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="keyword">LIKE</span> <span class="string">&#x27;[^AB]%&#x27;</span>; <span class="comment">-- 不以 A 和 B 开头的任意文本</span></span><br></pre></td></tr></table></figure>

<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h1 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="operator">*</span> col2 <span class="keyword">AS</span> alias</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="built_in">TRIM</span>(col1), <span class="string">&#x27;(&#x27;</span>, <span class="built_in">TRIM</span>(col2), <span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> concat_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AVG()</td>
<td align="center">返回某列的平均值</td>
</tr>
<tr>
<td align="center">COUNT()</td>
<td align="center">返回某列的行数</td>
</tr>
<tr>
<td align="center">MAX()</td>
<td align="center">返回某列的最大值</td>
</tr>
<tr>
<td align="center">MIN()</td>
<td align="center">返回某列的最小值</td>
</tr>
<tr>
<td align="center">SUM()</td>
<td align="center">返回某列值之和</td>
</tr>
</tbody></table>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以汇总不同的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span><br><span class="line"><span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure>

<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LEFT()</td>
<td align="center">左边的字符</td>
</tr>
<tr>
<td align="center">RIGHT()</td>
<td align="center">右边的字符</td>
</tr>
<tr>
<td align="center">LOWER()</td>
<td align="center">转换为小写字符</td>
</tr>
<tr>
<td align="center">UPPER()</td>
<td align="center">转换为大写字符</td>
</tr>
<tr>
<td align="center">LTRIM()</td>
<td align="center">去除左边的空格</td>
</tr>
<tr>
<td align="center">RTRIM()</td>
<td align="center">去除右边的空格</td>
</tr>
<tr>
<td align="center">LENGTH()</td>
<td align="center">长度</td>
</tr>
<tr>
<td align="center">SOUNDEX()</td>
<td align="center">转换为语音值</td>
</tr>
</tbody></table>
<p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> SOUNDEX(col1) <span class="operator">=</span> SOUNDEX(<span class="string">&#x27;apple&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h2><ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:<zero-width space>MM:SS</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函 数</th>
<th align="center">说 明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ADDDATE()</td>
<td align="center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td align="center">ADDTIME()</td>
<td align="center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td align="center">CURDATE()</td>
<td align="center">返回当前日期</td>
</tr>
<tr>
<td align="center">CURTIME()</td>
<td align="center">返回当前时间</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="center">返回日期时间的日期部分</td>
</tr>
<tr>
<td align="center">DATEDIFF()</td>
<td align="center">计算两个日期之差</td>
</tr>
<tr>
<td align="center">DATE_ADD()</td>
<td align="center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td align="center">DATE_FORMAT()</td>
<td align="center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td align="center">DAY()</td>
<td align="center">返回一个日期的天数部分</td>
</tr>
<tr>
<td align="center">DAYOFWEEK()</td>
<td align="center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td align="center">HOUR()</td>
<td align="center">返回一个时间的小时部分</td>
</tr>
<tr>
<td align="center">MINUTE()</td>
<td align="center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td align="center">MONTH()</td>
<td align="center">返回一个日期的月份部分</td>
</tr>
<tr>
<td align="center">NOW()</td>
<td align="center">返回当前日期和时间</td>
</tr>
<tr>
<td align="center">SECOND()</td>
<td align="center">返回一个时间的秒部分</td>
</tr>
<tr>
<td align="center">TIME()</td>
<td align="center">返回一个日期时间的时间部分</td>
</tr>
<tr>
<td align="center">YEAR()</td>
<td align="center">返回一个日期的年份部分</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="number">2018</span><span class="number">-4</span><span class="number">-14</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">11</span></span><br></pre></td></tr></table></figure>

<h2 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h2><table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIN()</td>
<td align="center">正弦</td>
</tr>
<tr>
<td align="center">COS()</td>
<td align="center">余弦</td>
</tr>
<tr>
<td align="center">TAN()</td>
<td align="center">正切</td>
</tr>
<tr>
<td align="center">ABS()</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">SQRT()</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">MOD()</td>
<td align="center">余数</td>
</tr>
<tr>
<td align="center">EXP()</td>
<td align="center">指数</td>
</tr>
<tr>
<td align="center">PI()</td>
<td align="center">圆周率</td>
</tr>
<tr>
<td align="center">RAND()</td>
<td align="center">随机数</td>
</tr>
</tbody></table>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序（8.0版本开始不再隐式排序）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col;</span><br></pre></td></tr></table></figure>

<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num;</span><br></pre></td></tr></table></figure>

<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> col</span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure>

<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/3tdmru77yrlaceaandd04d6hf.jpg" alt="3tdmru77yrlaceaandd04d6hf" style="zoom:67%;" />

<p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Jim&quot;);</span><br></pre></td></tr></table></figure>

<p>自连接版本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h2><p>自然连接是把<strong>同名列</strong>通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> R.A, R.B, S.C </span><br><span class="line"><span class="keyword">from</span> R,S </span><br><span class="line"><span class="keyword">where</span> R.B <span class="operator">=</span> S.B;</span><br><span class="line">##自然连接</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R <span class="keyword">natural</span> <span class="keyword">join</span> S;</span><br></pre></td></tr></table></figure>

<p>表R</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
</tr>
</tbody></table>
<p>表S</p>
<table>
<thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<p>结果</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody></table>
<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>mysql不支持全外连接，可以使用union来实现</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.name<span class="operator">=</span>b.id) </span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> b <span class="keyword">on</span> a.name<span class="operator">=</span>b.id );</span><br></pre></td></tr></table></figure>

<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
</tr>
</tbody></table>
<p>orders 表：</p>
<table>
<thead>
<tr>
<th align="center">order_id</th>
<th align="center">cust_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>结果：</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
<th align="center">order_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R <span class="keyword">left</span> <span class="keyword">join</span> T <span class="keyword">on</span> R.B<span class="operator">=</span>T.B) <span class="keyword">union</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R <span class="keyword">right</span> <span class="keyword">join</span> T <span class="keyword">on</span> R.B<span class="operator">=</span>T.B);</span><br></pre></td></tr></table></figure>

<p>表R</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
</tr>
</tbody></table>
<p>表T</p>
<table>
<thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>b22</td>
<td>c22</td>
</tr>
</tbody></table>
<p>结果</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td>a1</td>
<td>b1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>b22</td>
<td>c22</td>
</tr>
</tbody></table>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>系统变量@@<ul>
<li>全局变量：作用域是整个服务器，修改对所有会话有效，但是重启后会重置。</li>
<li>会话变量：作用域是当前会话有效。</li>
</ul>
</li>
<li>自定义变量@<ul>
<li>用户变量：作用域是当前会话</li>
<li>局部变量：作用域只在begin end中,必须是begin end的第一句话，无需@</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables;<span class="comment">--查看全局变量</span></span><br><span class="line"><span class="keyword">show</span> session variable;<span class="comment">--查看会话变量</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%char%&#x27;</span>;<span class="comment">--查看包含char的全局变量</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.系统变量名;<span class="comment">--查看具体的系统变量值，会话同理</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@global</span>.系统变量名 <span class="operator">=</span> <span class="keyword">value</span>;<span class="comment">--赋值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用户变量</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name<span class="operator">=</span><span class="keyword">value</span>;<span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">select</span> 字段 <span class="keyword">into</span> <span class="variable">@var</span>_name <span class="keyword">from</span> table_name;</span><br><span class="line"><span class="comment">--局部变量</span></span><br><span class="line"><span class="keyword">declare</span> var_name type_;<span class="comment">--声明变量</span></span><br><span class="line"><span class="keyword">declare</span> var_name type_ <span class="keyword">default</span> value_;<span class="comment">--声明变量</span></span><br></pre></td></tr></table></figure>

<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>六大约束</p>
<ul>
<li>not null</li>
<li>default</li>
<li>primary key：唯一非空</li>
<li>unique：唯一，可为空</li>
<li>check：（mysql不支持）限制取值范围</li>
<li>foreign key：限制该表的这个字段的值必须在另一个表的对应列的取值范围中。只能表级约束</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mytable(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    stuName <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">check</span>(gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">or</span> gender<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">    seat <span class="type">int</span> <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">default</span> <span class="number">19</span>,</span><br><span class="line">    majorid <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">constraint</span> fk_major_con <span class="keyword">foreign</span> key(majorid) <span class="keyword">references</span> major(id)<span class="comment">--表级约束</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> major(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    majorname <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是一种数据结构，用来提高查询效率。</p>
<p>提升查询效率，降低更新表的速度。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建</span></span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] index index_name <span class="keyword">on</span> table_name(col_name(length));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>_name <span class="keyword">add</span> [<span class="keyword">unique</span>] index index_name <span class="keyword">on</span> (col_name(length));</span><br><span class="line"><span class="comment">--删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index index_name <span class="keyword">on</span> table_name;</span><br><span class="line"><span class="comment">--显示所有索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>explain+sql语句</p>
<ul>
<li><p>id：表示表的读取顺序</p>
<ul>
<li>id相同，顺序执行</li>
<li>id不同，值越大越优先执行</li>
</ul>
</li>
<li><p>select_type：数据读取操作的操作类型</p>
<ul>
<li>simple：最简单的，没有子查询和union</li>
<li>primary：有子查询的最外面的查询</li>
<li>subquery：select或where中的子查询</li>
<li>derived：from中的子查询，结果放在临时表</li>
<li>union：第二个select出现在union后，被标记为union</li>
<li>union result：union的查询结果得到的select</li>
</ul>
</li>
<li><p>type：</p>
<ul>
<li>const：索引查一次就查到了，常见主键和unique索引</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录匹配</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行</li>
<li>range：检索时给定索引范围，key显示使用的索引。常见between in等查询</li>
<li>index：全索引扫描，只遍历索引树</li>
<li>all：全表扫描</li>
</ul>
</li>
<li><p>possible_keys：显示可能用到的索引，但不一定在查询时使用到</p>
</li>
<li><p>key：实际使用到的索引</p>
</li>
<li><p>key_len：索引中使用的字节数</p>
</li>
<li><p>ref：显示索引的哪一列被使用了</p>
</li>
<li><p>rows：估算找到所需读取的行数</p>
</li>
<li><p>extra</p>
<ul>
<li><p>using filesort：文件内排序，无法利用索引完成排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建立索引col1,col2,col3后</span></span><br><span class="line">explain <span class="keyword">select</span> col1 <span class="keyword">from</span> t1 <span class="keyword">where</span> col1<span class="operator">=</span><span class="string">&#x27;ac&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> col3</span><br><span class="line"><span class="comment">--由于最左匹配原则，where语句用到了索引，但是order没有用到索引（因为跳过了col2），所以mysql内部重新排序了，效率低</span></span><br><span class="line">explain <span class="keyword">select</span> col1 <span class="keyword">from</span> t1 <span class="keyword">where</span> col1<span class="operator">=</span><span class="string">&#x27;ac&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> col2,col3</span><br><span class="line"><span class="comment">--where和order都用到了索引，特别是order复用了索引，效率高</span></span><br></pre></td></tr></table></figure></li>
<li><p>using temporary：使用了临时表来保存中间结果</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--建立索引col1,col2后</span></span><br><span class="line">explain <span class="keyword">select</span> col1 <span class="keyword">from</span> t1 <span class="keyword">where</span> col1<span class="operator">=</span><span class="keyword">in</span> (<span class="string">&#x27;ac&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> col2</span><br><span class="line"><span class="comment">--最左匹配原则，where是范围，索引失效了，group就没用到索引，会使用到临时表</span></span><br><span class="line">explain <span class="keyword">select</span> col1 <span class="keyword">from</span> t1 <span class="keyword">where</span> col1<span class="operator">=</span><span class="keyword">in</span> (<span class="string">&#x27;ac&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> col1.col2</span><br><span class="line"><span class="comment">--group使用了索引</span></span><br></pre></td></tr></table></figure></li>
<li><p>using index：使用了索引</p>
</li>
</ul>
</li>
</ul>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ul>
<li>排序利用索引，不要被提前打断</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/0227111.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询col1=3,col2&gt;3并按照col3降序排列</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable4 <span class="keyword">where</span> col1<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> col2<span class="operator">&gt;</span><span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> col3 <span class="keyword">desc</span></span><br><span class="line"><span class="comment">--建立索引(col1,col2,col3)，type变成range，检索给定索引范围，优化了，但是col3还是会文件排序</span></span><br><span class="line"><span class="keyword">create</span> index idx_c123 <span class="keyword">on</span> mytable4(col1,col2,col3);</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable4 <span class="keyword">where</span> col1<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> col2<span class="operator">&gt;</span><span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> col3 <span class="keyword">desc</span></span><br><span class="line"><span class="comment">--建立索引(col1,col3)，没有了文件排序</span></span><br><span class="line"><span class="keyword">create</span> index idx_c13 <span class="keyword">on</span> mytable4(col1,col3);</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable4 <span class="keyword">where</span> col1<span class="operator">=</span><span class="number">3</span> <span class="keyword">and</span> col2<span class="operator">&gt;</span><span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> col3 <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<ul>
<li>左连接对右表建索引，右连接对左表建索引（反过来的话不会用到索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_4 <span class="keyword">on</span> mytable4(col2);</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable2 <span class="keyword">left</span> <span class="keyword">join</span> mytable4 <span class="keyword">on</span> mytable2.col2<span class="operator">=</span>mytable4.col2;</span><br><span class="line"><span class="comment">--使用索引，type是ref，如果对mytable2建索引，则type是all，不使用索引</span></span><br></pre></td></tr></table></figure>

<ul>
<li>尽量使用覆盖索引。不要使用select *,因为会需要回表得到全部数据。</li>
</ul>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul>
<li><p>违反了最左匹配原则</p>
</li>
<li><p>对索引列做操作（计算、函数、类型转换(字段为字符串，但是where语句里写Int)等）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx <span class="keyword">on</span> staffs(name);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> staffs <span class="keyword">where</span> <span class="keyword">left</span>(name,<span class="number">4</span>)<span class="operator">=</span><span class="string">&#x27;july&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果WHERE条件中含有OR，除非OR条件中的所有列都是索引列（即覆盖索引），否则MySQL不会选择索引。</p>
</li>
<li><p>like后面如果是%开头，不使用索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable4 <span class="keyword">where</span> col4 <span class="keyword">like</span> <span class="string">&#x27;c%&#x27;</span>;<span class="comment">--使用索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mytable4 <span class="keyword">where</span> col4 <span class="keyword">like</span> <span class="string">&#x27;%c%&#x27;</span>;<span class="comment">--不使用索引</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Concat(col1, col2) <span class="keyword">AS</span> concat_col, col3<span class="operator">*</span>col4 <span class="keyword">AS</span> compute_col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col5 <span class="operator">=</span> val;</span><br></pre></td></tr></table></figure>

<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。所以需要使用delimiter来设置结束符</p>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span> <span class="comment">--结束符设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure( <span class="keyword">out</span> ret <span class="type">int</span> )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> y <span class="type">int</span>;</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">sum</span>(col1)</span><br><span class="line">        <span class="keyword">from</span> mytable</span><br><span class="line">        <span class="keyword">into</span> y;</span><br><span class="line">        <span class="keyword">select</span> y<span class="operator">*</span>y <span class="keyword">into</span> ret;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">delimiter ; <span class="comment">--再次声明结束符</span></span><br><span class="line"><span class="keyword">call</span> myprocedure(<span class="variable">@ret</span>); <span class="comment">--调用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@ret</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> myprocedure； <span class="comment">--删除存储过程</span></span><br></pre></td></tr></table></figure>

<h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ol>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> myprocedure(<span class="keyword">out</span> ret <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">declare</span> done <span class="type">boolean</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">        <span class="keyword">select</span> col1 <span class="keyword">from</span> mytable;</span><br><span class="line">        #  定义了一个 continue handler，当 <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> 这个条件出现时，会执行 <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">declare</span> continue handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">set</span> done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">open</span> mycursor;</span><br><span class="line"></span><br><span class="line">        repeat</span><br><span class="line">            <span class="keyword">fetch</span> mycursor <span class="keyword">into</span> ret;</span><br><span class="line">            <span class="keyword">select</span> ret;</span><br><span class="line">        until done <span class="keyword">end</span> repeat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">close</span> mycursor;</span><br><span class="line">    <span class="keyword">end</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"> delimiter ;</span><br></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> mytrigger AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> mytable</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">SELECT</span> NEW.col <span class="keyword">into</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@result</span>; <span class="comment">-- 获取结果</span></span><br></pre></td></tr></table></figure>

<p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；原子性（要么全部执行，要么全部不执行）</li>
<li>回滚（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line"><span class="keyword">START</span> TRANSACTION</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">SAVEPOINT</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ...</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure>

<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">(col <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> latin <span class="keyword">COLLATE</span> latin1_general_ci )</span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> hebrew <span class="keyword">COLLATE</span> hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>可以在排序、分组时指定校对：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col <span class="keyword">COLLATE</span> latin1_general_ci;</span><br></pre></td></tr></table></figure>

<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>创建账户</strong></p>
<p>新创建的账户没有任何权限。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mypassword&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改账户名</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME <span class="keyword">USER</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure>

<p><strong>删除账户</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>查看权限</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>授予权限</strong></p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>删除权限</strong></p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>

<p><strong>更改密码</strong></p>
<p>必须使用 Password() 函数进行加密。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser <span class="operator">=</span> Password(<span class="string">&#x27;new_password&#x27;</span>);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/09/sql/" data-id="ckw9lgzzi002i2ww52yej6jy8" data-title="数据库语法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/07/mysql/" class="article-date">
  <time class="dt-published" datetime="2021-01-07T08:48:39.000Z" itemprop="datePublished">2021-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/07/mysql/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/640.png"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP的报文结构"><a href="#HTTP的报文结构" class="headerlink" title="HTTP的报文结构"></a>HTTP的报文结构</h3><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01083.jpg" alt="img"></p>
<h3 id="HTTP请求种类"><a href="#HTTP请求种类" class="headerlink" title="HTTP请求种类"></a>HTTP请求种类</h3><ol>
<li><strong>get：</strong>获取资源(多媒体，程序执行结果)</li>
<li><strong>post：</strong>传输实体主体，相比于 <code>get</code> 传输，<code>post</code> 请求的数据会放置在内容实体中而不是 <code>uri(Universal Resource Identifier)</code> 之后，安全性大大增强</li>
<li><strong>put：</strong>传输文件，由于 <code>http1.1</code> 本身不自带验证机制，所以安全性欠佳。一般 <code>web</code> 不使用此方法</li>
<li><strong>head：</strong>获得报文首部，与 <code>get</code> 一样，只是不获取报文主体，用来验证 <code>uri</code> 的有效性</li>
<li><strong>delete：</strong>删除文件 类似 <code>put</code></li>
<li><strong>options：</strong>询问支持的方法</li>
<li><strong>trace：</strong>追踪路径，让 <code>web</code> 服务器端将之前的请求通信环回给客户端，用来确认连接过程中，代理中转的加工/篡改。</li>
<li><strong>connect：</strong>要求用隧道协议连接代理，主要使用 <code>ssl</code> 和 <code>tsl</code> 把通信内容加密后经网络隧道传输</li>
</ol>
<hr>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<p><strong>1信息通知，2成功，3暂时没成功，但可以重定向，45是失败，4是客户端错误，5是服务器错误</strong></p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p><strong>HTTP状态码列表:</strong></p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。<a target="_blank" rel="noopener" href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<hr>
<h3 id="HTTP的首部字段"><a href="#HTTP的首部字段" class="headerlink" title="HTTP的首部字段"></a>HTTP的首部字段</h3><ul>
<li><p>通用字段：在请求头和响应头里都可以出现； </p>
</li>
<li><p>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件； </p>
</li>
<li><p>响应字段：仅能出现在响应头里，补充说明响应报文的信息； </p>
</li>
<li><p>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</p>
</li>
</ul>
<h4 id="首部字段：缓存"><a href="#首部字段：缓存" class="headerlink" title="首部字段：缓存"></a>首部字段：缓存</h4><ul>
<li><p>Cache-Control：</p>
<ul>
<li><p>max-age：资源存储的最长时间</p>
</li>
<li><p>no-store：不允许缓存</p>
</li>
<li><p>no-cache：可以缓存，使用之前必须要去服务器验证是否过期</p>
</li>
<li><p>must-revalidate：资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求</p>
<img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01084.jpg" style="zoom: 80%;" /></li>
</ul>
</li>
<li><p>条件缓存</p>
<ul>
<li><p>if-Modified-Since：指的是文件最后修改时间。在给定的日期时间之后，如果请求的资源没有改变，就返回304响应；如果有改变，返回资源</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01085.jpg"></p>
</li>
<li><p>If-None-Match：对于 GET 和 HEAD请求方法来说，当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 200</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="HTTPS的通信过程⭐"><a href="#HTTPS的通信过程⭐" class="headerlink" title="HTTPS的通信过程⭐"></a>HTTPS的通信过程⭐</h3><p><code>HTTPS</code> 是一种通过计算机网络进行安全通信的传输协议。<code>HTTPS</code> 经由 <code>HTTP</code> 进行通信，但利用 <strong>SSL/TLS</strong> 来加密数据包。 <code>HTTPS</code> 的通信过程，充分利用了各种加密算法及其特性。<code>HTTPS</code> 只是在原有的协议接口替换成了**SSL(Secure Socket Layer)<strong>和</strong>TLS(Transport Layer Security)**协议</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1627759-20190615112708629-638195014.jpg" alt="img"></p>
<ol>
<li><p>客户端或者浏览器向服务器发送 <code>https</code> 请求</p>
</li>
<li><p>服务器将数字证书(公钥+数字签名)返回给客户端</p>
</li>
<li><p>浏览器接收到服务器公钥</p>
<p>浏览器收到公钥后会对公钥进行一系列的验证，如：颁发机构，过期时间等等。认证失败会有警告，成功的话，<strong>会生成一个随机的对称密钥作为对称加密的密钥，用服务器返回的公钥对这个随机密钥进行加密</strong></p>
</li>
<li><p>加密后的随机密钥发送到服务器</p>
<p>服务器收到公钥加密后的随机密钥，会拿自己的私钥去解，解开之后得到随机密钥</p>
</li>
<li><p>客户端与服务器进行加密通信</p>
<p>客户端和服务器端信息数据通信，以这个随机密钥进行对称加密。</p>
</li>
</ol>
<p>总结：S<strong>发公钥</strong>给C，C<strong>验证</strong>后用<strong>公钥加密随机秘钥</strong>再发给S，S用<strong>私钥解密</strong>得到随机秘钥，最后双方用随机秘钥通信。</p>
<h4 id="非对称加密算法-对称加密算法"><a href="#非对称加密算法-对称加密算法" class="headerlink" title="非对称加密算法+对称加密算法"></a>非对称加密算法+对称加密算法</h4><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p>
<ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
<p>非对称加密算法，它有两个密钥：一个是公钥，可以明文传输的。一个是私钥，由发送方保存，其它人都不知道。非对称加密算法的加密和解密算法不同。通过公钥加密的信息只有用私钥才能解开。</p>
<p>主要是由于非对称加密算法运算量大，用非对称加密算法进行通信，其加解密过程特别慢。因此可以第一次用非对称加密算法传递对称加密算法的密钥，后续通信就用对称加密算法。除了第一次用非对称加密算法加解密密钥的时候比较慢外，其它时间都不会慢了。而且也可以保证对称加密算法密钥的安全性。这样可以充分利用非对称加密算法和对称加密算法的各自特点。</p>
<h4 id="数字证书—防止中间人攻击"><a href="#数字证书—防止中间人攻击" class="headerlink" title="数字证书—防止中间人攻击"></a>数字证书—防止中间人攻击</h4><p>为了防止在通信过程中有中间人截获两端的非对称密钥，导致两端收到的公钥都是中间人的，可以获取两端的信息然后中转。找个可靠的人做公证人，两端各自把公钥交给他。由他颁布一个证书，证书包含公钥以及两端的身份信息，来证明两端各自的身份。但是这个证书也可以在传递过程中被篡改。</p>
<h4 id="数字摘要算法"><a href="#数字摘要算法" class="headerlink" title="数字摘要算法"></a>数字摘要算法</h4><p><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p>
<p>为了解决数字证书中中间人攻击的问题，可以让公证人用<strong>数字摘要算法</strong>，把<strong>公钥和身份信息</strong>生成一个摘要。同时用非对称加密算法对摘要进行加密，生成数字签名。然后把【公钥和身份信息+数字签名】合并，形成数字证书。在获得数字证书的时候，就可以用公钥进行解密生成摘要信息，再用数字摘要算法对公钥和身份信息生成摘要信息，两者比对，如果能匹配，就说明没有被篡改 。</p>
<p>数字证书通常来说是由受信任的数字证书颁发机构<strong>CA</strong>，在验证服务器身份后颁发。</p>
<h4 id="证书内置"><a href="#证书内置" class="headerlink" title="证书内置"></a>证书内置</h4><p>为了防止公证人公钥传输过程也会出现中间人攻击问题，可以把公证人公钥预先加载在操作系统中。微软等公司会根据一些权威安全机构的评估选取一些信誉很好并且通过一定的安全认证的证书发布机构，把这些证书发布机构的证书默认安装在操作系统中，并且设置为操作系统信任的数字证书。</p>
<hr>
<h3 id="get-post-区别"><a href="#get-post-区别" class="headerlink" title="get/post 区别"></a>get/post 区别</h3><ul>
<li><code>GET</code> 用于信息获取，不会增删改服务器上的内容；<code>POST</code> 请求可能修改服务器上资源；</li>
<li><code>GET</code> 请求数据附在 <code>URL</code> 后面，而 <code>POST</code> 在 <code>HTTP</code> 包体内；</li>
<li><code>GET</code>方法产生一个TCP数据包，把首部和数据一起发送;<code>POST</code>方法产生两个TCP数据包，先发首部，服务器响应后再发数据 </li>
</ul>
<hr>
<h3 id="http-https-0-9、1-0、1-1、2-0、3-0的特点和区别"><a href="#http-https-0-9、1-0、1-1、2-0、3-0的特点和区别" class="headerlink" title="http/https 0.9、1.0、1.1、2.0、3.0的特点和区别"></a>http/https 0.9、1.0、1.1、2.0、3.0的特点和区别</h3><h4 id="Http0-9"><a href="#Http0-9" class="headerlink" title="Http0.9"></a>Http0.9</h4><ul>
<li><strong>请求方法支持有限</strong><br>只支持 <code>GET</code> 请求方式，不支持其他请求方式，因此客户端向服务端传输信息的量非常有限，也就是现在常用的 <code>Post</code> 请求无法使用</li>
<li><strong>不支持请求头header</strong><br>不能在请求中指定版本号，服务端只具有返回 <code>HTML</code> 字符串的能力</li>
<li><strong>响应即关闭</strong><br>服务端相响应之后，立即关闭 <code>TCP</code> 连接</li>
</ul>
<hr>
<h4 id="Http1-0"><a href="#Http1-0" class="headerlink" title="Http1.0"></a>Http1.0</h4><p>1.0版本主要是对0.9版本的强化，效果也比较明显，主要特性和缺点包括：</p>
<ul>
<li><strong>丰富请求方法</strong><br>请求方式新增了 <code>POST</code> ，<code>DELETE</code> ，<code>PUT</code> ，<code>HEADER</code> 等方式，提高了客户端向服务端发送信息的量级</li>
<li><strong>增加请求头和响应头</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，可以在通信中指定了 <code>HTTP</code> 协议版本号，以及其他 <code>header</code> 信息，使得C/S交互更加灵活方便</li>
<li><strong>丰富数据传输内容</strong><br>扩充了传输内容格式包括：<strong>图片、音视频资源、二进制</strong>等都可以进行传输，相比0.9的只能传输 <code>html</code> 内容让<code>http</code> 的应用场景更多。</li>
</ul>
<p><strong>缺点如下：</strong></p>
<ul>
<li><strong>链接复用性差</strong><br>1.0版本中<strong>每个TCP连接只能发送一个请求</strong>，<strong>数据发送完毕连接就关闭</strong>，如果还要请求其他资源，就必须重新建立连接。TCP为了保证正确性和可靠性需要客户端和服务器三次握手和四次挥手，因此建立连接成本很高，基于拥塞控制开始时发送速率较慢，所以1.0版本的<strong>性能并不理想</strong>。</li>
<li><strong>无状态无连接的弊端</strong><br>1.0版本是<strong>无状态且无连接</strong>的，换句话说就是服务器不跟踪不记录请求过的状态，客户端<strong>每次请求都需要建立tcp连接不能复用</strong>，并且1.0规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞后面的请求就会被阻塞。 <strong>丢包和乱序问题</strong>和高成本的链接过程让复用和<strong>队头阻塞</strong>产生很多问题，所以<strong>无连接无状态</strong>是1.0版本的一个<strong>弱肋</strong>。</li>
</ul>
<h4 id="Http1-1"><a href="#Http1-1" class="headerlink" title="Http1.1"></a>Http1.1</h4><p>1.1版本在1.0版本发布后大约1年就推出了，是<strong>对1.0版本的优化和完善</strong>，1.1版本的主要特点包括：</p>
<ul>
<li><strong>增加长连接</strong><br>新增 <code>Connection</code> 字段，可以设置 <code>keep-alive</code> 值保持连接不断开，即 <code>TCP</code> 连接默认不关闭，可以被多个请求<strong>复用</strong>，这也是1.1版本很重要的优化，在请求首部字段中提出keepalive之后，只要任意一段没有明确提出断开连接，tcp就一直会保持连接状态。但是在S端服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着，仍然存在队头阻塞问题。</li>
<li><strong>管道化</strong><br>在长连接的基础上，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回，即在<strong>同一个TCP连接中，客户端可以同时发送多个请求</strong>，进一步改进了HTTP协议的传输效率。</li>
<li><strong>更多的请求方法</strong><br>增加了 <code>PUT</code>、 <code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code> 等请求方式。</li>
<li><strong>host字段</strong><br><code>Host</code> 字段用来指定服务器的域名，这样就可以将多种请求发往同一台服务器上的不同网站，提高了机器的复用，这个也是重要的优化</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>仍然存在着<strong>队首阻塞</strong>的问题。也就是虽然请求可以同时发送了，但是要是前面的回应特别慢，后面就会有许多请求排队等着，仍然存在队头阻塞问题。</li>
</ul>
<hr>
<h4 id="Http2-0"><a href="#Http2-0" class="headerlink" title="Http2.0"></a>Http2.0</h4><p><strong>HTTP2.0多路复用+TLS安全加密+TCP拥塞控制</strong></p>
<p>2.0版本是个里程碑式的版本，相比1.x版本有了非常多的优化去适应当前的网络场景，其中几个重要功能点包括：</p>
<ul>
<li><p><strong>二进制格式</strong><br><code>1.x</code> 是文本协议，然而2.0是<strong>以二进制帧为基本单位</strong>，可以说是一个二进制协议，将所有传输的信息分割为<strong>消息和帧</strong>，并采用二进制格式的编码，一帧中包含数据和标识符，使得网络传输变得高效而灵活。</p>
<ul>
<li><p>二进制分帧层binary framing layer在不修改请求方法和语义的基础上，重新设计了编码机制。二进制编码机制使得通信可以在单个TCP连接上进行，该连接在整个对话期间一直处于活跃状态。</p>
<ul>
<li><strong>链接Link</strong><br>就是指一条C/S之间的TCP链接，这是个基础的链路数据的高速公路</li>
<li><strong>数据流Stream</strong><br>已建立的TCP连接内的双向字节流，TCP链接中可以承载一条或多条消息</li>
<li><strong>消息Message</strong><br>消息属于一个数据流，消息就是逻辑请求或响应消息对应的完整的一系列帧，也就是帧组成了消息</li>
<li><strong>帧Frame</strong><br>帧是通信的最小单位，每个帧都包含帧头和消息体，标识出当前帧所属的数据流</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多路复用</strong><br>这是一个非常重要的改进，1.x中建立多个连接的消耗以及效率都存在问题，2.0版本的多路复用<strong>多个请求共用一个连接，多个请求可以同时在一个TCP连接上并发，主要借助于二进制帧中的标识进行区分实现链路的复用。</strong></p>
<ul>
<li><p>客户端和服务器将交互数据分解为<strong>相互独立的帧</strong>，互不影响地<strong>交错传输</strong>，最后再在对端根据<strong>帧头中的流标识符</strong>把它们<strong>重新组装</strong>起来，从而实现了TCP链接的多路复用。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/a.jpg" alt="图片"></p>
</li>
</ul>
</li>
<li><p><strong>头部压缩</strong><br>2.0版本使用使用<strong>HPACK算法</strong>对头部 <code>header</code> 数据进行压缩，从而减少请求的大小提高效率，这个非常好理解，之前每次发送都要带相同的 <code>header</code> ，显得很冗余，<code>2.0</code> 版本对头部信息进行增量更新有效减少了头部数据的传输。</p>
<ul>
<li><p>2.0版本中HPACK算法在C/S中使用<strong>首部表</strong>来存储之前发送的键值对，对于相同的数据通信期间几乎不会改变的通用键值对只需发送一次即可。</p>
</li>
<li><p>极端情况如果请求头每次没有变化，那么传输中则不包含首部，也就是首部开销就是<strong>零字节</strong>。如果首部键值对发生变化了，也<strong>只需要发送变化的数据</strong>，并且将<strong>新增或修改的首部帧会被追加到首部表</strong>，首部表在链接存活期始终存在, 并且由客户端和服务器<strong>共同更新和维护</strong>。</p>
</li>
<li><p>简单说就是客户端和服务端共同维护了一个<strong>key-value</strong>的结构，发生变化时则更新传输，否则就不传输，这样相当于<strong>首次全量传输之后增量更新传输</strong>即可，这个思想在日常开发中也非常普遍，不用想的太复杂。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01082.jpg" alt="图片"></p>
</li>
</ul>
</li>
<li><p><strong>服务端推送</strong><br>这个功能有点意思，之前 <code>1.x</code> 版本服务端都是收到请求后被动执行，在2.0版本允许服务器主动向客户端发送资源，这样在客户端可以起到加速的作用。</p>
<ul>
<li>在实际的C/S交互中这种<strong>主动推送额外资源</strong>的方法很有效，因为几乎每个网络应用都会包含多种资源，客户端需要全部逐个获取它们，此时如果让服务器提前推送这些资源，从而可以<strong>有效减少额外的延迟时间</strong>，因为服务器可以知道客户端下一步要请求什么资源。</li>
</ul>
</li>
<li><p><strong>HTTP2.0存在的不足(主要是TCP的问题)</strong></p>
<ul>
<li>建立连接时间长</li>
<li>队头阻塞问题(HTTP2.0协议的<strong>多路复用机制</strong>解决了HTTP层的队头阻塞问题，但是在<strong>TCP层仍然存在队头阻塞问题</strong>。TCP协议在收到数据包之后，这部分数据可能是乱序到达的，但是TCP必须将所有数据收集排序整合后给上层使用，<strong>如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用</strong>。)</li>
<li>移动互联网领域表现不佳(弱网环境)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Http3-0"><a href="#Http3-0" class="headerlink" title="Http3.0"></a>Http3.0</h4><p>HTTP3.0又称为<strong>HTTP Over QUIC</strong>，其<strong>弃用TCP协议</strong>，改为使用<strong>基于UDP协议</strong>的QUIC协议来实现。</p>
<ul>
<li><strong>QUIC</strong>协议(<strong>Quick UDP Internet Connections</strong>)</li>
</ul>
<blockquote>
<p>QUIC提高了当前正在使用TCP的面向连接的Web应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。</p>
</blockquote>
<blockquote>
<p>QUIC的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
</blockquote>
<ul>
<li><strong>基于TCP协议和TLS协议的HTTP2.0在真正发送数据包之前需要花费一些时间来完成握手和加密协商</strong>，完成之后才可以真正传输业务数据。但是QUIC则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</li>
<li><strong>使用QUIC协议的客户端和服务端要使用1RTT进行密钥交换，使用的交换算法是DH(Diffie-Hellman)迪菲-赫尔曼算法。首次连接之后传递了config包，里面包含了服务端公钥和两个随机数，客户端会将config存储下来，后续再连接时可以直接使用，从而跳过这个1RTT，实现0RTT的业务数据交互。</strong></li>
<li>QUIC协议基于UDP实现摒弃了五元组(SIP+SPort+DIP+DPort+协议号)的概念，使用64位的随机数作为连接的ID，并使用该ID表示连接。基于QUIC协议之下，我们在日常wifi和4G切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</li>
<li>QUIC协议的核心思想是将TCP协议在内核实现的诸如可靠传输、流量控制、拥塞控制等功能转移到用户态来实现，同时在加密传输方向的尝试也推动了TLS1.3的发展。</li>
</ul>
<hr>
<h3 id="HTTP的无状态性"><a href="#HTTP的无状态性" class="headerlink" title="HTTP的无状态性"></a>HTTP的无状态性</h3><p><code>http</code> 是一种无状态协议，即<strong>不会保存请求和响应之间的通信状态</strong>。好处是<strong>可以加快处理速度，确保协议的可伸缩性</strong>。<code>http</code> 最初的设计是无状态的(stateless)，但是无状态的 <code>http</code> 无法满足互联网日益发展的需求，于是业界扩展了 <code>http</code> 协议，增加了有状态(stateful)协议头，使之变成一个有状态协议。</p>
<p>两种用于保持HTTP连接状态的技术就应运而生了，一个是Cookie，而另一个则是Session。HTTP本身是一个无状态的连接协议，为了支持客户端与服务器之间的交互，我们就需要通过不同的技术为交互存储状态，而这些不同的技术就是Cookie和Session了。</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>由于HTTP是一种无状态的协议，服务器<strong>单纯从网络连接上</strong>无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>
<p>Cookie实际上是<strong>一小段的文本信息</strong>。客户端请求服务器，如果服务器需要记录该用户状态，就使用 <code>response</code> 向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，<strong>浏览器把请求的网址连同该Cookie一同提交给服务器</strong>。<strong>服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</strong></p>
<p><em>Cookie具有不可跨域名性</em></p>
<p>很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有<strong>不可跨域名性</strong>。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p><strong>Cookie在客户端是由浏览器来管理的</strong>。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>由于网页是一种无状态的连接程序，因此无法得知用户的浏览状态。在网上购物的时，把很多商品加入了购物车，而在结账时网站却不知道你购物车有哪些物品。为了解决这个问题，服务器端就为特定用户创建了特定的<code>session</code> ，用于标示并跟踪这个用户，这样才知道购物车里有哪些商品。</p>
<ul>
<li><code>Session</code> 是另一种<strong>记录客户状态的机制</strong>，不同的是 <code>Cookie</code> 保存在客户端浏览器中，而 <code>Session</code> 保存在服务器上。</li>
<li>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 <code>Session</code> 。客户端浏览器再次访问时只需要从该 <code>Session</code> 中查找该客户的状态就可以了。</li>
<li>如果说 <code>Cookie</code> 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 <code>Session</code> 机制就是通过检查服务器上的“客户明细表”来确认客户身份。</li>
<li><code>Session</code> 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</li>
</ul>
<h4 id="Session和Cookie的关系"><a href="#Session和Cookie的关系" class="headerlink" title="Session和Cookie的关系"></a>Session和Cookie的关系</h4><ul>
<li><code>cookie</code> 是一个实际存在的、具体的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段。</li>
<li><code>session</code> 是一个抽象概念、开发者为了实现中断和继续等操作，将 <code>client</code> 和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念。</li>
<li>即 <code>session</code> 描述的是一种通讯会话机制，而 <code>cookie</code> 只是目前实现这种机制的主流方案里面的一个参与者，它一般是用于保存<strong>session ID</strong>。</li>
</ul>
<p>更多<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484943&idx=1&sn=2db6af0e47cd6bdf185b0b440cf31da5&chksm=9bd7f807aca0711183c4fe1f7b340a5f3399fc5517b77ec702f857818b0f3e000525363eda0a&scene=21#wechat_redirect">介绍</a></p>
<hr>
<h3 id="从浏览器输入URL到出现页面经过了哪些阶段"><a href="#从浏览器输入URL到出现页面经过了哪些阶段" class="headerlink" title="从浏览器输入URL到出现页面经过了哪些阶段"></a>从浏览器输入URL到出现页面经过了哪些阶段</h3><h4 id="输入网址"><a href="#输入网址" class="headerlink" title="输入网址"></a>输入网址</h4><p>URL的形式： <code>schema://host:port/path?query#fragment</code></p>
<p>　　<code>-schema</code> : 协议，例如 <code>http</code> , <code>https</code> , <code>ftp</code> 等</p>
<p>　　<code>-host</code> : 域名或者 <code>ip</code> 地址</p>
<p>　　<code>-port</code> ： 端口，<code>http</code> 默认端口 <code>80</code> ，可以省略</p>
<p>　　<code>-path</code> ： 路径，例如 <code>/abc</code> <code>/a/b/c</code></p>
<p>　　<code>-query</code> : 查询参数，例如 <code>token=sdfs2223fds2&amp;name=sdffaf</code></p>
<p>　　<code>-fragment</code> : 锚点（哈希 <code>Hash</code> ），用于定位页面的某个位置。</p>
<p>符合规则的URL</p>
<p>　　<a target="_blank" rel="noopener" href="http://www.baidu.com/java/web?flag=1#function">http://www.baidu.com/java/web?flag=1#function</a></p>
<h4 id="缓存解析"><a href="#缓存解析" class="headerlink" title="缓存解析"></a>缓存解析</h4><p>浏览器获取了这个 <code>url</code> ，它先去缓存当中看看有没有，依次从浏览器缓存-&gt;系统缓存-&gt;路由器缓存当中查看，如果有从缓存当中显示页面，这样是不需要发送 <code>http</code> 请求的。如果没有那就进行步骤3。<br>缓存就是把之前访问的web资源，比如一些js，css，图片什么的保存在本机的内存或者磁盘当中。</p>
<h4 id="域名DNS解析"><a href="#域名DNS解析" class="headerlink" title="域名DNS解析"></a>域名DNS解析</h4><p>当缓存中没有这个 <code>url</code> 的时候，就需要发送 <code>http</code> 请求了，那么在发送 <code>http</code> 请求之前，需要先进行<strong>DNS解析</strong>将域名解析成 <code>ip</code> 地址。<strong>DNS解析</strong>存在着多级缓存：</p>
<ul>
<li>浏览器缓存、系统缓存（hosts)、路由器缓存</li>
<li>本地DNS服务器（ISP提供）<ul>
<li>有映射，解析完成</li>
<li>有缓存，解析完成，不权威</li>
</ul>
</li>
<li>上述都失败<ul>
<li>未采用转发模式（迭代）：<ul>
<li>发给根DNS服务器</li>
<li>返回负责该顶级域名服务器的IP （如.com)</li>
<li>向该顶级域名服务器IP发送请求</li>
<li>如果失败，找下一级DNS服务器（如qq.com）</li>
<li>循环往复，直到得到结果，发给本地DNS服务器，再发给客户机</li>
</ul>
</li>
<li>采用转发模式（递归）：<ul>
<li> 请求转发至上一级DNS服务器</li>
<li> 不断重复</li>
</ul>
</li>
<li><strong>递归查询</strong>：本机向本地域名服务器发出一次查询请求，就静待最终的结果。如果本地域名服务器无法解析，自己会以 <code>DNS</code> 客户机的身份向其它域名服务器查询，直到得到最终的 <code>IP</code> 地址告诉本机</li>
<li><strong>迭代查询</strong>：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。</li>
</ul>
</li>
</ul>
<p><strong>DNS优化</strong></p>
<ul>
<li><strong>DNS缓存</strong><br>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</li>
<li><strong>DNS负载均衡</strong><br>DNS可以返回一个合适的机器的 IP 给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</li>
</ul>
<h4 id="tcp链接，三次握手"><a href="#tcp链接，三次握手" class="headerlink" title="tcp链接，三次握手"></a>tcp链接，三次握手</h4><p>在域名解析之后，浏览器向服务器发起了http请求，tcp连接，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。</p>
<p>（1）客户端向服务器发送连接请求报文；<br>（2）服务器端接受客户端发送的连接请求后后回复ACK报文，并为这次连接分配资源。<br>（3）客户端接收到ACK报文后也向服务器端发生ACK报文，并分配资源。</p>
<p>这样TCP连接就建立了。<br>在此之后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个<strong>请求头部</strong>和一个<strong>请求体</strong>。</p>
<h4 id="服务器收到请求"><a href="#服务器收到请求" class="headerlink" title="服务器收到请求"></a>服务器收到请求</h4><p>服务器收到浏览器发送的请求信息，返回一个<strong>响应头</strong>和一个<strong>响应体</strong>。</p>
<h4 id="浏览器页面渲染"><a href="#浏览器页面渲染" class="headerlink" title="浏览器页面渲染"></a>浏览器页面渲染</h4><ul>
<li>处理HTML标记并构建DOM树；</li>
<li>处理CSS标记并构建CSSOM树；</li>
<li>将DOM和CSSOM合并为一颗渲染树，通常为了更好的用户体验，渲染会与解析同时进行，将已经解析好的树渲染出来。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息(重排)</li>
<li>将各个结点绘制到屏幕上(重绘)</li>
<li>如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。</li>
</ul>
<h4 id="断开连接，四次挥手"><a href="#断开连接，四次挥手" class="headerlink" title="断开连接，四次挥手"></a>断开连接，四次挥手</h4><hr>
<h2 id="TCP-UDP-运输层"><a href="#TCP-UDP-运输层" class="headerlink" title="TCP/UDP/运输层"></a>TCP/UDP/运输层</h2><h3 id="UDP和TCP的差别⭐"><a href="#UDP和TCP的差别⭐" class="headerlink" title="UDP和TCP的差别⭐"></a>UDP和TCP的差别⭐</h3><p><strong>UDP：</strong></p>
<ul>
<li><strong>无连接</strong>：减少了开销和发送前时延；</li>
<li><strong>尽最大努力交付</strong>：不保证可靠交付；</li>
<li><strong>面向报文</strong>：对应用层交下来的报文既不合并，也不拆分，保留这些报文的边界。</li>
<li><strong>没有拥塞控制</strong>：网络拥塞不会使源主机发送速率降低，允许在网络拥塞时丢失一些数据，却不允许数据有太大的时延。</li>
<li><strong>支持一对一、一对多、多对一、多对多的交互通信</strong></li>
<li><strong>首部开销小：</strong> 首部长度只有 <strong>8</strong> 字节，比 TCP 的 <strong>20</strong> 字节短。</li>
</ul>
<p><strong>TCP:</strong></p>
<ul>
<li><strong>面向连接：</strong> 传输前需建立连接，传输完成需释放连接；TCP 连接是一条<strong>逻辑连接</strong>。</li>
<li><strong>提供可靠交付：</strong> 无差错、不丢失、不重复、不失序；</li>
<li><strong>面向字节流：</strong> TCP 把应用进程交下来的数据看作<strong>一连串的无结构字节流</strong>；</li>
<li><strong>有拥塞控制</strong></li>
<li><strong>点对点：</strong> 每一条 TCP 连接只能有两个端点；</li>
<li><strong>首部开销大：</strong>20字节</li>
</ul>
<hr>
<h3 id="TCP-UDP数据发送和接收过程"><a href="#TCP-UDP数据发送和接收过程" class="headerlink" title="TCP/UDP数据发送和接收过程"></a>TCP/UDP数据发送和接收过程</h3><h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a><strong>发送端</strong></h4><p>数据发送是发送到物理链路层的，从<strong>应用层</strong>开始，经过一层层的数据报文的封装，最终封装成<strong>以太网封装格式</strong> 和 <strong>802.x 封装格式的数据包</strong>，通过有线网络或无线网络在以太网上传输<strong>数据帧</strong>（bit流）。</p>
<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a><strong>接收端</strong></h4><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568283339430.91a72ae3.png" alt="1568283339430"></p>
<p>接收端和发送端的顺序刚好相反。即分别经过</p>
<ul>
<li>经过数据链路层去掉<strong>以太网的头部</strong>得到<strong>以太网MAC帧</strong></li>
<li>经过网络层去掉<strong>IP的头部</strong>得到<strong>IP数据包</strong></li>
<li>经过传输层去掉 <code>TCP/UDP</code> 的头部得到<strong>报文段/用户数据报</strong></li>
<li>经过应用层得到数据流</li>
</ul>
<p>就完成了整个的数据传输过程。</p>
<h4 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h4><p>应用层所有应用进程都可以通过运输层传输到 <code>IP</code> 层，称为<strong>复用</strong>；运输层从 <code>IP</code> 层收到发送给各应用进程的数据后，必须分别交付给指明的各应用进程，称为<strong>分用</strong>。</p>
<hr>
<h3 id="TCP协议的可靠性体现在哪里"><a href="#TCP协议的可靠性体现在哪里" class="headerlink" title="TCP协议的可靠性体现在哪里"></a>TCP协议的可靠性体现在哪里</h3><ol>
<li><strong>应用数据被分割成TCP认为最适合发送的数据块</strong>。(这和UDP完全不同，应用程序产生的数据报长度将保持不变)。</li>
<li><strong>超时重传:</strong> 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段。</li>
<li><strong>有序编号：</strong>TCP给发送的每一一个包进行编号 ,接收方对数据包进行排序,把有序数据传送给应用层。（TCP报文段作为IP数据报来传输，IP数据报的大刀可能会失序，因此TCP报文段的到达也可能会失序，如果必要，TCP将对收到的数据进行<strong>重新排序</strong>）。</li>
<li><strong>校验和</strong>: TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错, TCP将丢弃这个报文段和不确认收到此报文段。</li>
<li>IP数据报会发生重复，TCP的接收端会<strong>丢弃重复</strong>的数据。</li>
<li><strong>流量控制:</strong> TCP连接的每一方都有固定大小的缓冲空间 , TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据,能提示发送方降低发送的速率,防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时,减少数据的发送。</li>
<li><strong>确认响应</strong>：对于一个收到的请求，将发送一个确认。这个确认通常要延迟几分之一秒。</li>
</ol>
<p>TCP协议保证数据传输可靠性的方式主要有：</p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。<br><strong>发送方</strong>：在发送数据之前计算检验和，并进行校验和的填充。<br><strong>接收方</strong>：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01091.jpg" alt="这里写图片描述"></p>
<h4 id="序列号-ACK-和确认应答"><a href="#序列号-ACK-和确认应答" class="headerlink" title="序列号(ACK)和确认应答"></a>序列号(ACK)和确认应答</h4><p><code>TCP</code> 传输时将每个字节的数据都进行了编号，这就是序列号。确认应答：<code>TCP</code> 传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送 <code>ACK</code> 报文。这个 <code>ACK</code> 报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是 <code>TCP</code> 传输可靠性的保证之一。</p>
<h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 <code>ACK</code> 报文，并解析 <code>ACK</code> 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的 <code>ACK</code> 报文，这该怎么办呢？而没有收到 <code>ACK</code> 报文的原因可能是什么呢？</p>
<p>首先，发送方没有介绍到响应的 <code>ACK</code> 报文原因可能有两点：</p>
<ol>
<li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本<strong>没有接收</strong>到。</li>
<li>接收方接收到了响应的数据，但是发送的 <code>ACK</code> 报文响应却由于网络原因<strong>丢包</strong>了。</li>
</ol>
<p>TCP在解决这个问题的时候引入了一个新的机制，叫做<strong>超时重传机制</strong>。简单理解就是发送方在发送完数据后等待一个时间(<strong>500ms的整数倍</strong>)，时间到达没有接收到 <code>ACK</code> 报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行 <code>ACK</code> 应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送 <code>ACK</code> 应答。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而<strong>TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制</strong>。在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送 <code>ACK</code> 报文时，将自己的即时窗口大小填入，并跟随 <code>ACK</code> 报文一起发送过去。而发送方根据 <code>ACK</code> 报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01092.jpg" alt="这里写图片描述"></p>
<h4 id="滑动窗口-以字节为单位"><a href="#滑动窗口-以字节为单位" class="headerlink" title="滑动窗口(以字节为单位)"></a>滑动窗口(以字节为单位)</h4><ul>
<li>假定 <code>A</code> 收到来自 <code>B</code> 的确认报文段，其中窗口是 20 字节，确认号是 31 (表明 <code>B</code> 期望收到的下一个序号是 31)。根据这两个数据， <code>A</code> 构造出自己的发送窗口。</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01093.jpg" alt="1568790013316"></p>
<ul>
<li><p>发送窗口由<strong>前沿</strong>和<strong>后沿</strong>共同确定。发送窗口通常<strong>不断向前移动</strong>，也有<strong>可能不动</strong>（一是没有收到新的确认；二是收到了新的确认但对方通知窗口缩小了，因此只有后沿缩小，前沿正好不动）。</p>
</li>
<li><p>描述一个发送窗口的状态需要<strong>三个指针</strong>：$P_1,P_2,P_3$，指针指向字节序号。</p>
<ul>
<li>小于 $P_1$ 是已经发送并<strong>收到确认</strong>的部分</li>
<li>$P_1 - P_2$ 是已经发送但<strong>未收到确认</strong>的部分</li>
<li>$P_2 - P_3$ 是<strong>窗口内允许发送</strong>但<strong>尚未发送</strong>的部分</li>
<li>大于 $P_3$ 是<strong>窗口外不允许发送</strong>的部分</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568790430010.9e25f59d.png" alt="1568790430010"></p>
</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><ul>
<li><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568796886603.87101025.png" alt="1568796886603"></p>
</li>
<li><p>发送方窗口的上限值应取<strong>接收方窗口 rwnd 和拥塞窗口 cwnd 两个变量中的较小值</strong>：</p>
</li>
<li><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p>
</li>
<li><p>TCP拥塞控制由四个部分组成：<strong>慢开始，拥塞避免，快重传，快恢复</strong></p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568796161225.0a85de7d.png" alt="1568796161225"></p>
</li>
</ul>
<h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a><strong>慢开始</strong></h5><ul>
<li>在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做<strong>拥塞窗口(cwnd)<strong>的概念。发送刚开始定义拥塞窗口为 <code>1</code>，在传输的过程中以</strong>2的倍数</strong>指数增大 <code>cwnd</code> 直至其大于 <code>ssthreshold</code> ，之后转为<strong>拥塞避免</strong>，<strong>每次收到ACK应答，拥塞窗口加 1</strong>。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</li>
</ul>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h5><ul>
<li>当出现报文丢失时（既发生重传时），认定网络出现拥塞。将 <code>ssthreshold/=2</code> ，并初始化 <code>cwnd=1</code> 重新开始算法。</li>
</ul>
<h5 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a><strong>快重传</strong></h5><p>让发送方尽早<strong>知道个别报文段的丢失</strong>，以至于<strong>不需超时重传</strong>。使用快重传可以使整个网络吞吐量提升 20% 。</p>
<ul>
<li>快重传要求接收方不要等待自己发送数据时才捎带确认，而是<strong>立即发送确认</strong>；即使收到了失序的报文段也要立即发出对已收到的报文段的<strong>重复确认</strong>。</li>
<li>如下图所示，发送方只要<strong>一连收到 3 个重复确认ACK</strong>，就知道接收方没有收到 <code>M3</code> ，而<strong>立即重传 M3</strong> 。</li>
</ul>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568796172902.50a3f779.png" alt="1568796172902"></p>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a><strong>快恢复</strong></h5><p>当接收到连续 3 个重复确认时，知道只是丢失了个别报文段，于是不启动慢开始，而是执行快恢复。</p>
<ul>
<li>发送方调整门限值 <strong>ssthresh = cwnd / 2</strong>；同时设置 <strong>cwnd = ssthresh</strong> ，立即进入<strong>拥塞避免</strong>。</li>
<li>这样做的好处是<strong>避免个别丢失的报文段被误认为是网络拥塞造成。</strong></li>
</ul>
<hr>
<h3 id="TCP-和UDP报文段首部"><a href="#TCP-和UDP报文段首部" class="headerlink" title="TCP 和UDP报文段首部"></a>TCP 和UDP报文段首部</h3><p><strong>TCP</strong></p>
<ul>
<li>TCP 报文段首部前 <code>20</code> 字节固定，后面有 <code>4n</code> 字节可根据需要加选项。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20181130165347546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzA4MDI3,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20181130165347546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMzA4MDI3,size_16,color_FFFFFF,t_70" alt="图片来源于网络"></a></p>
<ul>
<li><strong>源端口和目的端口：</strong> 各占 <strong>2</strong> 字节；TCP 的分用功能通过端口实现。</li>
<li><strong>序号(seq)：</strong> 占 <strong>4</strong> 字节（序号范围 $[0,2^{32}-1]$）；TCP 传送的<strong>字节流</strong>中每一个字节都<strong>按顺序编号</strong>；序号字段代表本报文段发送数据的<strong>第一个字节的序号</strong>，例如一报文段序号 <code>301</code> ，最后一个字节序号 <code>400</code> ，那么下一个报文段的数据序号应当从 <code>401</code> 开始。</li>
<li><strong>确认号(ACK)<strong>：占 <strong>4</strong> 字节；代表</strong>期望收到对方下一个报文段第一个数据字节的序号</strong>；例如 <code>B</code> 正确收到一个报文段，序号字段是 <code>501</code>，数据长度是 <code>200</code> 字节，则 <code>B</code> 期望收到下一个数据序号是 <code>701</code> ，即将发送给 <code>A</code> 的确认报文段中的确认号置为 <code>701</code> 。若确认号 = <code>N</code>，代表直到序号 <code>N-1</code> 的所有数据都已正确收到。</li>
<li><strong>数据偏移</strong>：占 <strong>4</strong> 字节；指出 TCP 报文段<strong>数据起始处</strong>距离 TCP 报文段起始处的距离；能表示的最大十进制数字为 15，因此数据偏移最大值是 60 字节，也是 TCP 首部的最大长度。</li>
<li><strong>保留：</strong> 占 <strong>6</strong> 位，保留今后使用，应设置为 0；</li>
<li><strong>紧急 URG (urgent)：</strong> 当 <strong>URG = 1</strong> 时，表明紧急指针字段有效。发送方 TCP 把紧急数据插入到本报文段数据的<strong>最前面</strong>。</li>
<li><strong>确认 ACK (acknowledgment)<strong>：仅当 <strong>ACK = 1</strong> 时</strong>确认号</strong>字段有效。TCP 规定，在连接建立后所有传送的报文段应将 <code>ACK</code> 置 1 。</li>
<li><strong>推送 PSH (push)：</strong> 当两个应用进程交互式通信时，一段应用进程希望键入一个命令后立即收到对方响应；推送操作很少使用。</li>
<li><strong>复位 RST (reset)：</strong> <code>RST = 1</code> 代表 TCP 出现严重差错（例如主机崩溃），必须释放连接； <code>RST</code> 还用来拒绝一个非法的报文段或拒绝打开一个连接。</li>
<li><strong>同步 SYN (synchronization)：</strong> 连接建立时用来同步序号。当 <code>SYN = 1</code> 而 <code>ACK = 0</code> 时，表明这是一个<strong>连接请求</strong>报文段。<code>SYN = 1</code> 和 <code>ACK = 1</code> 就表示<strong>连接接受</strong>。</li>
<li><strong>终止 FIN (finish)：</strong> 用来释放一个连接。当 <code>FIN = 1</code> 时，表明发送方数据已经发送完毕，并要求<strong>释放连接</strong>。</li>
<li><strong>窗口：</strong> 占 <strong>2</strong> 字节；指发送本报文段的一方的<strong>接收窗口</strong>（窗口大小是由接收方定的，作为发送方设置其发送窗口的依据）。窗口字段明确指出了现在允许对方发送的数据量。窗口值是动态变化的。</li>
<li><strong>检验和：</strong> 占 <strong>2</strong> 字节；检验范围包括<strong>首部和数据</strong>两部分。计算检验和前需要在 TCP 报文段前面加上 12 字节的伪首部，格式与 UDP 伪首部一样，但应把第 4 个字段中的 17 改为 6 （TCP 协议号为 6 ），把第 5 个字段中 UDP 长度改为 TCP 长度。</li>
<li><strong>紧急指针：</strong>占 <strong>2</strong> 字节；仅在 <code>URG = 1</code> 时才有意义，指出本报文段中紧急数据的字节数（紧急数据后都是普通数据），紧急指针指出了紧急数据的末尾所在报文段中的位置；窗口为 0 时也可发紧急数据。</li>
<li><strong>选项：</strong> 长度可变，<strong>最长 40 字节</strong>。<strong>无选项时， TCP 首部长度为 20 字节。</strong></li>
</ul>
<p><strong>UDP</strong></p>
<p>相应的，<code>UDP</code> 的报文段只有<strong>源端口+目的端口+长度+检验和：</strong> 各占 <strong>2</strong> 字节，<strong>首部长度为8字节。</strong></p>
<p><strong>长度字段：</strong>占<code>16</code>比特。标明 <code>UDP</code> 头部和 <code>UDP</code> 数据的总长度字节，<code>UDP</code> 首部的长度为固定的 <code>8</code> 个字节，加上 <code>UDP</code> 数据长度就是长度大小，<code>UDP</code> 数据长度可以通过 <code>wireshark</code> 抓包看到。</p>
<p><a target="_blank" rel="noopener" href="https://krahets.gitee.io/assets/img/1568704529477.08a8d8a2.png"><img src="https://krahets.gitee.io/assets/img/1568704529477.08a8d8a2.png" alt="1568704529477"></a></p>
<h3 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。</p>
<p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p>
</li>
<li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p>
</li>
<li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p>
<p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</li>
</ul>
<p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568797056445.aa1412a3.png" alt="1568797056445"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568797480363.f8ec5647.png" alt="1568797480363"></p>
<ol>
<li><p>A 发送 TCP 连接释放报文，进入 <strong>FIN-WAIT-1</strong> 状态，<strong>等待 B 的确认</strong>；</p>
</li>
<li><p>B 收到报文段后立即发出确认，并进入 <strong>CLOSE-WAIT</strong> 状态；此时 A 到 B 的单向连接已经被释放， TCP 连接处于<strong>半关闭状态</strong>；B 继续向 A 传输未完成的数据。</p>
</li>
<li><p>A收到 B 的确认后，进入 <strong>FIN-WAIT-2</strong> 状态，<strong>等待 B 的连接释放报文段</strong>；</p>
</li>
<li><p>若 B已经将所有数据向 A 发送完毕，则向 A发送 TCP 连接释放报文，并进入 <strong>LAST-ACK</strong> 状态，<strong>等待 A 的确认</strong>；</p>
</li>
<li><p>A收到B的连接释放报文段后，立即发出确认，然后进入TIME-WAIT状态，必须经过时间等待计时器 设置的时间2MSL(4 min)后，A才进入CLOSED状态，这是因为：</p>
<ul>
<li><p><strong>第一：</strong> 由于 A 到 B的最后的 <code>ACK</code> 确认报文段有可能丢失，B 可能会超时重传释放连接报文段，而 <code>A</code> 就能在 <code>2MSL</code> 时间内收到这个重传的连接释放报文段，并重传确认且重新启动 <code>2MSL</code> 计时器。</p>
</li>
<li><p><strong>第二：</strong> 防止<strong>“已失效的连接请求报文段”</strong>出现在本连接中， <code>A</code> 等待 <code>2MSL</code> 就可以使本链接持续时间内所产生的所有报文段在网络中消失。MSL是任何报文段被丢弃前在网络内的最长时间</p>
</li>
</ul>
</li>
</ol>
<p><strong>其实可以理解为：seq就是发送者id，ack就是接受者id</strong></p>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ol>
<li><p><strong>为什么需要三次握手，两次不行吗？</strong></p>
<p>防止已失效的连接请求又传送到服务器端，因而产生错误：</p>
<p>假设 <code>A</code> 发出的第一个连接请求报文段没有丢失，而是在网络某处长时间滞留了，本来这是一个失效的连接请求；但后续 <code>B</code> 收到了它，误认为是 <code>A</code> 的连接请求，就向 <code>A</code> 发出确认报文段。若不采用三报文握手，此时一个已经失效的连接已经被建立，网络资源被白白浪费了。</p>
<p>第二次握手结束时，不能确定客户端的接收能力正常</p>
</li>
<li><p><strong>TCP三次握手，如果第三次客户端发出的信息服务器没收到怎么办</strong></p>
<p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p>
<p>服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>
</li>
<li><p><strong>ISN(Initial Sequence Number)是固定的吗</strong></p>
<p>就是图中的seq，不是固定的，ISN随时间而变化，因此每个连接都将具有不同的ISN。固定的容易被攻击。</p>
</li>
<li><p><strong>三次握手过程中可以携带数据么</strong></p>
<p>第三次握手的时候，可以携带。前两次握手不能携带数据。</p>
<p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。</p>
<p>而对于第三次握手，此时客户端已经建立了连接，已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。</p>
</li>
<li><p><strong>挥手为什么需要四次？</strong></p>
<p>因为服务端收到关闭请求的时候可能还有数据要传送，所以需要先把数据传送完，才发FIN请求，所以多了一次。</p>
</li>
<li><p><strong>大量TIME_WAIT造成的影响</strong></p>
<p>在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p>
<ul>
<li>高并发可以让服务器在短时间范围内同时占用大量端口，而端口是有限的</li>
<li>短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。</li>
</ul>
<p>持续的到达一定量的高并发短连接，会使服务器因端口资源不足而拒绝为一部分客户服务。</p>
</li>
</ol>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190718154523875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></a></p>
<p><code>Socket</code> 是应用层与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，<code>Socket</code> 其实就是一个门面模式，它把复杂的 <code>TCP/IP</code> 协议族隐藏在 <code>Socket</code> 接口后面，对用户来说，一组简单的接口就是全部，让<code>Socket</code> 去组织数据，以符合指定的协议。</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70"><img src="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></a></p>
<p>先从服务器端说起。服务器端先初始化 <code>Socket</code> ，然后与端口绑定( <code>bind</code> )，对端口进行监听( <code>listen</code> )，调用 <code>accept</code> 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 <code>Socket</code> ，然后连接服务器( <code>connect</code> )，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>
<h5 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而<strong>socket()<strong>用于创建一个</strong>socket描述符（socket descriptor）</strong>，它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<ul>
<li><strong>domain</strong>：即<strong>协议域</strong>，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li>
<li><strong>type</strong>：<strong>指定socket类型</strong>。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</li>
<li><strong>protocol</strong>：<strong>指定协议</strong>。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议等等。</li>
</ul>
<h5 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h5><p>正如上面所说 <code>bind()</code> 函数把一个地址族中的特定地址赋给 <code>socket</code> 。例如对应 <code>AF_INET</code> 、<code>AF_INET6</code> 就是把一个 <code>ipv4</code> 或 <code>ipv6</code> 地址和端口号组合赋给 <code>socket</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<h5 id="listen-connect函数"><a href="#listen-connect函数" class="headerlink" title="listen/connect函数"></a>listen/connect函数</h5><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h5 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h5><p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br></pre></td></tr></table></figure>

<h4 id="read-write函数"><a href="#read-write函数" class="headerlink" title="read/write函数"></a>read/write函数</h4><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read()/write()</span><br><span class="line">recv()/send()</span><br><span class="line">readv()/writev()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure>

<h3 id="UDP实现可靠传输：RUDP"><a href="#UDP实现可靠传输：RUDP" class="headerlink" title="UDP实现可靠传输：RUDP"></a>UDP实现可靠传输：RUDP</h3><p>UDP要实现可靠传输，可以在应用层实现TCP的那些可靠传输功能，例子是QUIC。</p>
<p>RUDP主要是通过重传来实现可靠传输的。</p>
<h3 id="SOCKET通信中TCP、UDP数据包大小的确定"><a href="#SOCKET通信中TCP、UDP数据包大小的确定" class="headerlink" title="SOCKET通信中TCP、UDP数据包大小的确定"></a>SOCKET通信中TCP、UDP数据包大小的确定</h3><p><code>UDP</code> 和 <code>TCP</code> 协议利用端口号实现多项应用同时发送和接收数据。数据通过源端口发送出去，通过目标端口接收。有的网络应用只能使用预留或注册的静态端口；而另外一些网络应用则可以使用未被注册的动态端口。因为 <code>UDP</code> 和 <code>TCP</code> 报头使用两个字节存放端口号，所以端口号的有效范围是从 <code>0</code> 到 <code>65535</code> 。动态端口的范围是从 <code>1024</code> 到 <code>65535</code> 。</p>
<p><strong>MTU最大传输单元</strong></p>
<ul>
<li>由于以太网最大的数据帧是 <code>1518Bytes</code> ，刨去以太网帧的帧头（DMAC目的MAC地址<strong>6Bytes</strong>+SMAC源MAC地址<strong>6Bytes</strong>+Type域<strong>2bytes</strong>）<strong>14Bytes</strong>和<strong>帧尾CRC校验部分4Bytes</strong> 那么剩下承载上层协议的地方也就是Data域最大就只能有<strong>1500Bytes</strong>这个值我们就把它称之为<strong>MTU</strong>。</li>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 <strong>MTU = 1500</strong> 字节，若长度超过 <code>MTU</code> 值，就必须把数据报分片处理。</li>
<li>虽然尽可能长的 <code>IP</code> 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
<p>因此：</p>
<p><strong>UDP</strong> 包的大小就应该是 <strong>1500 - IP头(20) - UDP头(8) = 1472(BYTES)</strong><br><strong>TCP</strong> 包的大小就应该是 <strong>1500 - IP头(20) - TCP头(20) = 1460 (BYTES)</strong></p>
<p>在用 <code>Socket</code> 编程时， <code>UDP</code>协议要求包小于 <code>64K</code> ，<code>TCP</code>没有限定。</p>
<p>不过鉴于Internet上的<strong>标准MTU</strong>值为<strong>576字节</strong>，所以建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在**548字节 (576-8-20)**以内。</p>
<hr>
<h2 id="IP-网络层"><a href="#IP-网络层" class="headerlink" title="IP/网络层"></a>IP/网络层</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>子网掩码确定ip地址哪部分是网络地址，哪部分是主机地址。</p>
<p>IP协议是不可靠的，非连接。传送的数据可能丢失、重复、失序。</p>
<h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>地址解析协议</p>
<p>同一子网下广播找到对应IP地址的MAC地址。</p>
<p>计算机网络是如何根据IP地址定位到一台主机的</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568551356084.394e4465.png" alt="1568551356084"></p>
<ul>
<li><p>APR 协议作用：已经知道一个机器的IP 地址，需要找出对应的硬件地址。</p>
<ul>
<li><strong>RARP 协议</strong>：现在的 <code>DHCP</code> 协议包含逆地址解析协议功能，即从<strong>硬件地址</strong>找出其 <strong>IP 地址</strong>。</li>
</ul>
</li>
<li><p>ARP 协议工作原理：网络层使用IP地址，但实际网络链路上传送数据帧时，最终必须使用该网络的硬件地址(MAC)。ARP解决方法是在主机 ARP 高速缓存中存放一个从IP地址到硬件地址的映射表，并实时动态更新（新增或超时删除）。</p>
<ul>
<li>当主机 A 要向主机 B 发送 <code>IP</code> 数据报时，就在其 <code>ARP</code> 高速缓存中查看有无主机 B 的 <code>IP</code> 地址，如有就查找并<strong>写入 MAC 帧</strong>，并传输。</li>
</ul>
</li>
<li><p>有可能查不到主机 B 的 <code>IP</code> 地址，可能主机 B 刚入网，可能主机 A 刚加电（高速缓存为空）。在这种情况下，主机 A 就自动运行 <code>ARP</code>，通过广播请求分组找出主机 B 的硬件地址。</p>
</li>
<li><p>ARP 协议工作流程：</p>
<ol>
<li>主机 A 在本局域网上发送一个 <code>ARP</code> 请求分组，在本局域网上所有主机上运行的 <code>ARP</code> 进程都收到此请求分组。</li>
<li>主机 B 收下这个 <code>ARP</code> 请求，并向主机 A 发送响应分组（普通的单播，发送给主机 A ）。同时，把请求分组里 A 的 <code>IP</code> 地址到硬件地址的映射写入主机 B 的 <code>ARP</code> 高速缓存中。</li>
<li>主机 A 收到主机 B 的响应分组后，就在 <code>ARP</code> 高速缓存中写入主机 B 的 <code>IP</code> 地址到硬件地址的映射。</li>
</ol>
</li>
<li><p><strong>ARP生存时间：</strong> 超过生存时间（例如 10 ~ 20 分钟）的项目从高速缓存中删掉。这样如果 B 更换了设备， A 无法找到原主机 B ，但过了一段时间， A 的 <code>ARP</code> 高速缓存中已经删除了 B 原先硬件地址，于是 A 重新广播发送 <code>ARP</code> 请求分组，找到新的 B 硬件地址。</p>
</li>
</ul>
<hr>
<h4 id="ICMP-IGMP"><a href="#ICMP-IGMP" class="headerlink" title="ICMP/IGMP"></a>ICMP/IGMP</h4><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568288257688.197541c0.png" alt="1568288257688"></p>
<h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a><strong>ICMP</strong></h5><p>网际控制报文协议</p>
<ul>
<li><p>报文种类：允许主机或路由器报告差错情况和提供有关异常情况的报告</p>
<ul>
<li><p>ICMP 差错报告报文和 ICMP 询问报文</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/1568635687315.e67e9b59.png" alt="1568635687315"></p>
</li>
</ul>
</li>
<li><p>ICMP应用：</p>
<ul>
<li><strong>Ping</strong> ：使用了 ICMP 的回送请求和回送回答报文。</li>
<li><strong>Traceroute</strong>：发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h5><p>网际组管理协议 </p>
<h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>网络地址转换</p>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<h4 id="IP-数据报的格式"><a href="#IP-数据报的格式" class="headerlink" title="IP 数据报的格式"></a>IP 数据报的格式</h4><p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01094.jpg" alt="img"></p>
<p><strong>首部固定字段</strong></p>
<ol>
<li><p><strong>版本：</strong> 占 4 位；指 IP 协议版本。通信双方使用的 IP 协议版本需一致。</p>
</li>
<li><p><strong>首部长度：</strong> 占 4 位；单位是 32 位字（4 字节）。</p>
</li>
<li><p><strong>区分服务：</strong> 占 8 位；只有在使用区分服务时才使用，一般情况不使用。</p>
</li>
<li><p>总长度：</p>
<p>占 16 位；指首部和数据长度之和；单位为字节，因此数据报最大长度为 $2^{16}-1=65536$字节</p>
<ul>
<li>数据链路层规定了<strong>数据帧中数据字段的最大长度 MTU</strong> ，最常用的以太网规定 MTU = 1500 字节，若长度超过 MTU 值，就必须把数据报分片处理。</li>
</ul>
</li>
</ol>
<ul>
<li>虽然尽可能长的 IP 数据报会使传输效率变高（首部长度占比小），但数据报短路由器转发速度也更快。</li>
</ul>
<ol start="5">
<li><p>标识</p>
<p>：占 16 位。 每产生一个 IP 数据报，计数器 +1。</p>
<ul>
<li>这个标识并不是序号（网络层不负责按序接收）；</li>
<li>在由于长度超过 MTU 而被分片时，标识字段值被复制到所有分片的标识字段，使各数据报片最后能正确地组装成原来的数据报。</li>
</ul>
</li>
<li><p>标志</p>
<p>：占 3 位，目前仅前 2 位有意义。</p>
<ul>
<li>最低位记为 MF (More Fragment) ，MF = 1 表示后面“还有分片”数据报，MF = 0 表示这是若干数据报片中的最后一个。</li>
<li>中间一位记为 DF (Don’t Fragment) ， DF = 1 表示不能分片，DF = 0 才允许分片。</li>
</ul>
</li>
<li><p>片偏移：</p>
<p>占 13 位；表示数据报在分片后，某片在原分组中的相对位置；单位是 8 字节。</p>
<ul>
<li>每个分片的长度一定是 8 字节（64 位）的整数倍。</li>
</ul>
</li>
<li><p>生存时间（TTL）</p>
<p>：占 8 位；表示数据报在网络中的寿命。防止数据报在互联网中无限制兜圈子。</p>
<ul>
<li>最初设计 TTL 以秒为单位，消耗时间小于 1s 则将 TTL 减 1 。</li>
<li>目前路由器处理数据报时间一般远远小于 1s ，后来 TTL 字段功能改为<strong>“跳数限制”</strong>，路由器每次转发数据之前把 TTL 减 1 ，当 TTL = 0 就丢失这个数据报。</li>
<li>数据报能在互联网中经过路由器的最大数值是 $255=(2^8 - 1)$。若设置 TTL = 1 ，则表示此数据报只能在本局域网中传送。</li>
</ul>
</li>
<li><p><strong>协议：</strong> 占 8 位；表示此数据报中携带的数据使用何种协议，以便接收方主机 IP 层直到应将数据上交给哪个协议处理。</p>
</li>
<li><p><strong>首部校验和：</strong> 占 16 位；只检验数据报的首部，不包括数据部分（减少计算量）。</p>
<p>计算方法：同TCP校验和计算方法：对IP头部中的每16bit进行二进制求和，进位加到低位，最后取反</p>
</li>
<li><p><strong>源地址：</strong> 占 32 位；</p>
</li>
<li><p><strong>目的地址：</strong> 占 32 位。</p>
</li>
</ol>
<p><strong>首部可变部分</strong></p>
<ul>
<li>IP 数据报首部的可变部分就是一个<strong>选项字段</strong>，用来支持<strong>排错、测量、安全措施</strong>等。</li>
<li>长度 <strong>1 - 40</strong> 字节，取决于选择的项目。</li>
<li>可变部分是用来增加 IP 数据报的功能，实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 <strong>IPv6 就将 IP 数据报的首部长度做成固定的</strong>。</li>
</ul>
<hr>
<h3 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h3><ol>
<li> 工作层次：交换机主要工作在数据链路层，路由器主要工作在网络层 </li>
<li> 转发依据：交换机转发依据的对象是MAC地址，路由器转发依据的对象是IP地址 </li>
<li> 功能：交换机功能较简单，只是将主机连接起来组件局域网，路由器可以将局域网连接起来，还能分割广播域，还能提供防火墙 </li>
</ol>
<h3 id="MAC表、路由表、ARP表的字段"><a href="#MAC表、路由表、ARP表的字段" class="headerlink" title="MAC表、路由表、ARP表的字段"></a>MAC表、路由表、ARP表的字段</h3><ul>
<li>MAC表 </li>
</ul>
<p> <img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01096.jpg" alt="img">  </p>
<ul>
<li>路由表 </li>
</ul>
 <img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01097.jpg" alt="img" style="zoom:80%;" />  

 <img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01098.jpg" alt="img" style="zoom:80%;" />  

<ul>
<li>ARP表 </li>
</ul>
<p> <img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/01099.jpg" alt="img">  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/07/mysql/" data-id="ckw9lh01100382ww5d1hb48qe" data-title="计算机网络" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-suixiang" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/03/suixiang/" class="article-date">
  <time class="dt-published" datetime="2021-01-02T16:28:39.000Z" itemprop="datePublished">2021-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/03/suixiang/">捐献</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>无他</p>
<p>登记了器官和眼角膜捐献</p>
<p>以上</p>
<p><img src="https://ifwant-pic-1303131123.cos.ap-nanjing.myqcloud.com/photo/juanxian.jpg" alt="电子卡"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/03/suixiang/" data-id="ckw9lgzz7001z2ww5cwey8cvv" data-title="捐献" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DIY/" rel="tag">DIY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" rel="tag">学术交流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F/" rel="tag">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9F%B3%E4%B9%90/" rel="tag">音乐</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" rel="tag">高并发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/DIY/" style="font-size: 12px;">DIY</a> <a href="/tags/JAVA/" style="font-size: 18px;">JAVA</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">学习</a> <a href="/tags/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81/" style="font-size: 12px;">学术交流</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 12px;">数据库</a> <a href="/tags/%E6%B8%B8%E6%88%8F/" style="font-size: 10px;">游戏</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 14px;">算法</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%9F%B3%E4%B9%90/" style="font-size: 12px;">音乐</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/" style="font-size: 16px;">高并发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/15/musicScore/">小提琴谱子</a>
          </li>
        
          <li>
            <a href="/2021/05/15/musicTheory/">基本乐理</a>
          </li>
        
          <li>
            <a href="/2021/05/09/qianyi/">网站迁移</a>
          </li>
        
          <li>
            <a href="/2021/05/05/mybatis/">MyBatis</a>
          </li>
        
          <li>
            <a href="/2021/04/25/maven/">Maven</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>